var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// built-in-modules:node:buffer
var node_buffer_exports = {};
import * as node_buffer_star from "node:buffer";
var init_node_buffer = __esm({
  "built-in-modules:node:buffer"() {
    __reExport(node_buffer_exports, node_buffer_star);
  }
});

// built-in-modules:node:async_hooks
var node_async_hooks_exports = {};
import * as node_async_hooks_star from "node:async_hooks";
var init_node_async_hooks = __esm({
  "built-in-modules:node:async_hooks"() {
    __reExport(node_async_hooks_exports, node_async_hooks_star);
  }
});

// <stdin>
var __namedExportsObject = {};
var __getNamedExports = (self, globalThis, global) => {
  __namedExportsObject["__chunk_6195"] = (t) => {
    "use strict";
    t.exports = (init_node_buffer(), __toCommonJS(node_buffer_exports));
  };
  __namedExportsObject["__chunk_2067"] = (t) => {
    "use strict";
    t.exports = (init_node_async_hooks(), __toCommonJS(node_async_hooks_exports));
  };
  __namedExportsObject["__chunk_5817"] = (e, t, r) => {
    "use strict";
    let a;
    r.d(t, { pA: () => to, z: () => tl }), function(e10) {
      e10.assertEqual = (e11) => e11, e10.assertIs = function(e11) {
      }, e10.assertNever = function(e11) {
        throw Error();
      }, e10.arrayToEnum = (e11) => {
        let t2 = {};
        for (let r2 of e11)
          t2[r2] = r2;
        return t2;
      }, e10.getValidEnumValues = (t2) => {
        let r2 = e10.objectKeys(t2).filter((e11) => "number" != typeof t2[t2[e11]]), a2 = {};
        for (let e11 of r2)
          a2[e11] = t2[e11];
        return e10.objectValues(a2);
      }, e10.objectValues = (t2) => e10.objectKeys(t2).map(function(e11) {
        return t2[e11];
      }), e10.objectKeys = "function" == typeof Object.keys ? (e11) => Object.keys(e11) : (e11) => {
        let t2 = [];
        for (let r2 in e11)
          Object.prototype.hasOwnProperty.call(e11, r2) && t2.push(r2);
        return t2;
      }, e10.find = (e11, t2) => {
        for (let r2 of e11)
          if (t2(r2))
            return r2;
      }, e10.isInteger = "function" == typeof Number.isInteger ? (e11) => Number.isInteger(e11) : (e11) => "number" == typeof e11 && isFinite(e11) && Math.floor(e11) === e11, e10.joinValues = function(e11, t2 = " | ") {
        return e11.map((e12) => "string" == typeof e12 ? `'${e12}'` : e12).join(t2);
      }, e10.jsonStringifyReplacer = (e11, t2) => "bigint" == typeof t2 ? t2.toString() : t2;
    }(tr || (tr = {})), (ta || (ta = {})).mergeShapes = (e10, t2) => ({ ...e10, ...t2 });
    let n = tr.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), i = (e10) => {
      switch (typeof e10) {
        case "undefined":
          return n.undefined;
        case "string":
          return n.string;
        case "number":
          return isNaN(e10) ? n.nan : n.number;
        case "boolean":
          return n.boolean;
        case "function":
          return n.function;
        case "bigint":
          return n.bigint;
        case "symbol":
          return n.symbol;
        case "object":
          if (Array.isArray(e10))
            return n.array;
          if (null === e10)
            return n.null;
          if (e10.then && "function" == typeof e10.then && e10.catch && "function" == typeof e10.catch)
            return n.promise;
          if ("undefined" != typeof Map && e10 instanceof Map)
            return n.map;
          if ("undefined" != typeof Set && e10 instanceof Set)
            return n.set;
          if ("undefined" != typeof Date && e10 instanceof Date)
            return n.date;
          return n.object;
        default:
          return n.unknown;
      }
    }, s = tr.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
    class o extends Error {
      constructor(e10) {
        super(), this.issues = [], this.addIssue = (e11) => {
          this.issues = [...this.issues, e11];
        }, this.addIssues = (e11 = []) => {
          this.issues = [...this.issues, ...e11];
        };
        let t2 = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t2) : this.__proto__ = t2, this.name = "ZodError", this.issues = e10;
      }
      get errors() {
        return this.issues;
      }
      format(e10) {
        let t2 = e10 || function(e11) {
          return e11.message;
        }, r2 = { _errors: [] }, a2 = (e11) => {
          for (let n2 of e11.issues)
            if ("invalid_union" === n2.code)
              n2.unionErrors.map(a2);
            else if ("invalid_return_type" === n2.code)
              a2(n2.returnTypeError);
            else if ("invalid_arguments" === n2.code)
              a2(n2.argumentsError);
            else if (0 === n2.path.length)
              r2._errors.push(t2(n2));
            else {
              let e12 = r2, a3 = 0;
              for (; a3 < n2.path.length; ) {
                let r3 = n2.path[a3];
                a3 === n2.path.length - 1 ? (e12[r3] = e12[r3] || { _errors: [] }, e12[r3]._errors.push(t2(n2))) : e12[r3] = e12[r3] || { _errors: [] }, e12 = e12[r3], a3++;
              }
            }
        };
        return a2(this), r2;
      }
      static assert(e10) {
        if (!(e10 instanceof o))
          throw Error(`Not a ZodError: ${e10}`);
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, tr.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return 0 === this.issues.length;
      }
      flatten(e10 = (e11) => e11.message) {
        let t2 = {}, r2 = [];
        for (let a2 of this.issues)
          a2.path.length > 0 ? (t2[a2.path[0]] = t2[a2.path[0]] || [], t2[a2.path[0]].push(e10(a2))) : r2.push(e10(a2));
        return { formErrors: r2, fieldErrors: t2 };
      }
      get formErrors() {
        return this.flatten();
      }
    }
    o.create = (e10) => new o(e10);
    let l = (e10, t2) => {
      let r2;
      switch (e10.code) {
        case s.invalid_type:
          r2 = e10.received === n.undefined ? "Required" : `Expected ${e10.expected}, received ${e10.received}`;
          break;
        case s.invalid_literal:
          r2 = `Invalid literal value, expected ${JSON.stringify(e10.expected, tr.jsonStringifyReplacer)}`;
          break;
        case s.unrecognized_keys:
          r2 = `Unrecognized key(s) in object: ${tr.joinValues(e10.keys, ", ")}`;
          break;
        case s.invalid_union:
          r2 = "Invalid input";
          break;
        case s.invalid_union_discriminator:
          r2 = `Invalid discriminator value. Expected ${tr.joinValues(e10.options)}`;
          break;
        case s.invalid_enum_value:
          r2 = `Invalid enum value. Expected ${tr.joinValues(e10.options)}, received '${e10.received}'`;
          break;
        case s.invalid_arguments:
          r2 = "Invalid function arguments";
          break;
        case s.invalid_return_type:
          r2 = "Invalid function return type";
          break;
        case s.invalid_date:
          r2 = "Invalid date";
          break;
        case s.invalid_string:
          "object" == typeof e10.validation ? "includes" in e10.validation ? (r2 = `Invalid input: must include "${e10.validation.includes}"`, "number" == typeof e10.validation.position && (r2 = `${r2} at one or more positions greater than or equal to ${e10.validation.position}`)) : "startsWith" in e10.validation ? r2 = `Invalid input: must start with "${e10.validation.startsWith}"` : "endsWith" in e10.validation ? r2 = `Invalid input: must end with "${e10.validation.endsWith}"` : tr.assertNever(e10.validation) : r2 = "regex" !== e10.validation ? `Invalid ${e10.validation}` : "Invalid";
          break;
        case s.too_small:
          r2 = "array" === e10.type ? `Array must contain ${e10.exact ? "exactly" : e10.inclusive ? "at least" : "more than"} ${e10.minimum} element(s)` : "string" === e10.type ? `String must contain ${e10.exact ? "exactly" : e10.inclusive ? "at least" : "over"} ${e10.minimum} character(s)` : "number" === e10.type ? `Number must be ${e10.exact ? "exactly equal to " : e10.inclusive ? "greater than or equal to " : "greater than "}${e10.minimum}` : "date" === e10.type ? `Date must be ${e10.exact ? "exactly equal to " : e10.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e10.minimum))}` : "Invalid input";
          break;
        case s.too_big:
          r2 = "array" === e10.type ? `Array must contain ${e10.exact ? "exactly" : e10.inclusive ? "at most" : "less than"} ${e10.maximum} element(s)` : "string" === e10.type ? `String must contain ${e10.exact ? "exactly" : e10.inclusive ? "at most" : "under"} ${e10.maximum} character(s)` : "number" === e10.type ? `Number must be ${e10.exact ? "exactly" : e10.inclusive ? "less than or equal to" : "less than"} ${e10.maximum}` : "bigint" === e10.type ? `BigInt must be ${e10.exact ? "exactly" : e10.inclusive ? "less than or equal to" : "less than"} ${e10.maximum}` : "date" === e10.type ? `Date must be ${e10.exact ? "exactly" : e10.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e10.maximum))}` : "Invalid input";
          break;
        case s.custom:
          r2 = "Invalid input";
          break;
        case s.invalid_intersection_types:
          r2 = "Intersection results could not be merged";
          break;
        case s.not_multiple_of:
          r2 = `Number must be a multiple of ${e10.multipleOf}`;
          break;
        case s.not_finite:
          r2 = "Number must be finite";
          break;
        default:
          r2 = t2.defaultError, tr.assertNever(e10);
      }
      return { message: r2 };
    }, u = l;
    function c() {
      return u;
    }
    let d = (e10) => {
      let { data: t2, path: r2, errorMaps: a2, issueData: n2 } = e10, i2 = [...r2, ...n2.path || []], s2 = { ...n2, path: i2 };
      if (void 0 !== n2.message)
        return { ...n2, path: i2, message: n2.message };
      let o2 = "";
      for (let e11 of a2.filter((e12) => !!e12).slice().reverse())
        o2 = e11(s2, { data: t2, defaultError: o2 }).message;
      return { ...n2, path: i2, message: o2 };
    };
    function h(e10, t2) {
      let r2 = c(), a2 = d({ issueData: t2, data: e10.data, path: e10.path, errorMaps: [e10.common.contextualErrorMap, e10.schemaErrorMap, r2, r2 === l ? void 0 : l].filter((e11) => !!e11) });
      e10.common.issues.push(a2);
    }
    class p {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        "valid" === this.value && (this.value = "dirty");
      }
      abort() {
        "aborted" !== this.value && (this.value = "aborted");
      }
      static mergeArray(e10, t2) {
        let r2 = [];
        for (let a2 of t2) {
          if ("aborted" === a2.status)
            return f;
          "dirty" === a2.status && e10.dirty(), r2.push(a2.value);
        }
        return { status: e10.value, value: r2 };
      }
      static async mergeObjectAsync(e10, t2) {
        let r2 = [];
        for (let e11 of t2) {
          let t3 = await e11.key, a2 = await e11.value;
          r2.push({ key: t3, value: a2 });
        }
        return p.mergeObjectSync(e10, r2);
      }
      static mergeObjectSync(e10, t2) {
        let r2 = {};
        for (let a2 of t2) {
          let { key: t3, value: n2 } = a2;
          if ("aborted" === t3.status || "aborted" === n2.status)
            return f;
          "dirty" === t3.status && e10.dirty(), "dirty" === n2.status && e10.dirty(), "__proto__" !== t3.value && (void 0 !== n2.value || a2.alwaysSet) && (r2[t3.value] = n2.value);
        }
        return { status: e10.value, value: r2 };
      }
    }
    let f = Object.freeze({ status: "aborted" }), m = (e10) => ({ status: "dirty", value: e10 }), g = (e10) => ({ status: "valid", value: e10 }), y = (e10) => "aborted" === e10.status, b = (e10) => "dirty" === e10.status, v = (e10) => "valid" === e10.status, _ = (e10) => "undefined" != typeof Promise && e10 instanceof Promise;
    function w(e10, t2, r2, a2) {
      if ("a" === r2 && !a2)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t2 ? e10 !== t2 || !a2 : !t2.has(e10))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === r2 ? a2 : "a" === r2 ? a2.call(e10) : a2 ? a2.value : t2.get(e10);
    }
    function E(e10, t2, r2, a2, n2) {
      if ("m" === a2)
        throw TypeError("Private method is not writable");
      if ("a" === a2 && !n2)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof t2 ? e10 !== t2 || !n2 : !t2.has(e10))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === a2 ? n2.call(e10, r2) : n2 ? n2.value = r2 : t2.set(e10, r2), r2;
    }
    "function" == typeof SuppressedError && SuppressedError, function(e10) {
      e10.errToObj = (e11) => "string" == typeof e11 ? { message: e11 } : e11 || {}, e10.toString = (e11) => "string" == typeof e11 ? e11 : null == e11 ? void 0 : e11.message;
    }(tn || (tn = {}));
    class x {
      constructor(e10, t2, r2, a2) {
        this._cachedPath = [], this.parent = e10, this.data = t2, this._path = r2, this._key = a2;
      }
      get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
      }
    }
    let O = (e10, t2) => {
      if (v(t2))
        return { success: true, data: t2.value };
      if (!e10.common.issues.length)
        throw Error("Validation failed but no issues detected.");
      return { success: false, get error() {
        if (this._error)
          return this._error;
        let t3 = new o(e10.common.issues);
        return this._error = t3, this._error;
      } };
    };
    function S(e10) {
      if (!e10)
        return {};
      let { errorMap: t2, invalid_type_error: r2, required_error: a2, description: n2 } = e10;
      if (t2 && (r2 || a2))
        throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      return t2 ? { errorMap: t2, description: n2 } : { errorMap: (t3, n3) => {
        var i2, s2;
        let { message: o2 } = e10;
        return "invalid_enum_value" === t3.code ? { message: null != o2 ? o2 : n3.defaultError } : void 0 === n3.data ? { message: null !== (i2 = null != o2 ? o2 : a2) && void 0 !== i2 ? i2 : n3.defaultError } : "invalid_type" !== t3.code ? { message: n3.defaultError } : { message: null !== (s2 = null != o2 ? o2 : r2) && void 0 !== s2 ? s2 : n3.defaultError };
      }, description: n2 };
    }
    class A {
      constructor(e10) {
        this.spa = this.safeParseAsync, this._def = e10, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (e11) => this["~validate"](e11) };
      }
      get description() {
        return this._def.description;
      }
      _getType(e10) {
        return i(e10.data);
      }
      _getOrReturnCtx(e10, t2) {
        return t2 || { common: e10.parent.common, data: e10.data, parsedType: i(e10.data), schemaErrorMap: this._def.errorMap, path: e10.path, parent: e10.parent };
      }
      _processInputParams(e10) {
        return { status: new p(), ctx: { common: e10.parent.common, data: e10.data, parsedType: i(e10.data), schemaErrorMap: this._def.errorMap, path: e10.path, parent: e10.parent } };
      }
      _parseSync(e10) {
        let t2 = this._parse(e10);
        if (_(t2))
          throw Error("Synchronous parse encountered promise.");
        return t2;
      }
      _parseAsync(e10) {
        return Promise.resolve(this._parse(e10));
      }
      parse(e10, t2) {
        let r2 = this.safeParse(e10, t2);
        if (r2.success)
          return r2.data;
        throw r2.error;
      }
      safeParse(e10, t2) {
        var r2;
        let a2 = { common: { issues: [], async: null !== (r2 = null == t2 ? void 0 : t2.async) && void 0 !== r2 && r2, contextualErrorMap: null == t2 ? void 0 : t2.errorMap }, path: (null == t2 ? void 0 : t2.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e10, parsedType: i(e10) }, n2 = this._parseSync({ data: e10, path: a2.path, parent: a2 });
        return O(a2, n2);
      }
      "~validate"(e10) {
        var t2, r2;
        let a2 = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: e10, parsedType: i(e10) };
        if (!this["~standard"].async)
          try {
            let t3 = this._parseSync({ data: e10, path: [], parent: a2 });
            return v(t3) ? { value: t3.value } : { issues: a2.common.issues };
          } catch (e11) {
            (null === (r2 = null === (t2 = null == e11 ? void 0 : e11.message) || void 0 === t2 ? void 0 : t2.toLowerCase()) || void 0 === r2 ? void 0 : r2.includes("encountered")) && (this["~standard"].async = true), a2.common = { issues: [], async: true };
          }
        return this._parseAsync({ data: e10, path: [], parent: a2 }).then((e11) => v(e11) ? { value: e11.value } : { issues: a2.common.issues });
      }
      async parseAsync(e10, t2) {
        let r2 = await this.safeParseAsync(e10, t2);
        if (r2.success)
          return r2.data;
        throw r2.error;
      }
      async safeParseAsync(e10, t2) {
        let r2 = { common: { issues: [], contextualErrorMap: null == t2 ? void 0 : t2.errorMap, async: true }, path: (null == t2 ? void 0 : t2.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e10, parsedType: i(e10) }, a2 = this._parse({ data: e10, path: r2.path, parent: r2 });
        return O(r2, await (_(a2) ? a2 : Promise.resolve(a2)));
      }
      refine(e10, t2) {
        let r2 = (e11) => "string" == typeof t2 || void 0 === t2 ? { message: t2 } : "function" == typeof t2 ? t2(e11) : t2;
        return this._refinement((t3, a2) => {
          let n2 = e10(t3), i2 = () => a2.addIssue({ code: s.custom, ...r2(t3) });
          return "undefined" != typeof Promise && n2 instanceof Promise ? n2.then((e11) => !!e11 || (i2(), false)) : !!n2 || (i2(), false);
        });
      }
      refinement(e10, t2) {
        return this._refinement((r2, a2) => !!e10(r2) || (a2.addIssue("function" == typeof t2 ? t2(r2, a2) : t2), false));
      }
      _refinement(e10) {
        return new e_({ schema: this, typeName: to.ZodEffects, effect: { type: "refinement", refinement: e10 } });
      }
      superRefine(e10) {
        return this._refinement(e10);
      }
      optional() {
        return ew.create(this, this._def);
      }
      nullable() {
        return eE.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ea.create(this);
      }
      promise() {
        return ev.create(this, this._def);
      }
      or(e10) {
        return ei.create([this, e10], this._def);
      }
      and(e10) {
        return el.create(this, e10, this._def);
      }
      transform(e10) {
        return new e_({ ...S(this._def), schema: this, typeName: to.ZodEffects, effect: { type: "transform", transform: e10 } });
      }
      default(e10) {
        return new ex({ ...S(this._def), innerType: this, defaultValue: "function" == typeof e10 ? e10 : () => e10, typeName: to.ZodDefault });
      }
      brand() {
        return new ek({ typeName: to.ZodBranded, type: this, ...S(this._def) });
      }
      catch(e10) {
        return new eO({ ...S(this._def), innerType: this, catchValue: "function" == typeof e10 ? e10 : () => e10, typeName: to.ZodCatch });
      }
      describe(e10) {
        return new this.constructor({ ...this._def, description: e10 });
      }
      pipe(e10) {
        return eT.create(this, e10);
      }
      readonly() {
        return eP.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    }
    let k = /^c[^\s-]{8,}$/i, T = /^[0-9a-z]+$/, P = /^[0-9A-HJKMNP-TV-Z]{26}$/i, C = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, I = /^[a-z0-9_-]{21}$/i, R = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, N = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, $ = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, j = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, L = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, M = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, D = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, U = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, F = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, z = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", B = RegExp(`^${z}$`);
    function q(e10) {
      let t2 = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
      return e10.precision ? t2 = `${t2}\\.\\d{${e10.precision}}` : null == e10.precision && (t2 = `${t2}(\\.\\d+)?`), t2;
    }
    function H(e10) {
      let t2 = `${z}T${q(e10)}`, r2 = [];
      return r2.push(e10.local ? "Z?" : "Z"), e10.offset && r2.push("([+-]\\d{2}:?\\d{2})"), t2 = `${t2}(${r2.join("|")})`, RegExp(`^${t2}$`);
    }
    class Z extends A {
      _parse(e10) {
        var t2, r2, i2, o2;
        let l2;
        if (this._def.coerce && (e10.data = String(e10.data)), this._getType(e10) !== n.string) {
          let t3 = this._getOrReturnCtx(e10);
          return h(t3, { code: s.invalid_type, expected: n.string, received: t3.parsedType }), f;
        }
        let u2 = new p();
        for (let n2 of this._def.checks)
          if ("min" === n2.kind)
            e10.data.length < n2.value && (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.too_small, minimum: n2.value, type: "string", inclusive: true, exact: false, message: n2.message }), u2.dirty());
          else if ("max" === n2.kind)
            e10.data.length > n2.value && (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.too_big, maximum: n2.value, type: "string", inclusive: true, exact: false, message: n2.message }), u2.dirty());
          else if ("length" === n2.kind) {
            let t3 = e10.data.length > n2.value, r3 = e10.data.length < n2.value;
            (t3 || r3) && (l2 = this._getOrReturnCtx(e10, l2), t3 ? h(l2, { code: s.too_big, maximum: n2.value, type: "string", inclusive: true, exact: true, message: n2.message }) : r3 && h(l2, { code: s.too_small, minimum: n2.value, type: "string", inclusive: true, exact: true, message: n2.message }), u2.dirty());
          } else if ("email" === n2.kind)
            $.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "email", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("emoji" === n2.kind)
            a || (a = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), a.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "emoji", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("uuid" === n2.kind)
            C.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "uuid", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("nanoid" === n2.kind)
            I.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "nanoid", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("cuid" === n2.kind)
            k.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "cuid", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("cuid2" === n2.kind)
            T.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "cuid2", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("ulid" === n2.kind)
            P.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "ulid", code: s.invalid_string, message: n2.message }), u2.dirty());
          else if ("url" === n2.kind)
            try {
              new URL(e10.data);
            } catch (t3) {
              h(l2 = this._getOrReturnCtx(e10, l2), { validation: "url", code: s.invalid_string, message: n2.message }), u2.dirty();
            }
          else
            "regex" === n2.kind ? (n2.regex.lastIndex = 0, n2.regex.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "regex", code: s.invalid_string, message: n2.message }), u2.dirty())) : "trim" === n2.kind ? e10.data = e10.data.trim() : "includes" === n2.kind ? e10.data.includes(n2.value, n2.position) || (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.invalid_string, validation: { includes: n2.value, position: n2.position }, message: n2.message }), u2.dirty()) : "toLowerCase" === n2.kind ? e10.data = e10.data.toLowerCase() : "toUpperCase" === n2.kind ? e10.data = e10.data.toUpperCase() : "startsWith" === n2.kind ? e10.data.startsWith(n2.value) || (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.invalid_string, validation: { startsWith: n2.value }, message: n2.message }), u2.dirty()) : "endsWith" === n2.kind ? e10.data.endsWith(n2.value) || (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.invalid_string, validation: { endsWith: n2.value }, message: n2.message }), u2.dirty()) : "datetime" === n2.kind ? H(n2).test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.invalid_string, validation: "datetime", message: n2.message }), u2.dirty()) : "date" === n2.kind ? B.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.invalid_string, validation: "date", message: n2.message }), u2.dirty()) : "time" === n2.kind ? RegExp(`^${q(n2)}$`).test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { code: s.invalid_string, validation: "time", message: n2.message }), u2.dirty()) : "duration" === n2.kind ? N.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "duration", code: s.invalid_string, message: n2.message }), u2.dirty()) : "ip" === n2.kind ? (t2 = e10.data, ("v4" === (r2 = n2.version) || !r2) && j.test(t2) || ("v6" === r2 || !r2) && M.test(t2) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "ip", code: s.invalid_string, message: n2.message }), u2.dirty())) : "jwt" === n2.kind ? !function(e11, t3) {
              if (!R.test(e11))
                return false;
              try {
                let [r3] = e11.split("."), a2 = r3.replace(/-/g, "+").replace(/_/g, "/").padEnd(r3.length + (4 - r3.length % 4) % 4, "="), n3 = JSON.parse(atob(a2));
                if ("object" != typeof n3 || null === n3 || !n3.typ || !n3.alg || t3 && n3.alg !== t3)
                  return false;
                return true;
              } catch (e12) {
                return false;
              }
            }(e10.data, n2.alg) && (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "jwt", code: s.invalid_string, message: n2.message }), u2.dirty()) : "cidr" === n2.kind ? (i2 = e10.data, ("v4" === (o2 = n2.version) || !o2) && L.test(i2) || ("v6" === o2 || !o2) && D.test(i2) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "cidr", code: s.invalid_string, message: n2.message }), u2.dirty())) : "base64" === n2.kind ? U.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "base64", code: s.invalid_string, message: n2.message }), u2.dirty()) : "base64url" === n2.kind ? F.test(e10.data) || (h(l2 = this._getOrReturnCtx(e10, l2), { validation: "base64url", code: s.invalid_string, message: n2.message }), u2.dirty()) : tr.assertNever(n2);
        return { status: u2.value, value: e10.data };
      }
      _regex(e10, t2, r2) {
        return this.refinement((t3) => e10.test(t3), { validation: t2, code: s.invalid_string, ...tn.errToObj(r2) });
      }
      _addCheck(e10) {
        return new Z({ ...this._def, checks: [...this._def.checks, e10] });
      }
      email(e10) {
        return this._addCheck({ kind: "email", ...tn.errToObj(e10) });
      }
      url(e10) {
        return this._addCheck({ kind: "url", ...tn.errToObj(e10) });
      }
      emoji(e10) {
        return this._addCheck({ kind: "emoji", ...tn.errToObj(e10) });
      }
      uuid(e10) {
        return this._addCheck({ kind: "uuid", ...tn.errToObj(e10) });
      }
      nanoid(e10) {
        return this._addCheck({ kind: "nanoid", ...tn.errToObj(e10) });
      }
      cuid(e10) {
        return this._addCheck({ kind: "cuid", ...tn.errToObj(e10) });
      }
      cuid2(e10) {
        return this._addCheck({ kind: "cuid2", ...tn.errToObj(e10) });
      }
      ulid(e10) {
        return this._addCheck({ kind: "ulid", ...tn.errToObj(e10) });
      }
      base64(e10) {
        return this._addCheck({ kind: "base64", ...tn.errToObj(e10) });
      }
      base64url(e10) {
        return this._addCheck({ kind: "base64url", ...tn.errToObj(e10) });
      }
      jwt(e10) {
        return this._addCheck({ kind: "jwt", ...tn.errToObj(e10) });
      }
      ip(e10) {
        return this._addCheck({ kind: "ip", ...tn.errToObj(e10) });
      }
      cidr(e10) {
        return this._addCheck({ kind: "cidr", ...tn.errToObj(e10) });
      }
      datetime(e10) {
        var t2, r2;
        return "string" == typeof e10 ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: e10 }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e10 ? void 0 : e10.precision) ? null : null == e10 ? void 0 : e10.precision, offset: null !== (t2 = null == e10 ? void 0 : e10.offset) && void 0 !== t2 && t2, local: null !== (r2 = null == e10 ? void 0 : e10.local) && void 0 !== r2 && r2, ...tn.errToObj(null == e10 ? void 0 : e10.message) });
      }
      date(e10) {
        return this._addCheck({ kind: "date", message: e10 });
      }
      time(e10) {
        return "string" == typeof e10 ? this._addCheck({ kind: "time", precision: null, message: e10 }) : this._addCheck({ kind: "time", precision: void 0 === (null == e10 ? void 0 : e10.precision) ? null : null == e10 ? void 0 : e10.precision, ...tn.errToObj(null == e10 ? void 0 : e10.message) });
      }
      duration(e10) {
        return this._addCheck({ kind: "duration", ...tn.errToObj(e10) });
      }
      regex(e10, t2) {
        return this._addCheck({ kind: "regex", regex: e10, ...tn.errToObj(t2) });
      }
      includes(e10, t2) {
        return this._addCheck({ kind: "includes", value: e10, position: null == t2 ? void 0 : t2.position, ...tn.errToObj(null == t2 ? void 0 : t2.message) });
      }
      startsWith(e10, t2) {
        return this._addCheck({ kind: "startsWith", value: e10, ...tn.errToObj(t2) });
      }
      endsWith(e10, t2) {
        return this._addCheck({ kind: "endsWith", value: e10, ...tn.errToObj(t2) });
      }
      min(e10, t2) {
        return this._addCheck({ kind: "min", value: e10, ...tn.errToObj(t2) });
      }
      max(e10, t2) {
        return this._addCheck({ kind: "max", value: e10, ...tn.errToObj(t2) });
      }
      length(e10, t2) {
        return this._addCheck({ kind: "length", value: e10, ...tn.errToObj(t2) });
      }
      nonempty(e10) {
        return this.min(1, tn.errToObj(e10));
      }
      trim() {
        return new Z({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
      }
      toLowerCase() {
        return new Z({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
      }
      toUpperCase() {
        return new Z({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
      }
      get isDatetime() {
        return !!this._def.checks.find((e10) => "datetime" === e10.kind);
      }
      get isDate() {
        return !!this._def.checks.find((e10) => "date" === e10.kind);
      }
      get isTime() {
        return !!this._def.checks.find((e10) => "time" === e10.kind);
      }
      get isDuration() {
        return !!this._def.checks.find((e10) => "duration" === e10.kind);
      }
      get isEmail() {
        return !!this._def.checks.find((e10) => "email" === e10.kind);
      }
      get isURL() {
        return !!this._def.checks.find((e10) => "url" === e10.kind);
      }
      get isEmoji() {
        return !!this._def.checks.find((e10) => "emoji" === e10.kind);
      }
      get isUUID() {
        return !!this._def.checks.find((e10) => "uuid" === e10.kind);
      }
      get isNANOID() {
        return !!this._def.checks.find((e10) => "nanoid" === e10.kind);
      }
      get isCUID() {
        return !!this._def.checks.find((e10) => "cuid" === e10.kind);
      }
      get isCUID2() {
        return !!this._def.checks.find((e10) => "cuid2" === e10.kind);
      }
      get isULID() {
        return !!this._def.checks.find((e10) => "ulid" === e10.kind);
      }
      get isIP() {
        return !!this._def.checks.find((e10) => "ip" === e10.kind);
      }
      get isCIDR() {
        return !!this._def.checks.find((e10) => "cidr" === e10.kind);
      }
      get isBase64() {
        return !!this._def.checks.find((e10) => "base64" === e10.kind);
      }
      get isBase64url() {
        return !!this._def.checks.find((e10) => "base64url" === e10.kind);
      }
      get minLength() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "min" === t2.kind && (null === e10 || t2.value > e10) && (e10 = t2.value);
        return e10;
      }
      get maxLength() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "max" === t2.kind && (null === e10 || t2.value < e10) && (e10 = t2.value);
        return e10;
      }
    }
    Z.create = (e10) => {
      var t2;
      return new Z({ checks: [], typeName: to.ZodString, coerce: null !== (t2 = null == e10 ? void 0 : e10.coerce) && void 0 !== t2 && t2, ...S(e10) });
    };
    class G extends A {
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
      }
      _parse(e10) {
        let t2;
        if (this._def.coerce && (e10.data = Number(e10.data)), this._getType(e10) !== n.number) {
          let t3 = this._getOrReturnCtx(e10);
          return h(t3, { code: s.invalid_type, expected: n.number, received: t3.parsedType }), f;
        }
        let r2 = new p();
        for (let a2 of this._def.checks)
          "int" === a2.kind ? tr.isInteger(e10.data) || (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.invalid_type, expected: "integer", received: "float", message: a2.message }), r2.dirty()) : "min" === a2.kind ? (a2.inclusive ? e10.data < a2.value : e10.data <= a2.value) && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.too_small, minimum: a2.value, type: "number", inclusive: a2.inclusive, exact: false, message: a2.message }), r2.dirty()) : "max" === a2.kind ? (a2.inclusive ? e10.data > a2.value : e10.data >= a2.value) && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.too_big, maximum: a2.value, type: "number", inclusive: a2.inclusive, exact: false, message: a2.message }), r2.dirty()) : "multipleOf" === a2.kind ? 0 !== function(e11, t3) {
            let r3 = (e11.toString().split(".")[1] || "").length, a3 = (t3.toString().split(".")[1] || "").length, n2 = r3 > a3 ? r3 : a3;
            return parseInt(e11.toFixed(n2).replace(".", "")) % parseInt(t3.toFixed(n2).replace(".", "")) / Math.pow(10, n2);
          }(e10.data, a2.value) && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.not_multiple_of, multipleOf: a2.value, message: a2.message }), r2.dirty()) : "finite" === a2.kind ? Number.isFinite(e10.data) || (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.not_finite, message: a2.message }), r2.dirty()) : tr.assertNever(a2);
        return { status: r2.value, value: e10.data };
      }
      gte(e10, t2) {
        return this.setLimit("min", e10, true, tn.toString(t2));
      }
      gt(e10, t2) {
        return this.setLimit("min", e10, false, tn.toString(t2));
      }
      lte(e10, t2) {
        return this.setLimit("max", e10, true, tn.toString(t2));
      }
      lt(e10, t2) {
        return this.setLimit("max", e10, false, tn.toString(t2));
      }
      setLimit(e10, t2, r2, a2) {
        return new G({ ...this._def, checks: [...this._def.checks, { kind: e10, value: t2, inclusive: r2, message: tn.toString(a2) }] });
      }
      _addCheck(e10) {
        return new G({ ...this._def, checks: [...this._def.checks, e10] });
      }
      int(e10) {
        return this._addCheck({ kind: "int", message: tn.toString(e10) });
      }
      positive(e10) {
        return this._addCheck({ kind: "min", value: 0, inclusive: false, message: tn.toString(e10) });
      }
      negative(e10) {
        return this._addCheck({ kind: "max", value: 0, inclusive: false, message: tn.toString(e10) });
      }
      nonpositive(e10) {
        return this._addCheck({ kind: "max", value: 0, inclusive: true, message: tn.toString(e10) });
      }
      nonnegative(e10) {
        return this._addCheck({ kind: "min", value: 0, inclusive: true, message: tn.toString(e10) });
      }
      multipleOf(e10, t2) {
        return this._addCheck({ kind: "multipleOf", value: e10, message: tn.toString(t2) });
      }
      finite(e10) {
        return this._addCheck({ kind: "finite", message: tn.toString(e10) });
      }
      safe(e10) {
        return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: tn.toString(e10) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: tn.toString(e10) });
      }
      get minValue() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "min" === t2.kind && (null === e10 || t2.value > e10) && (e10 = t2.value);
        return e10;
      }
      get maxValue() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "max" === t2.kind && (null === e10 || t2.value < e10) && (e10 = t2.value);
        return e10;
      }
      get isInt() {
        return !!this._def.checks.find((e10) => "int" === e10.kind || "multipleOf" === e10.kind && tr.isInteger(e10.value));
      }
      get isFinite() {
        let e10 = null, t2 = null;
        for (let r2 of this._def.checks) {
          if ("finite" === r2.kind || "int" === r2.kind || "multipleOf" === r2.kind)
            return true;
          "min" === r2.kind ? (null === t2 || r2.value > t2) && (t2 = r2.value) : "max" === r2.kind && (null === e10 || r2.value < e10) && (e10 = r2.value);
        }
        return Number.isFinite(t2) && Number.isFinite(e10);
      }
    }
    G.create = (e10) => new G({ checks: [], typeName: to.ZodNumber, coerce: (null == e10 ? void 0 : e10.coerce) || false, ...S(e10) });
    class V extends A {
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte;
      }
      _parse(e10) {
        let t2;
        if (this._def.coerce)
          try {
            e10.data = BigInt(e10.data);
          } catch (t3) {
            return this._getInvalidInput(e10);
          }
        if (this._getType(e10) !== n.bigint)
          return this._getInvalidInput(e10);
        let r2 = new p();
        for (let a2 of this._def.checks)
          "min" === a2.kind ? (a2.inclusive ? e10.data < a2.value : e10.data <= a2.value) && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.too_small, type: "bigint", minimum: a2.value, inclusive: a2.inclusive, message: a2.message }), r2.dirty()) : "max" === a2.kind ? (a2.inclusive ? e10.data > a2.value : e10.data >= a2.value) && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.too_big, type: "bigint", maximum: a2.value, inclusive: a2.inclusive, message: a2.message }), r2.dirty()) : "multipleOf" === a2.kind ? e10.data % a2.value !== BigInt(0) && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.not_multiple_of, multipleOf: a2.value, message: a2.message }), r2.dirty()) : tr.assertNever(a2);
        return { status: r2.value, value: e10.data };
      }
      _getInvalidInput(e10) {
        let t2 = this._getOrReturnCtx(e10);
        return h(t2, { code: s.invalid_type, expected: n.bigint, received: t2.parsedType }), f;
      }
      gte(e10, t2) {
        return this.setLimit("min", e10, true, tn.toString(t2));
      }
      gt(e10, t2) {
        return this.setLimit("min", e10, false, tn.toString(t2));
      }
      lte(e10, t2) {
        return this.setLimit("max", e10, true, tn.toString(t2));
      }
      lt(e10, t2) {
        return this.setLimit("max", e10, false, tn.toString(t2));
      }
      setLimit(e10, t2, r2, a2) {
        return new V({ ...this._def, checks: [...this._def.checks, { kind: e10, value: t2, inclusive: r2, message: tn.toString(a2) }] });
      }
      _addCheck(e10) {
        return new V({ ...this._def, checks: [...this._def.checks, e10] });
      }
      positive(e10) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: tn.toString(e10) });
      }
      negative(e10) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: tn.toString(e10) });
      }
      nonpositive(e10) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: tn.toString(e10) });
      }
      nonnegative(e10) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: tn.toString(e10) });
      }
      multipleOf(e10, t2) {
        return this._addCheck({ kind: "multipleOf", value: e10, message: tn.toString(t2) });
      }
      get minValue() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "min" === t2.kind && (null === e10 || t2.value > e10) && (e10 = t2.value);
        return e10;
      }
      get maxValue() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "max" === t2.kind && (null === e10 || t2.value < e10) && (e10 = t2.value);
        return e10;
      }
    }
    V.create = (e10) => {
      var t2;
      return new V({ checks: [], typeName: to.ZodBigInt, coerce: null !== (t2 = null == e10 ? void 0 : e10.coerce) && void 0 !== t2 && t2, ...S(e10) });
    };
    class W extends A {
      _parse(e10) {
        if (this._def.coerce && (e10.data = !!e10.data), this._getType(e10) !== n.boolean) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { code: s.invalid_type, expected: n.boolean, received: t2.parsedType }), f;
        }
        return g(e10.data);
      }
    }
    W.create = (e10) => new W({ typeName: to.ZodBoolean, coerce: (null == e10 ? void 0 : e10.coerce) || false, ...S(e10) });
    class J extends A {
      _parse(e10) {
        let t2;
        if (this._def.coerce && (e10.data = new Date(e10.data)), this._getType(e10) !== n.date) {
          let t3 = this._getOrReturnCtx(e10);
          return h(t3, { code: s.invalid_type, expected: n.date, received: t3.parsedType }), f;
        }
        if (isNaN(e10.data.getTime()))
          return h(this._getOrReturnCtx(e10), { code: s.invalid_date }), f;
        let r2 = new p();
        for (let a2 of this._def.checks)
          "min" === a2.kind ? e10.data.getTime() < a2.value && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.too_small, message: a2.message, inclusive: true, exact: false, minimum: a2.value, type: "date" }), r2.dirty()) : "max" === a2.kind ? e10.data.getTime() > a2.value && (h(t2 = this._getOrReturnCtx(e10, t2), { code: s.too_big, message: a2.message, inclusive: true, exact: false, maximum: a2.value, type: "date" }), r2.dirty()) : tr.assertNever(a2);
        return { status: r2.value, value: new Date(e10.data.getTime()) };
      }
      _addCheck(e10) {
        return new J({ ...this._def, checks: [...this._def.checks, e10] });
      }
      min(e10, t2) {
        return this._addCheck({ kind: "min", value: e10.getTime(), message: tn.toString(t2) });
      }
      max(e10, t2) {
        return this._addCheck({ kind: "max", value: e10.getTime(), message: tn.toString(t2) });
      }
      get minDate() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "min" === t2.kind && (null === e10 || t2.value > e10) && (e10 = t2.value);
        return null != e10 ? new Date(e10) : null;
      }
      get maxDate() {
        let e10 = null;
        for (let t2 of this._def.checks)
          "max" === t2.kind && (null === e10 || t2.value < e10) && (e10 = t2.value);
        return null != e10 ? new Date(e10) : null;
      }
    }
    J.create = (e10) => new J({ checks: [], coerce: (null == e10 ? void 0 : e10.coerce) || false, typeName: to.ZodDate, ...S(e10) });
    class K extends A {
      _parse(e10) {
        if (this._getType(e10) !== n.symbol) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { code: s.invalid_type, expected: n.symbol, received: t2.parsedType }), f;
        }
        return g(e10.data);
      }
    }
    K.create = (e10) => new K({ typeName: to.ZodSymbol, ...S(e10) });
    class X extends A {
      _parse(e10) {
        if (this._getType(e10) !== n.undefined) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { code: s.invalid_type, expected: n.undefined, received: t2.parsedType }), f;
        }
        return g(e10.data);
      }
    }
    X.create = (e10) => new X({ typeName: to.ZodUndefined, ...S(e10) });
    class Y extends A {
      _parse(e10) {
        if (this._getType(e10) !== n.null) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { code: s.invalid_type, expected: n.null, received: t2.parsedType }), f;
        }
        return g(e10.data);
      }
    }
    Y.create = (e10) => new Y({ typeName: to.ZodNull, ...S(e10) });
    class Q extends A {
      constructor() {
        super(...arguments), this._any = true;
      }
      _parse(e10) {
        return g(e10.data);
      }
    }
    Q.create = (e10) => new Q({ typeName: to.ZodAny, ...S(e10) });
    class ee extends A {
      constructor() {
        super(...arguments), this._unknown = true;
      }
      _parse(e10) {
        return g(e10.data);
      }
    }
    ee.create = (e10) => new ee({ typeName: to.ZodUnknown, ...S(e10) });
    class et extends A {
      _parse(e10) {
        let t2 = this._getOrReturnCtx(e10);
        return h(t2, { code: s.invalid_type, expected: n.never, received: t2.parsedType }), f;
      }
    }
    et.create = (e10) => new et({ typeName: to.ZodNever, ...S(e10) });
    class er extends A {
      _parse(e10) {
        if (this._getType(e10) !== n.undefined) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { code: s.invalid_type, expected: n.void, received: t2.parsedType }), f;
        }
        return g(e10.data);
      }
    }
    er.create = (e10) => new er({ typeName: to.ZodVoid, ...S(e10) });
    class ea extends A {
      _parse(e10) {
        let { ctx: t2, status: r2 } = this._processInputParams(e10), a2 = this._def;
        if (t2.parsedType !== n.array)
          return h(t2, { code: s.invalid_type, expected: n.array, received: t2.parsedType }), f;
        if (null !== a2.exactLength) {
          let e11 = t2.data.length > a2.exactLength.value, n2 = t2.data.length < a2.exactLength.value;
          (e11 || n2) && (h(t2, { code: e11 ? s.too_big : s.too_small, minimum: n2 ? a2.exactLength.value : void 0, maximum: e11 ? a2.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: a2.exactLength.message }), r2.dirty());
        }
        if (null !== a2.minLength && t2.data.length < a2.minLength.value && (h(t2, { code: s.too_small, minimum: a2.minLength.value, type: "array", inclusive: true, exact: false, message: a2.minLength.message }), r2.dirty()), null !== a2.maxLength && t2.data.length > a2.maxLength.value && (h(t2, { code: s.too_big, maximum: a2.maxLength.value, type: "array", inclusive: true, exact: false, message: a2.maxLength.message }), r2.dirty()), t2.common.async)
          return Promise.all([...t2.data].map((e11, r3) => a2.type._parseAsync(new x(t2, e11, t2.path, r3)))).then((e11) => p.mergeArray(r2, e11));
        let i2 = [...t2.data].map((e11, r3) => a2.type._parseSync(new x(t2, e11, t2.path, r3)));
        return p.mergeArray(r2, i2);
      }
      get element() {
        return this._def.type;
      }
      min(e10, t2) {
        return new ea({ ...this._def, minLength: { value: e10, message: tn.toString(t2) } });
      }
      max(e10, t2) {
        return new ea({ ...this._def, maxLength: { value: e10, message: tn.toString(t2) } });
      }
      length(e10, t2) {
        return new ea({ ...this._def, exactLength: { value: e10, message: tn.toString(t2) } });
      }
      nonempty(e10) {
        return this.min(1, e10);
      }
    }
    ea.create = (e10, t2) => new ea({ type: e10, minLength: null, maxLength: null, exactLength: null, typeName: to.ZodArray, ...S(t2) });
    class en extends A {
      constructor() {
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
      }
      _getCached() {
        if (null !== this._cached)
          return this._cached;
        let e10 = this._def.shape(), t2 = tr.objectKeys(e10);
        return this._cached = { shape: e10, keys: t2 };
      }
      _parse(e10) {
        if (this._getType(e10) !== n.object) {
          let t3 = this._getOrReturnCtx(e10);
          return h(t3, { code: s.invalid_type, expected: n.object, received: t3.parsedType }), f;
        }
        let { status: t2, ctx: r2 } = this._processInputParams(e10), { shape: a2, keys: i2 } = this._getCached(), o2 = [];
        if (!(this._def.catchall instanceof et && "strip" === this._def.unknownKeys))
          for (let e11 in r2.data)
            i2.includes(e11) || o2.push(e11);
        let l2 = [];
        for (let e11 of i2) {
          let t3 = a2[e11], n2 = r2.data[e11];
          l2.push({ key: { status: "valid", value: e11 }, value: t3._parse(new x(r2, n2, r2.path, e11)), alwaysSet: e11 in r2.data });
        }
        if (this._def.catchall instanceof et) {
          let e11 = this._def.unknownKeys;
          if ("passthrough" === e11)
            for (let e12 of o2)
              l2.push({ key: { status: "valid", value: e12 }, value: { status: "valid", value: r2.data[e12] } });
          else if ("strict" === e11)
            o2.length > 0 && (h(r2, { code: s.unrecognized_keys, keys: o2 }), t2.dirty());
          else if ("strip" === e11)
            ;
          else
            throw Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
          let e11 = this._def.catchall;
          for (let t3 of o2) {
            let a3 = r2.data[t3];
            l2.push({ key: { status: "valid", value: t3 }, value: e11._parse(new x(r2, a3, r2.path, t3)), alwaysSet: t3 in r2.data });
          }
        }
        return r2.common.async ? Promise.resolve().then(async () => {
          let e11 = [];
          for (let t3 of l2) {
            let r3 = await t3.key, a3 = await t3.value;
            e11.push({ key: r3, value: a3, alwaysSet: t3.alwaysSet });
          }
          return e11;
        }).then((e11) => p.mergeObjectSync(t2, e11)) : p.mergeObjectSync(t2, l2);
      }
      get shape() {
        return this._def.shape();
      }
      strict(e10) {
        return tn.errToObj, new en({ ...this._def, unknownKeys: "strict", ...void 0 !== e10 ? { errorMap: (t2, r2) => {
          var a2, n2, i2, s2;
          let o2 = null !== (i2 = null === (n2 = (a2 = this._def).errorMap) || void 0 === n2 ? void 0 : n2.call(a2, t2, r2).message) && void 0 !== i2 ? i2 : r2.defaultError;
          return "unrecognized_keys" === t2.code ? { message: null !== (s2 = tn.errToObj(e10).message) && void 0 !== s2 ? s2 : o2 } : { message: o2 };
        } } : {} });
      }
      strip() {
        return new en({ ...this._def, unknownKeys: "strip" });
      }
      passthrough() {
        return new en({ ...this._def, unknownKeys: "passthrough" });
      }
      extend(e10) {
        return new en({ ...this._def, shape: () => ({ ...this._def.shape(), ...e10 }) });
      }
      merge(e10) {
        return new en({ unknownKeys: e10._def.unknownKeys, catchall: e10._def.catchall, shape: () => ({ ...this._def.shape(), ...e10._def.shape() }), typeName: to.ZodObject });
      }
      setKey(e10, t2) {
        return this.augment({ [e10]: t2 });
      }
      catchall(e10) {
        return new en({ ...this._def, catchall: e10 });
      }
      pick(e10) {
        let t2 = {};
        return tr.objectKeys(e10).forEach((r2) => {
          e10[r2] && this.shape[r2] && (t2[r2] = this.shape[r2]);
        }), new en({ ...this._def, shape: () => t2 });
      }
      omit(e10) {
        let t2 = {};
        return tr.objectKeys(this.shape).forEach((r2) => {
          e10[r2] || (t2[r2] = this.shape[r2]);
        }), new en({ ...this._def, shape: () => t2 });
      }
      deepPartial() {
        return function e10(t2) {
          if (t2 instanceof en) {
            let r2 = {};
            for (let a2 in t2.shape) {
              let n2 = t2.shape[a2];
              r2[a2] = ew.create(e10(n2));
            }
            return new en({ ...t2._def, shape: () => r2 });
          }
          return t2 instanceof ea ? new ea({ ...t2._def, type: e10(t2.element) }) : t2 instanceof ew ? ew.create(e10(t2.unwrap())) : t2 instanceof eE ? eE.create(e10(t2.unwrap())) : t2 instanceof eu ? eu.create(t2.items.map((t3) => e10(t3))) : t2;
        }(this);
      }
      partial(e10) {
        let t2 = {};
        return tr.objectKeys(this.shape).forEach((r2) => {
          let a2 = this.shape[r2];
          e10 && !e10[r2] ? t2[r2] = a2 : t2[r2] = a2.optional();
        }), new en({ ...this._def, shape: () => t2 });
      }
      required(e10) {
        let t2 = {};
        return tr.objectKeys(this.shape).forEach((r2) => {
          if (e10 && !e10[r2])
            t2[r2] = this.shape[r2];
          else {
            let e11 = this.shape[r2];
            for (; e11 instanceof ew; )
              e11 = e11._def.innerType;
            t2[r2] = e11;
          }
        }), new en({ ...this._def, shape: () => t2 });
      }
      keyof() {
        return eg(tr.objectKeys(this.shape));
      }
    }
    en.create = (e10, t2) => new en({ shape: () => e10, unknownKeys: "strip", catchall: et.create(), typeName: to.ZodObject, ...S(t2) }), en.strictCreate = (e10, t2) => new en({ shape: () => e10, unknownKeys: "strict", catchall: et.create(), typeName: to.ZodObject, ...S(t2) }), en.lazycreate = (e10, t2) => new en({ shape: e10, unknownKeys: "strip", catchall: et.create(), typeName: to.ZodObject, ...S(t2) });
    class ei extends A {
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10), r2 = this._def.options;
        if (t2.common.async)
          return Promise.all(r2.map(async (e11) => {
            let r3 = { ...t2, common: { ...t2.common, issues: [] }, parent: null };
            return { result: await e11._parseAsync({ data: t2.data, path: t2.path, parent: r3 }), ctx: r3 };
          })).then(function(e11) {
            for (let t3 of e11)
              if ("valid" === t3.result.status)
                return t3.result;
            for (let r4 of e11)
              if ("dirty" === r4.result.status)
                return t2.common.issues.push(...r4.ctx.common.issues), r4.result;
            let r3 = e11.map((e12) => new o(e12.ctx.common.issues));
            return h(t2, { code: s.invalid_union, unionErrors: r3 }), f;
          });
        {
          let e11;
          let a2 = [];
          for (let n3 of r2) {
            let r3 = { ...t2, common: { ...t2.common, issues: [] }, parent: null }, i2 = n3._parseSync({ data: t2.data, path: t2.path, parent: r3 });
            if ("valid" === i2.status)
              return i2;
            "dirty" !== i2.status || e11 || (e11 = { result: i2, ctx: r3 }), r3.common.issues.length && a2.push(r3.common.issues);
          }
          if (e11)
            return t2.common.issues.push(...e11.ctx.common.issues), e11.result;
          let n2 = a2.map((e12) => new o(e12));
          return h(t2, { code: s.invalid_union, unionErrors: n2 }), f;
        }
      }
      get options() {
        return this._def.options;
      }
    }
    ei.create = (e10, t2) => new ei({ options: e10, typeName: to.ZodUnion, ...S(t2) });
    let es = (e10) => {
      if (e10 instanceof ef)
        return es(e10.schema);
      if (e10 instanceof e_)
        return es(e10.innerType());
      if (e10 instanceof em)
        return [e10.value];
      if (e10 instanceof ey)
        return e10.options;
      if (e10 instanceof eb)
        return tr.objectValues(e10.enum);
      if (e10 instanceof ex)
        return es(e10._def.innerType);
      if (e10 instanceof X)
        return [void 0];
      else if (e10 instanceof Y)
        return [null];
      else if (e10 instanceof ew)
        return [void 0, ...es(e10.unwrap())];
      else if (e10 instanceof eE)
        return [null, ...es(e10.unwrap())];
      else if (e10 instanceof ek)
        return es(e10.unwrap());
      else if (e10 instanceof eP)
        return es(e10.unwrap());
      else if (e10 instanceof eO)
        return es(e10._def.innerType);
      else
        return [];
    };
    class eo extends A {
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10);
        if (t2.parsedType !== n.object)
          return h(t2, { code: s.invalid_type, expected: n.object, received: t2.parsedType }), f;
        let r2 = this.discriminator, a2 = t2.data[r2], i2 = this.optionsMap.get(a2);
        return i2 ? t2.common.async ? i2._parseAsync({ data: t2.data, path: t2.path, parent: t2 }) : i2._parseSync({ data: t2.data, path: t2.path, parent: t2 }) : (h(t2, { code: s.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [r2] }), f);
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(e10, t2, r2) {
        let a2 = /* @__PURE__ */ new Map();
        for (let r3 of t2) {
          let t3 = es(r3.shape[e10]);
          if (!t3.length)
            throw Error(`A discriminator value for key \`${e10}\` could not be extracted from all schema options`);
          for (let n2 of t3) {
            if (a2.has(n2))
              throw Error(`Discriminator property ${String(e10)} has duplicate value ${String(n2)}`);
            a2.set(n2, r3);
          }
        }
        return new eo({ typeName: to.ZodDiscriminatedUnion, discriminator: e10, options: t2, optionsMap: a2, ...S(r2) });
      }
    }
    class el extends A {
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10), a2 = (e11, a3) => {
          if (y(e11) || y(a3))
            return f;
          let o2 = function e12(t3, r3) {
            let a4 = i(t3), s2 = i(r3);
            if (t3 === r3)
              return { valid: true, data: t3 };
            if (a4 === n.object && s2 === n.object) {
              let a5 = tr.objectKeys(r3), n2 = tr.objectKeys(t3).filter((e13) => -1 !== a5.indexOf(e13)), i2 = { ...t3, ...r3 };
              for (let a6 of n2) {
                let n3 = e12(t3[a6], r3[a6]);
                if (!n3.valid)
                  return { valid: false };
                i2[a6] = n3.data;
              }
              return { valid: true, data: i2 };
            }
            if (a4 === n.array && s2 === n.array) {
              if (t3.length !== r3.length)
                return { valid: false };
              let a5 = [];
              for (let n2 = 0; n2 < t3.length; n2++) {
                let i2 = e12(t3[n2], r3[n2]);
                if (!i2.valid)
                  return { valid: false };
                a5.push(i2.data);
              }
              return { valid: true, data: a5 };
            }
            return a4 === n.date && s2 === n.date && +t3 == +r3 ? { valid: true, data: t3 } : { valid: false };
          }(e11.value, a3.value);
          return o2.valid ? ((b(e11) || b(a3)) && t2.dirty(), { status: t2.value, value: o2.data }) : (h(r2, { code: s.invalid_intersection_types }), f);
        };
        return r2.common.async ? Promise.all([this._def.left._parseAsync({ data: r2.data, path: r2.path, parent: r2 }), this._def.right._parseAsync({ data: r2.data, path: r2.path, parent: r2 })]).then(([e11, t3]) => a2(e11, t3)) : a2(this._def.left._parseSync({ data: r2.data, path: r2.path, parent: r2 }), this._def.right._parseSync({ data: r2.data, path: r2.path, parent: r2 }));
      }
    }
    el.create = (e10, t2, r2) => new el({ left: e10, right: t2, typeName: to.ZodIntersection, ...S(r2) });
    class eu extends A {
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10);
        if (r2.parsedType !== n.array)
          return h(r2, { code: s.invalid_type, expected: n.array, received: r2.parsedType }), f;
        if (r2.data.length < this._def.items.length)
          return h(r2, { code: s.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), f;
        !this._def.rest && r2.data.length > this._def.items.length && (h(r2, { code: s.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t2.dirty());
        let a2 = [...r2.data].map((e11, t3) => {
          let a3 = this._def.items[t3] || this._def.rest;
          return a3 ? a3._parse(new x(r2, e11, r2.path, t3)) : null;
        }).filter((e11) => !!e11);
        return r2.common.async ? Promise.all(a2).then((e11) => p.mergeArray(t2, e11)) : p.mergeArray(t2, a2);
      }
      get items() {
        return this._def.items;
      }
      rest(e10) {
        return new eu({ ...this._def, rest: e10 });
      }
    }
    eu.create = (e10, t2) => {
      if (!Array.isArray(e10))
        throw Error("You must pass an array of schemas to z.tuple([ ... ])");
      return new eu({ items: e10, typeName: to.ZodTuple, rest: null, ...S(t2) });
    };
    class ec extends A {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10);
        if (r2.parsedType !== n.object)
          return h(r2, { code: s.invalid_type, expected: n.object, received: r2.parsedType }), f;
        let a2 = [], i2 = this._def.keyType, o2 = this._def.valueType;
        for (let e11 in r2.data)
          a2.push({ key: i2._parse(new x(r2, e11, r2.path, e11)), value: o2._parse(new x(r2, r2.data[e11], r2.path, e11)), alwaysSet: e11 in r2.data });
        return r2.common.async ? p.mergeObjectAsync(t2, a2) : p.mergeObjectSync(t2, a2);
      }
      get element() {
        return this._def.valueType;
      }
      static create(e10, t2, r2) {
        return new ec(t2 instanceof A ? { keyType: e10, valueType: t2, typeName: to.ZodRecord, ...S(r2) } : { keyType: Z.create(), valueType: e10, typeName: to.ZodRecord, ...S(t2) });
      }
    }
    class ed extends A {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10);
        if (r2.parsedType !== n.map)
          return h(r2, { code: s.invalid_type, expected: n.map, received: r2.parsedType }), f;
        let a2 = this._def.keyType, i2 = this._def.valueType, o2 = [...r2.data.entries()].map(([e11, t3], n2) => ({ key: a2._parse(new x(r2, e11, r2.path, [n2, "key"])), value: i2._parse(new x(r2, t3, r2.path, [n2, "value"])) }));
        if (r2.common.async) {
          let e11 = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (let r3 of o2) {
              let a3 = await r3.key, n2 = await r3.value;
              if ("aborted" === a3.status || "aborted" === n2.status)
                return f;
              ("dirty" === a3.status || "dirty" === n2.status) && t2.dirty(), e11.set(a3.value, n2.value);
            }
            return { status: t2.value, value: e11 };
          });
        }
        {
          let e11 = /* @__PURE__ */ new Map();
          for (let r3 of o2) {
            let a3 = r3.key, n2 = r3.value;
            if ("aborted" === a3.status || "aborted" === n2.status)
              return f;
            ("dirty" === a3.status || "dirty" === n2.status) && t2.dirty(), e11.set(a3.value, n2.value);
          }
          return { status: t2.value, value: e11 };
        }
      }
    }
    ed.create = (e10, t2, r2) => new ed({ valueType: t2, keyType: e10, typeName: to.ZodMap, ...S(r2) });
    class eh extends A {
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10);
        if (r2.parsedType !== n.set)
          return h(r2, { code: s.invalid_type, expected: n.set, received: r2.parsedType }), f;
        let a2 = this._def;
        null !== a2.minSize && r2.data.size < a2.minSize.value && (h(r2, { code: s.too_small, minimum: a2.minSize.value, type: "set", inclusive: true, exact: false, message: a2.minSize.message }), t2.dirty()), null !== a2.maxSize && r2.data.size > a2.maxSize.value && (h(r2, { code: s.too_big, maximum: a2.maxSize.value, type: "set", inclusive: true, exact: false, message: a2.maxSize.message }), t2.dirty());
        let i2 = this._def.valueType;
        function o2(e11) {
          let r3 = /* @__PURE__ */ new Set();
          for (let a3 of e11) {
            if ("aborted" === a3.status)
              return f;
            "dirty" === a3.status && t2.dirty(), r3.add(a3.value);
          }
          return { status: t2.value, value: r3 };
        }
        let l2 = [...r2.data.values()].map((e11, t3) => i2._parse(new x(r2, e11, r2.path, t3)));
        return r2.common.async ? Promise.all(l2).then((e11) => o2(e11)) : o2(l2);
      }
      min(e10, t2) {
        return new eh({ ...this._def, minSize: { value: e10, message: tn.toString(t2) } });
      }
      max(e10, t2) {
        return new eh({ ...this._def, maxSize: { value: e10, message: tn.toString(t2) } });
      }
      size(e10, t2) {
        return this.min(e10, t2).max(e10, t2);
      }
      nonempty(e10) {
        return this.min(1, e10);
      }
    }
    eh.create = (e10, t2) => new eh({ valueType: e10, minSize: null, maxSize: null, typeName: to.ZodSet, ...S(t2) });
    class ep extends A {
      constructor() {
        super(...arguments), this.validate = this.implement;
      }
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10);
        if (t2.parsedType !== n.function)
          return h(t2, { code: s.invalid_type, expected: n.function, received: t2.parsedType }), f;
        function r2(e11, r3) {
          return d({ data: e11, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, c(), l].filter((e12) => !!e12), issueData: { code: s.invalid_arguments, argumentsError: r3 } });
        }
        function a2(e11, r3) {
          return d({ data: e11, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, c(), l].filter((e12) => !!e12), issueData: { code: s.invalid_return_type, returnTypeError: r3 } });
        }
        let i2 = { errorMap: t2.common.contextualErrorMap }, u2 = t2.data;
        if (this._def.returns instanceof ev) {
          let e11 = this;
          return g(async function(...t3) {
            let n2 = new o([]), s2 = await e11._def.args.parseAsync(t3, i2).catch((e12) => {
              throw n2.addIssue(r2(t3, e12)), n2;
            }), l2 = await Reflect.apply(u2, this, s2);
            return await e11._def.returns._def.type.parseAsync(l2, i2).catch((e12) => {
              throw n2.addIssue(a2(l2, e12)), n2;
            });
          });
        }
        {
          let e11 = this;
          return g(function(...t3) {
            let n2 = e11._def.args.safeParse(t3, i2);
            if (!n2.success)
              throw new o([r2(t3, n2.error)]);
            let s2 = Reflect.apply(u2, this, n2.data), l2 = e11._def.returns.safeParse(s2, i2);
            if (!l2.success)
              throw new o([a2(s2, l2.error)]);
            return l2.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...e10) {
        return new ep({ ...this._def, args: eu.create(e10).rest(ee.create()) });
      }
      returns(e10) {
        return new ep({ ...this._def, returns: e10 });
      }
      implement(e10) {
        return this.parse(e10);
      }
      strictImplement(e10) {
        return this.parse(e10);
      }
      static create(e10, t2, r2) {
        return new ep({ args: e10 || eu.create([]).rest(ee.create()), returns: t2 || ee.create(), typeName: to.ZodFunction, ...S(r2) });
      }
    }
    class ef extends A {
      get schema() {
        return this._def.getter();
      }
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10);
        return this._def.getter()._parse({ data: t2.data, path: t2.path, parent: t2 });
      }
    }
    ef.create = (e10, t2) => new ef({ getter: e10, typeName: to.ZodLazy, ...S(t2) });
    class em extends A {
      _parse(e10) {
        if (e10.data !== this._def.value) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { received: t2.data, code: s.invalid_literal, expected: this._def.value }), f;
        }
        return { status: "valid", value: e10.data };
      }
      get value() {
        return this._def.value;
      }
    }
    function eg(e10, t2) {
      return new ey({ values: e10, typeName: to.ZodEnum, ...S(t2) });
    }
    em.create = (e10, t2) => new em({ value: e10, typeName: to.ZodLiteral, ...S(t2) });
    class ey extends A {
      constructor() {
        super(...arguments), ti.set(this, void 0);
      }
      _parse(e10) {
        if ("string" != typeof e10.data) {
          let t2 = this._getOrReturnCtx(e10), r2 = this._def.values;
          return h(t2, { expected: tr.joinValues(r2), received: t2.parsedType, code: s.invalid_type }), f;
        }
        if (w(this, ti, "f") || E(this, ti, new Set(this._def.values), "f"), !w(this, ti, "f").has(e10.data)) {
          let t2 = this._getOrReturnCtx(e10), r2 = this._def.values;
          return h(t2, { received: t2.data, code: s.invalid_enum_value, options: r2 }), f;
        }
        return g(e10.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        let e10 = {};
        for (let t2 of this._def.values)
          e10[t2] = t2;
        return e10;
      }
      get Values() {
        let e10 = {};
        for (let t2 of this._def.values)
          e10[t2] = t2;
        return e10;
      }
      get Enum() {
        let e10 = {};
        for (let t2 of this._def.values)
          e10[t2] = t2;
        return e10;
      }
      extract(e10, t2 = this._def) {
        return ey.create(e10, { ...this._def, ...t2 });
      }
      exclude(e10, t2 = this._def) {
        return ey.create(this.options.filter((t3) => !e10.includes(t3)), { ...this._def, ...t2 });
      }
    }
    ti = /* @__PURE__ */ new WeakMap(), ey.create = eg;
    class eb extends A {
      constructor() {
        super(...arguments), ts.set(this, void 0);
      }
      _parse(e10) {
        let t2 = tr.getValidEnumValues(this._def.values), r2 = this._getOrReturnCtx(e10);
        if (r2.parsedType !== n.string && r2.parsedType !== n.number) {
          let e11 = tr.objectValues(t2);
          return h(r2, { expected: tr.joinValues(e11), received: r2.parsedType, code: s.invalid_type }), f;
        }
        if (w(this, ts, "f") || E(this, ts, new Set(tr.getValidEnumValues(this._def.values)), "f"), !w(this, ts, "f").has(e10.data)) {
          let e11 = tr.objectValues(t2);
          return h(r2, { received: r2.data, code: s.invalid_enum_value, options: e11 }), f;
        }
        return g(e10.data);
      }
      get enum() {
        return this._def.values;
      }
    }
    ts = /* @__PURE__ */ new WeakMap(), eb.create = (e10, t2) => new eb({ values: e10, typeName: to.ZodNativeEnum, ...S(t2) });
    class ev extends A {
      unwrap() {
        return this._def.type;
      }
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10);
        return t2.parsedType !== n.promise && false === t2.common.async ? (h(t2, { code: s.invalid_type, expected: n.promise, received: t2.parsedType }), f) : g((t2.parsedType === n.promise ? t2.data : Promise.resolve(t2.data)).then((e11) => this._def.type.parseAsync(e11, { path: t2.path, errorMap: t2.common.contextualErrorMap })));
      }
    }
    ev.create = (e10, t2) => new ev({ type: e10, typeName: to.ZodPromise, ...S(t2) });
    class e_ extends A {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === to.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10), a2 = this._def.effect || null, n2 = { addIssue: (e11) => {
          h(r2, e11), e11.fatal ? t2.abort() : t2.dirty();
        }, get path() {
          return r2.path;
        } };
        if (n2.addIssue = n2.addIssue.bind(n2), "preprocess" === a2.type) {
          let e11 = a2.transform(r2.data, n2);
          if (r2.common.async)
            return Promise.resolve(e11).then(async (e12) => {
              if ("aborted" === t2.value)
                return f;
              let a3 = await this._def.schema._parseAsync({ data: e12, path: r2.path, parent: r2 });
              return "aborted" === a3.status ? f : "dirty" === a3.status || "dirty" === t2.value ? m(a3.value) : a3;
            });
          {
            if ("aborted" === t2.value)
              return f;
            let a3 = this._def.schema._parseSync({ data: e11, path: r2.path, parent: r2 });
            return "aborted" === a3.status ? f : "dirty" === a3.status || "dirty" === t2.value ? m(a3.value) : a3;
          }
        }
        if ("refinement" === a2.type) {
          let e11 = (e12) => {
            let t3 = a2.refinement(e12, n2);
            if (r2.common.async)
              return Promise.resolve(t3);
            if (t3 instanceof Promise)
              throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            return e12;
          };
          if (false !== r2.common.async)
            return this._def.schema._parseAsync({ data: r2.data, path: r2.path, parent: r2 }).then((r3) => "aborted" === r3.status ? f : ("dirty" === r3.status && t2.dirty(), e11(r3.value).then(() => ({ status: t2.value, value: r3.value }))));
          {
            let a3 = this._def.schema._parseSync({ data: r2.data, path: r2.path, parent: r2 });
            return "aborted" === a3.status ? f : ("dirty" === a3.status && t2.dirty(), e11(a3.value), { status: t2.value, value: a3.value });
          }
        }
        if ("transform" === a2.type) {
          if (false !== r2.common.async)
            return this._def.schema._parseAsync({ data: r2.data, path: r2.path, parent: r2 }).then((e11) => v(e11) ? Promise.resolve(a2.transform(e11.value, n2)).then((e12) => ({ status: t2.value, value: e12 })) : e11);
          {
            let e11 = this._def.schema._parseSync({ data: r2.data, path: r2.path, parent: r2 });
            if (!v(e11))
              return e11;
            let i2 = a2.transform(e11.value, n2);
            if (i2 instanceof Promise)
              throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return { status: t2.value, value: i2 };
          }
        }
        tr.assertNever(a2);
      }
    }
    e_.create = (e10, t2, r2) => new e_({ schema: e10, typeName: to.ZodEffects, effect: t2, ...S(r2) }), e_.createWithPreprocess = (e10, t2, r2) => new e_({ schema: t2, effect: { type: "preprocess", transform: e10 }, typeName: to.ZodEffects, ...S(r2) });
    class ew extends A {
      _parse(e10) {
        return this._getType(e10) === n.undefined ? g(void 0) : this._def.innerType._parse(e10);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    ew.create = (e10, t2) => new ew({ innerType: e10, typeName: to.ZodOptional, ...S(t2) });
    class eE extends A {
      _parse(e10) {
        return this._getType(e10) === n.null ? g(null) : this._def.innerType._parse(e10);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    eE.create = (e10, t2) => new eE({ innerType: e10, typeName: to.ZodNullable, ...S(t2) });
    class ex extends A {
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10), r2 = t2.data;
        return t2.parsedType === n.undefined && (r2 = this._def.defaultValue()), this._def.innerType._parse({ data: r2, path: t2.path, parent: t2 });
      }
      removeDefault() {
        return this._def.innerType;
      }
    }
    ex.create = (e10, t2) => new ex({ innerType: e10, typeName: to.ZodDefault, defaultValue: "function" == typeof t2.default ? t2.default : () => t2.default, ...S(t2) });
    class eO extends A {
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10), r2 = { ...t2, common: { ...t2.common, issues: [] } }, a2 = this._def.innerType._parse({ data: r2.data, path: r2.path, parent: { ...r2 } });
        return _(a2) ? a2.then((e11) => ({ status: "valid", value: "valid" === e11.status ? e11.value : this._def.catchValue({ get error() {
          return new o(r2.common.issues);
        }, input: r2.data }) })) : { status: "valid", value: "valid" === a2.status ? a2.value : this._def.catchValue({ get error() {
          return new o(r2.common.issues);
        }, input: r2.data }) };
      }
      removeCatch() {
        return this._def.innerType;
      }
    }
    eO.create = (e10, t2) => new eO({ innerType: e10, typeName: to.ZodCatch, catchValue: "function" == typeof t2.catch ? t2.catch : () => t2.catch, ...S(t2) });
    class eS extends A {
      _parse(e10) {
        if (this._getType(e10) !== n.nan) {
          let t2 = this._getOrReturnCtx(e10);
          return h(t2, { code: s.invalid_type, expected: n.nan, received: t2.parsedType }), f;
        }
        return { status: "valid", value: e10.data };
      }
    }
    eS.create = (e10) => new eS({ typeName: to.ZodNaN, ...S(e10) });
    let eA = Symbol("zod_brand");
    class ek extends A {
      _parse(e10) {
        let { ctx: t2 } = this._processInputParams(e10), r2 = t2.data;
        return this._def.type._parse({ data: r2, path: t2.path, parent: t2 });
      }
      unwrap() {
        return this._def.type;
      }
    }
    class eT extends A {
      _parse(e10) {
        let { status: t2, ctx: r2 } = this._processInputParams(e10);
        if (r2.common.async)
          return (async () => {
            let e11 = await this._def.in._parseAsync({ data: r2.data, path: r2.path, parent: r2 });
            return "aborted" === e11.status ? f : "dirty" === e11.status ? (t2.dirty(), m(e11.value)) : this._def.out._parseAsync({ data: e11.value, path: r2.path, parent: r2 });
          })();
        {
          let e11 = this._def.in._parseSync({ data: r2.data, path: r2.path, parent: r2 });
          return "aborted" === e11.status ? f : "dirty" === e11.status ? (t2.dirty(), { status: "dirty", value: e11.value }) : this._def.out._parseSync({ data: e11.value, path: r2.path, parent: r2 });
        }
      }
      static create(e10, t2) {
        return new eT({ in: e10, out: t2, typeName: to.ZodPipeline });
      }
    }
    class eP extends A {
      _parse(e10) {
        let t2 = this._def.innerType._parse(e10), r2 = (e11) => (v(e11) && (e11.value = Object.freeze(e11.value)), e11);
        return _(t2) ? t2.then((e11) => r2(e11)) : r2(t2);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    function eC(e10, t2 = {}, r2) {
      return e10 ? Q.create().superRefine((a2, n2) => {
        var i2, s2;
        if (!e10(a2)) {
          let e11 = "function" == typeof t2 ? t2(a2) : "string" == typeof t2 ? { message: t2 } : t2, o2 = null === (s2 = null !== (i2 = e11.fatal) && void 0 !== i2 ? i2 : r2) || void 0 === s2 || s2;
          n2.addIssue({ code: "custom", ..."string" == typeof e11 ? { message: e11 } : e11, fatal: o2 });
        }
      }) : Q.create();
    }
    eP.create = (e10, t2) => new eP({ innerType: e10, typeName: to.ZodReadonly, ...S(t2) });
    let eI = { object: en.lazycreate };
    !function(e10) {
      e10.ZodString = "ZodString", e10.ZodNumber = "ZodNumber", e10.ZodNaN = "ZodNaN", e10.ZodBigInt = "ZodBigInt", e10.ZodBoolean = "ZodBoolean", e10.ZodDate = "ZodDate", e10.ZodSymbol = "ZodSymbol", e10.ZodUndefined = "ZodUndefined", e10.ZodNull = "ZodNull", e10.ZodAny = "ZodAny", e10.ZodUnknown = "ZodUnknown", e10.ZodNever = "ZodNever", e10.ZodVoid = "ZodVoid", e10.ZodArray = "ZodArray", e10.ZodObject = "ZodObject", e10.ZodUnion = "ZodUnion", e10.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e10.ZodIntersection = "ZodIntersection", e10.ZodTuple = "ZodTuple", e10.ZodRecord = "ZodRecord", e10.ZodMap = "ZodMap", e10.ZodSet = "ZodSet", e10.ZodFunction = "ZodFunction", e10.ZodLazy = "ZodLazy", e10.ZodLiteral = "ZodLiteral", e10.ZodEnum = "ZodEnum", e10.ZodEffects = "ZodEffects", e10.ZodNativeEnum = "ZodNativeEnum", e10.ZodOptional = "ZodOptional", e10.ZodNullable = "ZodNullable", e10.ZodDefault = "ZodDefault", e10.ZodCatch = "ZodCatch", e10.ZodPromise = "ZodPromise", e10.ZodBranded = "ZodBranded", e10.ZodPipeline = "ZodPipeline", e10.ZodReadonly = "ZodReadonly";
    }(to || (to = {}));
    let eR = Z.create, eN = G.create, e$ = eS.create, ej = V.create, eL = W.create, eM = J.create, eD = K.create, eU = X.create, eF = Y.create, ez = Q.create, eB = ee.create, eq = et.create, eH = er.create, eZ = ea.create, eG = en.create, eV = en.strictCreate, eW = ei.create, eJ = eo.create, eK = el.create, eX = eu.create, eY = ec.create, eQ = ed.create, e0 = eh.create, e1 = ep.create, e2 = ef.create, e4 = em.create, e9 = ey.create, e3 = eb.create, e5 = ev.create, e6 = e_.create, e8 = ew.create, e7 = eE.create, te = e_.createWithPreprocess, tt = eT.create;
    var tr, ta, tn, ti, ts, to, tl = Object.freeze({ __proto__: null, defaultErrorMap: l, setErrorMap: function(e10) {
      u = e10;
    }, getErrorMap: c, makeIssue: d, EMPTY_PATH: [], addIssueToContext: h, ParseStatus: p, INVALID: f, DIRTY: m, OK: g, isAborted: y, isDirty: b, isValid: v, isAsync: _, get util() {
      return tr;
    }, get objectUtil() {
      return ta;
    }, ZodParsedType: n, getParsedType: i, ZodType: A, datetimeRegex: H, ZodString: Z, ZodNumber: G, ZodBigInt: V, ZodBoolean: W, ZodDate: J, ZodSymbol: K, ZodUndefined: X, ZodNull: Y, ZodAny: Q, ZodUnknown: ee, ZodNever: et, ZodVoid: er, ZodArray: ea, ZodObject: en, ZodUnion: ei, ZodDiscriminatedUnion: eo, ZodIntersection: el, ZodTuple: eu, ZodRecord: ec, ZodMap: ed, ZodSet: eh, ZodFunction: ep, ZodLazy: ef, ZodLiteral: em, ZodEnum: ey, ZodNativeEnum: eb, ZodPromise: ev, ZodEffects: e_, ZodTransformer: e_, ZodOptional: ew, ZodNullable: eE, ZodDefault: ex, ZodCatch: eO, ZodNaN: eS, BRAND: eA, ZodBranded: ek, ZodPipeline: eT, ZodReadonly: eP, custom: eC, Schema: A, ZodSchema: A, late: eI, get ZodFirstPartyTypeKind() {
      return to;
    }, coerce: { string: (e10) => Z.create({ ...e10, coerce: true }), number: (e10) => G.create({ ...e10, coerce: true }), boolean: (e10) => W.create({ ...e10, coerce: true }), bigint: (e10) => V.create({ ...e10, coerce: true }), date: (e10) => J.create({ ...e10, coerce: true }) }, any: ez, array: eZ, bigint: ej, boolean: eL, date: eM, discriminatedUnion: eJ, effect: e6, enum: e9, function: e1, instanceof: (e10, t2 = { message: `Input not instance of ${e10.name}` }) => eC((t3) => t3 instanceof e10, t2), intersection: eK, lazy: e2, literal: e4, map: eQ, nan: e$, nativeEnum: e3, never: eq, null: eF, nullable: e7, number: eN, object: eG, oboolean: () => eL().optional(), onumber: () => eN().optional(), optional: e8, ostring: () => eR().optional(), pipeline: tt, preprocess: te, promise: e5, record: eY, set: e0, strictObject: eV, string: eR, symbol: eD, transformer: e6, tuple: eX, undefined: eU, union: eW, unknown: eB, void: eH, NEVER: f, ZodIssueCode: s, quotelessJson: (e10) => JSON.stringify(e10, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError: o });
  };
  __namedExportsObject["__chunk_7026"] = (e, t, r) => {
    "use strict";
    let a;
    r.d(t, { Y_: () => R });
    let n = Symbol("Let zodToJsonSchema decide on which parser to use"), i = { name: void 0, $refStrategy: "root", basePath: ["#"], effectStrategy: "input", pipeStrategy: "all", dateStrategy: "format:date-time", mapStrategy: "entries", removeAdditionalStrategy: "passthrough", definitionPath: "definitions", target: "jsonSchema7", strictUnions: false, definitions: {}, errorMessages: false, markdownDescription: false, patternStrategy: "escape", applyRegexFlags: false, emailStrategy: "format:email", base64Strategy: "contentEncoding:base64", nameStrategy: "ref" }, s = (e2) => "string" == typeof e2 ? { ...i, name: e2 } : { ...i, ...e2 }, o = (e2) => {
      let t2 = s(e2), r2 = void 0 !== t2.name ? [...t2.basePath, t2.definitionPath, t2.name] : t2.basePath;
      return { ...t2, currentPath: r2, propertyPath: void 0, seen: new Map(Object.entries(t2.definitions).map(([e3, r3]) => [r3._def, { def: r3._def, path: [...t2.basePath, t2.definitionPath, e3], jsonSchema: void 0 }])) };
    };
    var l = r(5817);
    function u(e2, t2, r2, a2) {
      a2?.errorMessages && r2 && (e2.errorMessage = { ...e2.errorMessage, [t2]: r2 });
    }
    function c(e2, t2, r2, a2, n2) {
      e2[t2] = r2, u(e2, t2, a2, n2);
    }
    function d(e2, t2) {
      return k(e2.type._def, t2);
    }
    let h = (e2, t2) => k(e2.innerType._def, t2), p = (e2, t2) => {
      let r2 = { type: "integer", format: "unix-time" };
      if ("openApi3" === t2.target)
        return r2;
      for (let a2 of e2.checks)
        switch (a2.kind) {
          case "min":
            c(r2, "minimum", a2.value, a2.message, t2);
            break;
          case "max":
            c(r2, "maximum", a2.value, a2.message, t2);
        }
      return r2;
    }, f = (e2) => (!("type" in e2) || "string" !== e2.type) && "allOf" in e2, m = { cuid: /^[cC][^\s-]{8,}$/, cuid2: /^[0-9a-z]+$/, ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/, email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/, emoji: () => (void 0 === a && (a = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), a), base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, nanoid: /^[a-zA-Z0-9_-]{21}$/ };
    function g(e2, t2) {
      let r2 = { type: "string" };
      function a2(e3) {
        return "escape" === t2.patternStrategy ? y(e3) : e3;
      }
      if (e2.checks)
        for (let n2 of e2.checks)
          switch (n2.kind) {
            case "min":
              c(r2, "minLength", "number" == typeof r2.minLength ? Math.max(r2.minLength, n2.value) : n2.value, n2.message, t2);
              break;
            case "max":
              c(r2, "maxLength", "number" == typeof r2.maxLength ? Math.min(r2.maxLength, n2.value) : n2.value, n2.message, t2);
              break;
            case "email":
              switch (t2.emailStrategy) {
                case "format:email":
                  b(r2, "email", n2.message, t2);
                  break;
                case "format:idn-email":
                  b(r2, "idn-email", n2.message, t2);
                  break;
                case "pattern:zod":
                  v(r2, m.email, n2.message, t2);
              }
              break;
            case "url":
              b(r2, "uri", n2.message, t2);
              break;
            case "uuid":
              b(r2, "uuid", n2.message, t2);
              break;
            case "regex":
              v(r2, n2.regex, n2.message, t2);
              break;
            case "cuid":
              v(r2, m.cuid, n2.message, t2);
              break;
            case "cuid2":
              v(r2, m.cuid2, n2.message, t2);
              break;
            case "startsWith":
              v(r2, RegExp(`^${a2(n2.value)}`), n2.message, t2);
              break;
            case "endsWith":
              v(r2, RegExp(`${a2(n2.value)}$`), n2.message, t2);
              break;
            case "datetime":
              b(r2, "date-time", n2.message, t2);
              break;
            case "date":
              b(r2, "date", n2.message, t2);
              break;
            case "time":
              b(r2, "time", n2.message, t2);
              break;
            case "duration":
              b(r2, "duration", n2.message, t2);
              break;
            case "length":
              c(r2, "minLength", "number" == typeof r2.minLength ? Math.max(r2.minLength, n2.value) : n2.value, n2.message, t2), c(r2, "maxLength", "number" == typeof r2.maxLength ? Math.min(r2.maxLength, n2.value) : n2.value, n2.message, t2);
              break;
            case "includes":
              v(r2, RegExp(a2(n2.value)), n2.message, t2);
              break;
            case "ip":
              "v6" !== n2.version && b(r2, "ipv4", n2.message, t2), "v4" !== n2.version && b(r2, "ipv6", n2.message, t2);
              break;
            case "emoji":
              v(r2, m.emoji, n2.message, t2);
              break;
            case "ulid":
              v(r2, m.ulid, n2.message, t2);
              break;
            case "base64":
              switch (t2.base64Strategy) {
                case "format:binary":
                  b(r2, "binary", n2.message, t2);
                  break;
                case "contentEncoding:base64":
                  c(r2, "contentEncoding", "base64", n2.message, t2);
                  break;
                case "pattern:zod":
                  v(r2, m.base64, n2.message, t2);
              }
              break;
            case "nanoid":
              v(r2, m.nanoid, n2.message, t2);
          }
      return r2;
    }
    let y = (e2) => Array.from(e2).map((e3) => /[a-zA-Z0-9]/.test(e3) ? e3 : `\\${e3}`).join(""), b = (e2, t2, r2, a2) => {
      e2.format || e2.anyOf?.some((e3) => e3.format) ? (e2.anyOf || (e2.anyOf = []), e2.format && (e2.anyOf.push({ format: e2.format, ...e2.errorMessage && a2.errorMessages && { errorMessage: { format: e2.errorMessage.format } } }), delete e2.format, e2.errorMessage && (delete e2.errorMessage.format, 0 === Object.keys(e2.errorMessage).length && delete e2.errorMessage)), e2.anyOf.push({ format: t2, ...r2 && a2.errorMessages && { errorMessage: { format: r2 } } })) : c(e2, "format", t2, r2, a2);
    }, v = (e2, t2, r2, a2) => {
      e2.pattern || e2.allOf?.some((e3) => e3.pattern) ? (e2.allOf || (e2.allOf = []), e2.pattern && (e2.allOf.push({ pattern: e2.pattern, ...e2.errorMessage && a2.errorMessages && { errorMessage: { pattern: e2.errorMessage.pattern } } }), delete e2.pattern, e2.errorMessage && (delete e2.errorMessage.pattern, 0 === Object.keys(e2.errorMessage).length && delete e2.errorMessage)), e2.allOf.push({ pattern: _(t2, a2), ...r2 && a2.errorMessages && { errorMessage: { pattern: r2 } } })) : c(e2, "pattern", _(t2, a2), r2, a2);
    }, _ = (e2, t2) => {
      let r2 = "function" == typeof e2 ? e2() : e2;
      if (!t2.applyRegexFlags || !r2.flags)
        return r2.source;
      let a2 = { i: r2.flags.includes("i"), m: r2.flags.includes("m"), s: r2.flags.includes("s") }, n2 = a2.i ? r2.source.toLowerCase() : r2.source, i2 = "", s2 = false, o2 = false, l2 = false;
      for (let e3 = 0; e3 < n2.length; e3++) {
        if (s2) {
          i2 += n2[e3], s2 = false;
          continue;
        }
        if (a2.i) {
          if (o2) {
            if (n2[e3].match(/[a-z]/)) {
              l2 ? (i2 += n2[e3] + `${n2[e3 - 2]}-${n2[e3]}`.toUpperCase(), l2 = false) : "-" === n2[e3 + 1] && n2[e3 + 2]?.match(/[a-z]/) ? (i2 += n2[e3], l2 = true) : i2 += `${n2[e3]}${n2[e3].toUpperCase()}`;
              continue;
            }
          } else if (n2[e3].match(/[a-z]/)) {
            i2 += `[${n2[e3]}${n2[e3].toUpperCase()}]`;
            continue;
          }
        }
        if (a2.m) {
          if ("^" === n2[e3]) {
            i2 += `(^|(?<=[\r
]))`;
            continue;
          }
          if ("$" === n2[e3]) {
            i2 += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (a2.s && "." === n2[e3]) {
          i2 += o2 ? `${n2[e3]}\r
` : `[${n2[e3]}\r
]`;
          continue;
        }
        i2 += n2[e3], "\\" === n2[e3] ? s2 = true : o2 && "]" === n2[e3] ? o2 = false : o2 || "[" !== n2[e3] || (o2 = true);
      }
      try {
        new RegExp(i2);
      } catch {
        return console.warn(`Could not convert regex pattern at ${t2.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), r2.source;
      }
      return i2;
    };
    function w(e2, t2) {
      if ("openApi3" === t2.target && e2.keyType?._def.typeName === l.pA.ZodEnum)
        return { type: "object", required: e2.keyType._def.values, properties: e2.keyType._def.values.reduce((r3, a2) => ({ ...r3, [a2]: k(e2.valueType._def, { ...t2, currentPath: [...t2.currentPath, "properties", a2] }) ?? {} }), {}), additionalProperties: false };
      let r2 = { type: "object", additionalProperties: k(e2.valueType._def, { ...t2, currentPath: [...t2.currentPath, "additionalProperties"] }) ?? {} };
      if ("openApi3" === t2.target)
        return r2;
      if (e2.keyType?._def.typeName === l.pA.ZodString && e2.keyType._def.checks?.length) {
        let { type: a2, ...n2 } = g(e2.keyType._def, t2);
        return { ...r2, propertyNames: n2 };
      }
      if (e2.keyType?._def.typeName === l.pA.ZodEnum)
        return { ...r2, propertyNames: { enum: e2.keyType._def.values } };
      if (e2.keyType?._def.typeName === l.pA.ZodBranded && e2.keyType._def.type._def.typeName === l.pA.ZodString && e2.keyType._def.type._def.checks?.length) {
        let { type: a2, ...n2 } = d(e2.keyType._def, t2);
        return { ...r2, propertyNames: n2 };
      }
      return r2;
    }
    let E = { ZodString: "string", ZodNumber: "number", ZodBigInt: "integer", ZodBoolean: "boolean", ZodNull: "null" }, x = (e2, t2) => {
      let r2 = (e2.options instanceof Map ? Array.from(e2.options.values()) : e2.options).map((e3, r3) => k(e3._def, { ...t2, currentPath: [...t2.currentPath, "anyOf", `${r3}`] })).filter((e3) => !!e3 && (!t2.strictUnions || "object" == typeof e3 && Object.keys(e3).length > 0));
      return r2.length ? { anyOf: r2 } : void 0;
    }, O = (e2, t2) => {
      if (t2.currentPath.toString() === t2.propertyPath?.toString())
        return k(e2.innerType._def, t2);
      let r2 = k(e2.innerType._def, { ...t2, currentPath: [...t2.currentPath, "anyOf", "1"] });
      return r2 ? { anyOf: [{ not: {} }, r2] } : {};
    }, S = (e2, t2) => {
      if ("input" === t2.pipeStrategy)
        return k(e2.in._def, t2);
      if ("output" === t2.pipeStrategy)
        return k(e2.out._def, t2);
      let r2 = k(e2.in._def, { ...t2, currentPath: [...t2.currentPath, "allOf", "0"] }), a2 = k(e2.out._def, { ...t2, currentPath: [...t2.currentPath, "allOf", r2 ? "1" : "0"] });
      return { allOf: [r2, a2].filter((e3) => void 0 !== e3) };
    }, A = (e2, t2) => k(e2.innerType._def, t2);
    function k(e2, t2, r2 = false) {
      let a2 = t2.seen.get(e2);
      if (t2.override) {
        let i3 = t2.override?.(e2, t2, a2, r2);
        if (i3 !== n)
          return i3;
      }
      if (a2 && !r2) {
        let e3 = T(a2, t2);
        if (void 0 !== e3)
          return e3;
      }
      let i2 = { def: e2, path: t2.currentPath, jsonSchema: void 0 };
      t2.seen.set(e2, i2);
      let s2 = C(e2, e2.typeName, t2);
      return s2 && I(e2, t2, s2), i2.jsonSchema = s2, s2;
    }
    let T = (e2, t2) => {
      switch (t2.$refStrategy) {
        case "root":
          return { $ref: e2.path.join("/") };
        case "relative":
          return { $ref: P(t2.currentPath, e2.path) };
        case "none":
        case "seen":
          if (e2.path.length < t2.currentPath.length && e2.path.every((e3, r2) => t2.currentPath[r2] === e3))
            return console.warn(`Recursive reference detected at ${t2.currentPath.join("/")}! Defaulting to any`), {};
          return "seen" === t2.$refStrategy ? {} : void 0;
      }
    }, P = (e2, t2) => {
      let r2 = 0;
      for (; r2 < e2.length && r2 < t2.length && e2[r2] === t2[r2]; r2++)
        ;
      return [(e2.length - r2).toString(), ...t2.slice(r2)].join("/");
    }, C = (e2, t2, r2) => {
      switch (t2) {
        case l.pA.ZodString:
          return g(e2, r2);
        case l.pA.ZodNumber:
          return function(e3, t3) {
            let r3 = { type: "number" };
            if (!e3.checks)
              return r3;
            for (let a2 of e3.checks)
              switch (a2.kind) {
                case "int":
                  r3.type = "integer", u(r3, "type", a2.message, t3);
                  break;
                case "min":
                  "jsonSchema7" === t3.target ? a2.inclusive ? c(r3, "minimum", a2.value, a2.message, t3) : c(r3, "exclusiveMinimum", a2.value, a2.message, t3) : (a2.inclusive || (r3.exclusiveMinimum = true), c(r3, "minimum", a2.value, a2.message, t3));
                  break;
                case "max":
                  "jsonSchema7" === t3.target ? a2.inclusive ? c(r3, "maximum", a2.value, a2.message, t3) : c(r3, "exclusiveMaximum", a2.value, a2.message, t3) : (a2.inclusive || (r3.exclusiveMaximum = true), c(r3, "maximum", a2.value, a2.message, t3));
                  break;
                case "multipleOf":
                  c(r3, "multipleOf", a2.value, a2.message, t3);
              }
            return r3;
          }(e2, r2);
        case l.pA.ZodObject:
          return function(e3, t3) {
            let r3 = { type: "object", ...Object.entries(e3.shape()).reduce((e4, [r4, a2]) => {
              if (void 0 === a2 || void 0 === a2._def)
                return e4;
              let n2 = k(a2._def, { ...t3, currentPath: [...t3.currentPath, "properties", r4], propertyPath: [...t3.currentPath, "properties", r4] });
              return void 0 === n2 ? e4 : { properties: { ...e4.properties, [r4]: n2 }, required: a2.isOptional() ? e4.required : [...e4.required, r4] };
            }, { properties: {}, required: [] }), additionalProperties: "strict" === t3.removeAdditionalStrategy ? "ZodNever" === e3.catchall._def.typeName ? "strict" !== e3.unknownKeys : k(e3.catchall._def, { ...t3, currentPath: [...t3.currentPath, "additionalProperties"] }) ?? true : "ZodNever" === e3.catchall._def.typeName ? "passthrough" === e3.unknownKeys : k(e3.catchall._def, { ...t3, currentPath: [...t3.currentPath, "additionalProperties"] }) ?? true };
            return r3.required.length || delete r3.required, r3;
          }(e2, r2);
        case l.pA.ZodBigInt:
          return function(e3, t3) {
            let r3 = { type: "integer", format: "int64" };
            if (!e3.checks)
              return r3;
            for (let a2 of e3.checks)
              switch (a2.kind) {
                case "min":
                  "jsonSchema7" === t3.target ? a2.inclusive ? c(r3, "minimum", a2.value, a2.message, t3) : c(r3, "exclusiveMinimum", a2.value, a2.message, t3) : (a2.inclusive || (r3.exclusiveMinimum = true), c(r3, "minimum", a2.value, a2.message, t3));
                  break;
                case "max":
                  "jsonSchema7" === t3.target ? a2.inclusive ? c(r3, "maximum", a2.value, a2.message, t3) : c(r3, "exclusiveMaximum", a2.value, a2.message, t3) : (a2.inclusive || (r3.exclusiveMaximum = true), c(r3, "maximum", a2.value, a2.message, t3));
                  break;
                case "multipleOf":
                  c(r3, "multipleOf", a2.value, a2.message, t3);
              }
            return r3;
          }(e2, r2);
        case l.pA.ZodBoolean:
          return { type: "boolean" };
        case l.pA.ZodDate:
          return function e3(t3, r3, a2) {
            let n2 = a2 ?? r3.dateStrategy;
            if (Array.isArray(n2))
              return { anyOf: n2.map((a3, n3) => e3(t3, r3, a3)) };
            switch (n2) {
              case "string":
              case "format:date-time":
                return { type: "string", format: "date-time" };
              case "format:date":
                return { type: "string", format: "date" };
              case "integer":
                return p(t3, r3);
            }
          }(e2, r2);
        case l.pA.ZodUndefined:
          return { not: {} };
        case l.pA.ZodNull:
          return "openApi3" === r2.target ? { enum: ["null"], nullable: true } : { type: "null" };
        case l.pA.ZodArray:
          return function(e3, t3) {
            let r3 = { type: "array" };
            return e3.type?._def && e3.type?._def?.typeName !== l.pA.ZodAny && (r3.items = k(e3.type._def, { ...t3, currentPath: [...t3.currentPath, "items"] })), e3.minLength && c(r3, "minItems", e3.minLength.value, e3.minLength.message, t3), e3.maxLength && c(r3, "maxItems", e3.maxLength.value, e3.maxLength.message, t3), e3.exactLength && (c(r3, "minItems", e3.exactLength.value, e3.exactLength.message, t3), c(r3, "maxItems", e3.exactLength.value, e3.exactLength.message, t3)), r3;
          }(e2, r2);
        case l.pA.ZodUnion:
        case l.pA.ZodDiscriminatedUnion:
          return function(e3, t3) {
            if ("openApi3" === t3.target)
              return x(e3, t3);
            let r3 = e3.options instanceof Map ? Array.from(e3.options.values()) : e3.options;
            if (r3.every((e4) => e4._def.typeName in E && (!e4._def.checks || !e4._def.checks.length))) {
              let e4 = r3.reduce((e5, t4) => {
                let r4 = E[t4._def.typeName];
                return r4 && !e5.includes(r4) ? [...e5, r4] : e5;
              }, []);
              return { type: e4.length > 1 ? e4 : e4[0] };
            }
            if (r3.every((e4) => "ZodLiteral" === e4._def.typeName && !e4.description)) {
              let e4 = r3.reduce((e5, t4) => {
                let r4 = typeof t4._def.value;
                switch (r4) {
                  case "string":
                  case "number":
                  case "boolean":
                    return [...e5, r4];
                  case "bigint":
                    return [...e5, "integer"];
                  case "object":
                    if (null === t4._def.value)
                      return [...e5, "null"];
                  default:
                    return e5;
                }
              }, []);
              if (e4.length === r3.length) {
                let t4 = e4.filter((e5, t5, r4) => r4.indexOf(e5) === t5);
                return { type: t4.length > 1 ? t4 : t4[0], enum: r3.reduce((e5, t5) => e5.includes(t5._def.value) ? e5 : [...e5, t5._def.value], []) };
              }
            } else if (r3.every((e4) => "ZodEnum" === e4._def.typeName))
              return { type: "string", enum: r3.reduce((e4, t4) => [...e4, ...t4._def.values.filter((t5) => !e4.includes(t5))], []) };
            return x(e3, t3);
          }(e2, r2);
        case l.pA.ZodIntersection:
          return function(e3, t3) {
            let r3 = [k(e3.left._def, { ...t3, currentPath: [...t3.currentPath, "allOf", "0"] }), k(e3.right._def, { ...t3, currentPath: [...t3.currentPath, "allOf", "1"] })].filter((e4) => !!e4), a2 = "jsonSchema2019-09" === t3.target ? { unevaluatedProperties: false } : void 0, n2 = [];
            return r3.forEach((e4) => {
              if (f(e4))
                n2.push(...e4.allOf), void 0 === e4.unevaluatedProperties && (a2 = void 0);
              else {
                let t4 = e4;
                if ("additionalProperties" in e4 && false === e4.additionalProperties) {
                  let { additionalProperties: r4, ...a3 } = e4;
                  t4 = a3;
                } else
                  a2 = void 0;
                n2.push(t4);
              }
            }), n2.length ? { allOf: n2, ...a2 } : void 0;
          }(e2, r2);
        case l.pA.ZodTuple:
          return function(e3, t3) {
            return e3.rest ? { type: "array", minItems: e3.items.length, items: e3.items.map((e4, r3) => k(e4._def, { ...t3, currentPath: [...t3.currentPath, "items", `${r3}`] })).reduce((e4, t4) => void 0 === t4 ? e4 : [...e4, t4], []), additionalItems: k(e3.rest._def, { ...t3, currentPath: [...t3.currentPath, "additionalItems"] }) } : { type: "array", minItems: e3.items.length, maxItems: e3.items.length, items: e3.items.map((e4, r3) => k(e4._def, { ...t3, currentPath: [...t3.currentPath, "items", `${r3}`] })).reduce((e4, t4) => void 0 === t4 ? e4 : [...e4, t4], []) };
          }(e2, r2);
        case l.pA.ZodRecord:
          return w(e2, r2);
        case l.pA.ZodLiteral:
          return function(e3, t3) {
            let r3 = typeof e3.value;
            return "bigint" !== r3 && "number" !== r3 && "boolean" !== r3 && "string" !== r3 ? { type: Array.isArray(e3.value) ? "array" : "object" } : "openApi3" === t3.target ? { type: "bigint" === r3 ? "integer" : r3, enum: [e3.value] } : { type: "bigint" === r3 ? "integer" : r3, const: e3.value };
          }(e2, r2);
        case l.pA.ZodEnum:
          return { type: "string", enum: e2.values };
        case l.pA.ZodNativeEnum:
          return function(e3) {
            let t3 = e3.values, r3 = Object.keys(e3.values).filter((e4) => "number" != typeof t3[t3[e4]]).map((e4) => t3[e4]), a2 = Array.from(new Set(r3.map((e4) => typeof e4)));
            return { type: 1 === a2.length ? "string" === a2[0] ? "string" : "number" : ["string", "number"], enum: r3 };
          }(e2);
        case l.pA.ZodNullable:
          return function(e3, t3) {
            if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e3.innerType._def.typeName) && (!e3.innerType._def.checks || !e3.innerType._def.checks.length))
              return "openApi3" === t3.target ? { type: E[e3.innerType._def.typeName], nullable: true } : { type: [E[e3.innerType._def.typeName], "null"] };
            if ("openApi3" === t3.target) {
              let r4 = k(e3.innerType._def, { ...t3, currentPath: [...t3.currentPath] });
              return r4 && "$ref" in r4 ? { allOf: [r4], nullable: true } : r4 && { ...r4, nullable: true };
            }
            let r3 = k(e3.innerType._def, { ...t3, currentPath: [...t3.currentPath, "anyOf", "0"] });
            return r3 && { anyOf: [r3, { type: "null" }] };
          }(e2, r2);
        case l.pA.ZodOptional:
          return O(e2, r2);
        case l.pA.ZodMap:
          return function(e3, t3) {
            return "record" === t3.mapStrategy ? w(e3, t3) : { type: "array", maxItems: 125, items: { type: "array", items: [k(e3.keyType._def, { ...t3, currentPath: [...t3.currentPath, "items", "items", "0"] }) || {}, k(e3.valueType._def, { ...t3, currentPath: [...t3.currentPath, "items", "items", "1"] }) || {}], minItems: 2, maxItems: 2 } };
          }(e2, r2);
        case l.pA.ZodSet:
          return function(e3, t3) {
            let r3 = { type: "array", uniqueItems: true, items: k(e3.valueType._def, { ...t3, currentPath: [...t3.currentPath, "items"] }) };
            return e3.minSize && c(r3, "minItems", e3.minSize.value, e3.minSize.message, t3), e3.maxSize && c(r3, "maxItems", e3.maxSize.value, e3.maxSize.message, t3), r3;
          }(e2, r2);
        case l.pA.ZodLazy:
          return k(e2.getter()._def, r2);
        case l.pA.ZodPromise:
          return k(e2.type._def, r2);
        case l.pA.ZodNaN:
        case l.pA.ZodNever:
          return { not: {} };
        case l.pA.ZodEffects:
          return function(e3, t3) {
            return "input" === t3.effectStrategy ? k(e3.schema._def, t3) : {};
          }(e2, r2);
        case l.pA.ZodAny:
        case l.pA.ZodUnknown:
          return {};
        case l.pA.ZodDefault:
          return function(e3, t3) {
            return { ...k(e3.innerType._def, t3), default: e3.defaultValue() };
          }(e2, r2);
        case l.pA.ZodBranded:
          return d(e2, r2);
        case l.pA.ZodReadonly:
          return A(e2, r2);
        case l.pA.ZodCatch:
          return h(e2, r2);
        case l.pA.ZodPipeline:
          return S(e2, r2);
        case l.pA.ZodFunction:
        case l.pA.ZodVoid:
        case l.pA.ZodSymbol:
        default:
          return;
      }
    }, I = (e2, t2, r2) => (e2.description && (r2.description = e2.description, t2.markdownDescription && (r2.markdownDescription = e2.description)), r2), R = (e2, t2) => {
      let r2 = o(t2), a2 = "object" == typeof t2 && t2.definitions ? Object.entries(t2.definitions).reduce((e3, [t3, a3]) => ({ ...e3, [t3]: k(a3._def, { ...r2, currentPath: [...r2.basePath, r2.definitionPath, t3] }, true) ?? {} }), {}) : void 0, n2 = "string" == typeof t2 ? t2 : t2?.nameStrategy === "title" ? void 0 : t2?.name, i2 = k(e2._def, void 0 === n2 ? r2 : { ...r2, currentPath: [...r2.basePath, r2.definitionPath, n2] }, false) ?? {}, s2 = "object" == typeof t2 && void 0 !== t2.name && "title" === t2.nameStrategy ? t2.name : void 0;
      void 0 !== s2 && (i2.title = s2);
      let l2 = void 0 === n2 ? a2 ? { ...i2, [r2.definitionPath]: a2 } : i2 : { $ref: [..."relative" === r2.$refStrategy ? [] : r2.basePath, r2.definitionPath, n2].join("/"), [r2.definitionPath]: { ...a2, [n2]: i2 } };
      return "jsonSchema7" === r2.target ? l2.$schema = "http://json-schema.org/draft-07/schema#" : "jsonSchema2019-09" === r2.target && (l2.$schema = "https://json-schema.org/draft/2019-09/schema#"), l2;
    };
  };
  __namedExportsObject["__chunk_7928"] = (e, t, r) => {
    "use strict";
    r.d(t, { dy: () => u, xQ: () => c });
    var a = r(1042);
    class n {
      getStore() {
      }
      run(e2, t2) {
        return t2();
      }
    }
    let i = Symbol.for("ls:tracing_async_local_storage"), s = new n();
    class o {
      getInstance() {
        return globalThis[i] ?? s;
      }
      initializeGlobalInstance(e2) {
        void 0 === globalThis[i] && (globalThis[i] = e2);
      }
    }
    let l = new o(), u = () => {
      let e2 = l.getInstance().getStore();
      if (!(0, a.n6)(e2))
        throw Error("Could not get the current run tree.\n\nPlease make sure you are calling this method within a traceable function or the tracing is enabled.");
      return e2;
    };
    function c(e2) {
      return "function" == typeof e2 && "langsmith:traceable" in e2;
    }
    Symbol.for("langsmith:traceable:root");
  };
  __namedExportsObject["__chunk_6953"] = (e, t, r) => {
    "use strict";
    r.d(t, { IV: () => a.IV, KU: () => a.KU });
    var a = r(4434);
  };
  __namedExportsObject["__chunk_9680"] = (e, t, r) => {
    "use strict";
    r.d(t, { O: () => n });
    let a = {};
    function n(e2) {
      a[e2] || (console.warn(e2), a[e2] = true);
    }
  };
  __namedExportsObject["__chunk_5325"] = (e, t, r) => {
    "use strict";
    let a, n, i;
    r.d(t, { DW: () => f, HC: () => g, lS: () => m, sA: () => p });
    var s = r(4434);
    let o = () => "undefined" != typeof window && void 0 !== window.document, l = () => "object" == typeof globalThis && globalThis.constructor && "DedicatedWorkerGlobalScope" === globalThis.constructor.name, u = () => "undefined" != typeof window && "nodejs" === window.name || "undefined" != typeof navigator && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), c = () => "undefined" != typeof Deno, d = () => "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node && !c(), h = () => a || (a = o() ? "browser" : d() ? "node" : l() ? "webworker" : u() ? "jsdom" : c() ? "deno" : "other");
    function p() {
      if (void 0 === n) {
        let e2 = h(), t2 = function() {
          if (void 0 !== i)
            return i;
          let e3 = {};
          for (let t3 of ["VERCEL_GIT_COMMIT_SHA", "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA", "COMMIT_REF", "RENDER_GIT_COMMIT", "CI_COMMIT_SHA", "CIRCLE_SHA1", "CF_PAGES_COMMIT_SHA", "REACT_APP_GIT_SHA", "SOURCE_VERSION", "GITHUB_SHA", "TRAVIS_COMMIT", "GIT_COMMIT", "BUILD_VCS_NUMBER", "bamboo_planRepository_revision", "Build.SourceVersion", "BITBUCKET_COMMIT", "DRONE_COMMIT_SHA", "SEMAPHORE_GIT_SHA", "BUILDKITE_COMMIT"]) {
            let r2 = m(t3);
            void 0 !== r2 && (e3[t3] = r2);
          }
          return i = e3, e3;
        }();
        n = { library: "langsmith", runtime: e2, sdk: "langsmith-js", sdk_version: s.I9, ...t2 };
      }
      return n;
    }
    function f() {
      let e2 = function() {
        try {
          if ("undefined" != typeof process && process.env)
            return Object.entries(process.env).reduce((e3, [t3, r3]) => (e3[t3] = String(r3), e3), {});
          return;
        } catch (e3) {
          return;
        }
      }() || {}, t2 = {}, r2 = ["LANGCHAIN_API_KEY", "LANGCHAIN_ENDPOINT", "LANGCHAIN_TRACING_V2", "LANGCHAIN_PROJECT", "LANGCHAIN_SESSION", "LANGSMITH_API_KEY", "LANGSMITH_ENDPOINT", "LANGSMITH_TRACING_V2", "LANGSMITH_PROJECT", "LANGSMITH_SESSION"];
      for (let [a2, n2] of Object.entries(e2))
        (a2.startsWith("LANGCHAIN_") || a2.startsWith("LANGSMITH_")) && "string" == typeof n2 && !r2.includes(a2) && !a2.toLowerCase().includes("key") && !a2.toLowerCase().includes("secret") && !a2.toLowerCase().includes("token") && ("LANGCHAIN_REVISION_ID" === a2 ? t2.revision_id = n2 : t2[a2] = n2);
      return t2;
    }
    function m(e2) {
      try {
        return "undefined" != typeof process ? process.env?.[e2] : void 0;
      } catch (e3) {
        return;
      }
    }
    function g(e2) {
      return m(`LANGSMITH_${e2}`) || m(`LANGCHAIN_${e2}`);
    }
  };
  __namedExportsObject["__chunk_4089"] = (e, t, r) => {
    "use strict";
    r.d(t, { s: () => i });
    let a = (...e2) => fetch(...e2), n = Symbol.for("ls:fetch_implementation"), i = () => globalThis[n] ?? a;
  };
  __namedExportsObject["__chunk_1042"] = (e, t, r) => {
    "use strict";
    r.d(t, { IV: () => c, n6: () => d });
    var a = r(2208), n = r(5325), i = r(6388);
    let s = (e2) => void 0 !== e2 ? e2 : !!["TRACING_V2", "TRACING"].find((e3) => "true" === (0, n.HC)(e3));
    var o = r(9680);
    let l = Symbol.for("lc:context_variables");
    class u {
      constructor(e2, t2) {
        Object.defineProperty(this, "metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.metadata = e2, this.tags = t2;
      }
      static fromHeader(e2) {
        let t2 = e2.split(","), r2 = {}, a2 = [];
        for (let e3 of t2) {
          let [t3, n2] = e3.split("="), i2 = decodeURIComponent(n2);
          "langsmith-metadata" === t3 ? r2 = JSON.parse(i2) : "langsmith-tags" === t3 && (a2 = i2.split(","));
        }
        return new u(r2, a2);
      }
      toHeader() {
        let e2 = [];
        return this.metadata && Object.keys(this.metadata).length > 0 && e2.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && e2.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), e2.join(",");
      }
    }
    class c {
      constructor(e2) {
        if (Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "run_type", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "project_name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "parent_run", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "child_runs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "start_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "end_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "extra", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "error", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "serialized", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "inputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "outputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "reference_example_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "events", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "trace_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "dotted_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tracingEnabled", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "execution_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "child_execution_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "attachments", { enumerable: true, configurable: true, writable: true, value: void 0 }), d(e2)) {
          Object.assign(this, { ...e2 });
          return;
        }
        let t2 = c.getDefaultConfig(), { metadata: r2, ...a2 } = e2, n2 = a2.client ?? c.getSharedClient(), i2 = { ...r2, ...a2?.extra?.metadata };
        if (a2.extra = { ...a2.extra, metadata: i2 }, Object.assign(this, { ...t2, ...a2, client: n2 }), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.execution_order ??= 1, this.child_execution_order ??= 1, !this.dotted_order) {
          let e3 = function(e4, t3, r3 = 1) {
            let a3 = r3.toFixed(0).slice(0, 3).padStart(3, "0");
            return `${new Date(e4).toISOString().slice(0, -1)}${a3}Z`.replace(/[-:.]/g, "") + t3;
          }(this.start_time, this.id, this.execution_order);
          this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + e3 : this.dotted_order = e3;
        }
      }
      static getDefaultConfig() {
        return { id: a.Z(), run_type: "chain", project_name: (0, n.lS)("LANGCHAIN_PROJECT") ?? (0, n.lS)("LANGCHAIN_SESSION") ?? "default", child_runs: [], api_url: (0, n.lS)("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984", api_key: (0, n.lS)("LANGCHAIN_API_KEY"), caller_options: {}, start_time: Date.now(), serialized: {}, inputs: {}, extra: {} };
      }
      static getSharedClient() {
        return c.sharedClient || (c.sharedClient = new i.KU()), c.sharedClient;
      }
      createChild(e2) {
        var t2;
        let r2 = this.child_execution_order + 1, a2 = new c({ ...e2, parent_run: this, project_name: this.project_name, client: this.client, tracingEnabled: this.tracingEnabled, execution_order: r2, child_execution_order: r2 });
        l in this && (a2[l] = this[l]);
        let n2 = Symbol.for("lc:child_config"), i2 = e2.extra?.[n2] ?? this.extra[n2];
        if (void 0 !== i2 && "object" == typeof i2.callbacks && (p(i2.callbacks?.handlers) || p(i2.callbacks))) {
          let e3 = { ...i2 }, r3 = "object" == typeof (t2 = e3.callbacks) && null != t2 && Array.isArray(t2.handlers) ? e3.callbacks.copy?.() : void 0;
          r3 && (Object.assign(r3, { _parentRunId: a2.id }), r3.handlers?.find(h)?.updateFromRunTree?.(a2), e3.callbacks = r3), a2.extra[n2] = e3;
        }
        let s2 = /* @__PURE__ */ new Set(), o2 = this;
        for (; null != o2 && !s2.has(o2.id); )
          s2.add(o2.id), o2.child_execution_order = Math.max(o2.child_execution_order, r2), o2 = o2.parent_run;
        return this.child_runs.push(a2), a2;
      }
      async end(e2, t2, r2 = Date.now(), a2) {
        this.outputs = this.outputs ?? e2, this.error = this.error ?? t2, this.end_time = this.end_time ?? r2, a2 && Object.keys(a2).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...a2 } } : { metadata: a2 });
      }
      _convertToCreate(e2, t2, r2 = true) {
        let a2, n2;
        let i2 = e2.extra ?? {};
        if (i2.runtime || (i2.runtime = {}), t2)
          for (let [e3, r3] of Object.entries(t2))
            i2.runtime[e3] || (i2.runtime[e3] = r3);
        return r2 ? (n2 = e2.parent_run?.id, a2 = []) : (a2 = e2.child_runs.map((e3) => this._convertToCreate(e3, t2, r2)), n2 = void 0), { id: e2.id, name: e2.name, start_time: e2.start_time, end_time: e2.end_time, run_type: e2.run_type, reference_example_id: e2.reference_example_id, extra: i2, serialized: e2.serialized, error: e2.error, inputs: e2.inputs, outputs: e2.outputs, session_name: e2.project_name, child_runs: a2, parent_run_id: n2, trace_id: e2.trace_id, dotted_order: e2.dotted_order, tags: e2.tags, attachments: e2.attachments };
      }
      async postRun(e2 = true) {
        try {
          let t2 = (0, n.sA)(), r2 = await this._convertToCreate(this, t2, true);
          if (await this.client.createRun(r2), !e2)
            for (let e3 of ((0, o.O)("Posting with excludeChildRuns=false is deprecated and will be removed in a future version."), this.child_runs))
              await e3.postRun(false);
        } catch (e3) {
          console.error(`Error in postRun for run ${this.id}:`, e3);
        }
      }
      async patchRun() {
        try {
          let e2 = { end_time: this.end_time, error: this.error, inputs: this.inputs, outputs: this.outputs, parent_run_id: this.parent_run?.id, reference_example_id: this.reference_example_id, extra: this.extra, events: this.events, dotted_order: this.dotted_order, trace_id: this.trace_id, tags: this.tags, attachments: this.attachments };
          await this.client.updateRun(this.id, e2);
        } catch (e2) {
          console.error(`Error in patchRun for run ${this.id}`, e2);
        }
      }
      toJSON() {
        return this._convertToCreate(this, void 0, false);
      }
      static fromRunnableConfig(e2, t2) {
        let r2, a2, n2;
        let i2 = e2?.callbacks, o2 = s();
        if (i2) {
          let e3 = i2?.getParentRunId?.() ?? "", t3 = i2?.handlers?.find((e4) => e4?.name == "langchain_tracer");
          r2 = t3?.getRun?.(e3), a2 = t3?.projectName, n2 = t3?.client, o2 = o2 || !!t3;
        }
        return r2 ? new c({ name: r2.name, id: r2.id, trace_id: r2.trace_id, dotted_order: r2.dotted_order, client: n2, tracingEnabled: o2, project_name: a2, tags: [...new Set((r2?.tags ?? []).concat(e2?.tags ?? []))], extra: { metadata: { ...r2?.extra?.metadata, ...e2?.metadata } } }).createChild(t2) : new c({ ...t2, client: n2, tracingEnabled: o2, project_name: a2 });
      }
      static fromDottedOrder(e2) {
        return this.fromHeaders({ "langsmith-trace": e2 });
      }
      static fromHeaders(e2, t2) {
        let r2 = "get" in e2 && "function" == typeof e2.get ? { "langsmith-trace": e2.get("langsmith-trace"), baggage: e2.get("baggage") } : e2, a2 = r2["langsmith-trace"];
        if (!a2 || "string" != typeof a2)
          return;
        let n2 = a2.trim(), i2 = n2.split(".").map((e3) => {
          let [t3, r3] = e3.split("Z");
          return { strTime: t3, time: Date.parse(t3 + "Z"), uuid: r3 };
        }), s2 = i2[0].uuid, o2 = { ...t2, name: t2?.name ?? "parent", run_type: t2?.run_type ?? "chain", start_time: t2?.start_time ?? Date.now(), id: i2.at(-1)?.uuid, trace_id: s2, dotted_order: n2 };
        if (r2.baggage && "string" == typeof r2.baggage) {
          let e3 = u.fromHeader(r2.baggage);
          o2.metadata = e3.metadata, o2.tags = e3.tags;
        }
        return new c(o2);
      }
      toHeaders(e2) {
        let t2 = { "langsmith-trace": this.dotted_order, baggage: new u(this.extra?.metadata, this.tags).toHeader() };
        if (e2)
          for (let [r2, a2] of Object.entries(t2))
            e2.set(r2, a2);
        return t2;
      }
    }
    function d(e2) {
      return void 0 !== e2 && "function" == typeof e2.createChild && "function" == typeof e2.postRun;
    }
    function h(e2) {
      return "object" == typeof e2 && null != e2 && "string" == typeof e2.name && "langchain_tracer" === e2.name;
    }
    function p(e2) {
      return Array.isArray(e2) && e2.some((e3) => h(e3));
    }
    Object.defineProperty(c, "sharedClient", { enumerable: true, configurable: true, writable: true, value: null });
  };
  __namedExportsObject["__chunk_4434"] = (e, t, r) => {
    "use strict";
    r.d(t, { I9: () => i, IV: () => n.IV, KU: () => a.KU });
    var a = r(6388), n = r(1042);
    r(4089);
    let i = "0.2.11";
  };
  __namedExportsObject["__chunk_6388"] = (e, t, r) => {
    "use strict";
    r.d(t, { KU: () => R });
    var a = r(2208), n = r(4779), i = r(7439), s = r(4089);
    let o = [400, 401, 403, 404, 405, 406, 407, 408], l = [409];
    class u {
      constructor(e2) {
        Object.defineProperty(this, "maxConcurrency", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "maxRetries", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "queue", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "onFailedResponseHook", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.maxConcurrency = e2.maxConcurrency ?? 1 / 0, this.maxRetries = e2.maxRetries ?? 6, this.queue = new i.default({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = e2?.onFailedResponseHook;
      }
      call(e2, ...t2) {
        let r2 = this.onFailedResponseHook;
        return this.queue.add(() => n(() => e2(...t2).catch((e3) => {
          if (e3 instanceof Error)
            throw e3;
          throw Error(e3);
        }), { async onFailedAttempt(e3) {
          if (e3.message.startsWith("Cancel") || e3.message.startsWith("TimeoutError") || e3.message.startsWith("AbortError") || e3?.code === "ECONNABORTED")
            throw e3;
          let t3 = e3?.response, a2 = t3?.status;
          if (a2) {
            if (o.includes(+a2))
              throw e3;
            if (l.includes(+a2))
              return;
            r2 && await r2(t3);
          }
        }, retries: this.maxRetries, randomize: true }), { throwOnTimeout: true });
      }
      callWithOptions(e2, t2, ...r2) {
        return e2.signal ? Promise.race([this.call(t2, ...r2), new Promise((t3, r3) => {
          e2.signal?.addEventListener("abort", () => {
            r3(Error("AbortError"));
          });
        })]) : this.call(t2, ...r2);
      }
      fetch(...e2) {
        return this.call(() => (0, s.s)()(...e2).then((e3) => e3.ok ? e3 : Promise.reject(e3)));
      }
    }
    function c(e2) {
      return "function" == typeof e2?._getType;
    }
    function d(e2) {
      let t2 = { type: e2._getType(), data: { content: e2.content } };
      return e2?.additional_kwargs && Object.keys(e2.additional_kwargs).length > 0 && (t2.data.additional_kwargs = { ...e2.additional_kwargs }), t2;
    }
    var h = r(5325), p = r(4434), f = r(8212);
    function m(e2, t2) {
      if (!f.Z(e2))
        throw Error(void 0 !== t2 ? `Invalid UUID for ${t2}: ${e2}` : `Invalid UUID: ${e2}`);
      return e2;
    }
    var g = r(9680);
    function y(e2) {
      if (!e2 || e2.split("/").length > 2 || e2.startsWith("/") || e2.endsWith("/") || e2.split(":").length > 2)
        throw Error(`Invalid identifier format: ${e2}`);
      let [t2, r2] = e2.split(":"), a2 = r2 || "latest";
      if (t2.includes("/")) {
        let [r3, n2] = t2.split("/", 2);
        if (!r3 || !n2)
          throw Error(`Invalid identifier format: ${e2}`);
        return [r3, n2, a2];
      }
      if (!t2)
        throw Error(`Invalid identifier format: ${e2}`);
      return ["-", t2, a2];
    }
    r(7420);
    class b extends Error {
      constructor(e2) {
        super(e2), this.name = "LangSmithConflictError";
      }
    }
    async function v(e2, t2, r2) {
      let a2;
      if (e2.ok) {
        r2 && (a2 = await e2.text());
        return;
      }
      a2 = await e2.text();
      let n2 = `Failed to ${t2}. Received status [${e2.status}]: ${e2.statusText}. Server response: ${a2}`;
      if (409 === e2.status)
        throw new b(n2);
      throw Error(n2);
    }
    var _ = { result: "[Circular]" }, w = [], E = [];
    function x(e2, t2, r2, a2) {
      try {
        return JSON.stringify(e2, t2, r2);
      } catch (o2) {
        if (!o2.message?.includes("Converting circular structure to JSON"))
          return console.warn("[WARNING]: LangSmith received unserializable value."), "[Unserializable]";
        console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance."), void 0 === a2 && (a2 = { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER }), function e3(t3, r3, a3, n3, i3, s3, o3) {
          if (s3 += 1, "object" == typeof t3 && null !== t3) {
            for (l2 = 0; l2 < n3.length; l2++)
              if (n3[l2] === t3) {
                O(_, t3, r3, i3);
                return;
              }
            if (void 0 !== o3.depthLimit && s3 > o3.depthLimit || void 0 !== o3.edgesLimit && a3 + 1 > o3.edgesLimit) {
              O("[...]", t3, r3, i3);
              return;
            }
            if (n3.push(t3), Array.isArray(t3))
              for (l2 = 0; l2 < t3.length; l2++)
                e3(t3[l2], l2, l2, n3, t3, s3, o3);
            else {
              var l2, u2 = Object.keys(t3);
              for (l2 = 0; l2 < u2.length; l2++) {
                var c2 = u2[l2];
                e3(t3[c2], c2, l2, n3, t3, s3, o3);
              }
            }
            n3.pop();
          }
        }(e2, "", 0, [], void 0, 0, a2);
        try {
          var n2;
          i2 = 0 === E.length ? JSON.stringify(e2, t2, r2) : JSON.stringify(e2, (n2 = t2, n2 = void 0 !== n2 ? n2 : function(e3, t3) {
            return t3;
          }, function(e3, t3) {
            if (E.length > 0)
              for (var r3 = 0; r3 < E.length; r3++) {
                var a3 = E[r3];
                if (a3[1] === e3 && a3[0] === t3) {
                  t3 = a3[2], E.splice(r3, 1);
                  break;
                }
              }
            return n2.call(this, e3, t3);
          }), r2);
        } catch (e3) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          for (; 0 !== w.length; ) {
            var i2, s2 = w.pop();
            4 === s2.length ? Object.defineProperty(s2[0], s2[1], s2[3]) : s2[0][s2[1]] = s2[2];
          }
        }
        return i2;
      }
    }
    function O(e2, t2, r2, a2) {
      var n2 = Object.getOwnPropertyDescriptor(a2, r2);
      void 0 !== n2.get ? n2.configurable ? (Object.defineProperty(a2, r2, { value: e2 }), w.push([a2, r2, t2, n2])) : E.push([t2, r2, e2]) : (a2[r2] = e2, w.push([a2, r2, t2]));
    }
    function S(e2) {
      let t2 = (0, h.sA)(), r2 = (0, h.DW)(), a2 = e2.extra ?? {}, n2 = a2.metadata;
      return e2.extra = { ...a2, runtime: { ...t2, ...a2?.runtime }, metadata: { ...r2, ...r2.revision_id || e2.revision_id ? { revision_id: e2.revision_id ?? r2.revision_id } : {}, ...n2 } }, e2;
    }
    let A = () => {
      let e2 = (0, h.HC)("TRACING_SAMPLING_RATE");
      if (void 0 === e2)
        return;
      let t2 = parseFloat(e2);
      if (t2 < 0 || t2 > 1)
        throw Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${t2}`);
      return t2;
    }, k = (e2) => {
      let t2 = e2.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
      return "localhost" === t2 || "127.0.0.1" === t2 || "::1" === t2;
    };
    async function T(e2) {
      let t2 = [];
      for await (let r2 of e2)
        t2.push(r2);
      return t2;
    }
    function P(e2) {
      if (void 0 !== e2)
        return e2.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
    }
    let C = async (e2) => {
      if (e2?.status === 429) {
        let t2 = 1e3 * parseInt(e2.headers.get("retry-after") ?? "30", 10);
        if (t2 > 0)
          return await new Promise((e3) => setTimeout(e3, t2)), true;
      }
      return false;
    };
    class I {
      constructor() {
        Object.defineProperty(this, "items", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "sizeBytes", { enumerable: true, configurable: true, writable: true, value: 0 });
      }
      peek() {
        return this.items[0];
      }
      push(e2) {
        let t2;
        let r2 = new Promise((e3) => {
          t2 = e3;
        }), a2 = x(e2.item).length;
        return this.items.push({ action: e2.action, payload: e2.item, itemPromiseResolve: t2, itemPromise: r2, size: a2 }), this.sizeBytes += a2, r2;
      }
      pop(e2) {
        if (e2 < 1)
          throw Error("Number of bytes to pop off may not be less than 1.");
        let t2 = [], r2 = 0;
        for (; r2 + (this.peek()?.size ?? 0) < e2 && this.items.length > 0; ) {
          let e3 = this.items.shift();
          e3 && (t2.push(e3), r2 += e3.size, this.sizeBytes -= e3.size);
        }
        if (0 === t2.length && this.items.length > 0) {
          let e3 = this.items.shift();
          t2.push(e3), r2 += e3.size, this.sizeBytes -= e3.size;
        }
        return [t2.map((e3) => ({ action: e3.action, item: e3.payload })), () => t2.forEach((e3) => e3.itemPromiseResolve())];
      }
    }
    class R {
      constructor(e2 = {}) {
        Object.defineProperty(this, "apiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "apiUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "webUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "caller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "batchIngestCaller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "timeout_ms", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_tenantId", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "hideInputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "hideOutputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tracingSampleRate", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "filteredPostUuids", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Set() }), Object.defineProperty(this, "autoBatchTracing", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "autoBatchQueue", { enumerable: true, configurable: true, writable: true, value: new I() }), Object.defineProperty(this, "autoBatchTimeout", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "autoBatchAggregationDelayMs", { enumerable: true, configurable: true, writable: true, value: 250 }), Object.defineProperty(this, "batchSizeBytesLimit", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fetchOptions", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "settings", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "blockOnRootRunFinalization", { enumerable: true, configurable: true, writable: true, value: "false" === (0, h.lS)("LANGSMITH_TRACING_BACKGROUND") }), Object.defineProperty(this, "traceBatchConcurrency", { enumerable: true, configurable: true, writable: true, value: 5 }), Object.defineProperty(this, "_serverInfo", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_getServerInfoPromise", { enumerable: true, configurable: true, writable: true, value: void 0 });
        let t2 = R.getDefaultClientConfig();
        if (this.tracingSampleRate = A(), this.apiUrl = P(e2.apiUrl ?? t2.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = P(e2.apiKey ?? t2.apiKey), this.webUrl = P(e2.webUrl ?? t2.webUrl), this.webUrl?.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.timeout_ms = e2.timeout_ms ?? 9e4, this.caller = new u(e2.callerOptions ?? {}), this.traceBatchConcurrency = e2.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
          throw Error("Trace batch concurrency must be positive.");
        this.batchIngestCaller = new u({ maxRetries: 2, maxConcurrency: this.traceBatchConcurrency, ...e2.callerOptions ?? {}, onFailedResponseHook: C }), this.hideInputs = e2.hideInputs ?? e2.anonymizer ?? t2.hideInputs, this.hideOutputs = e2.hideOutputs ?? e2.anonymizer ?? t2.hideOutputs, this.autoBatchTracing = e2.autoBatchTracing ?? this.autoBatchTracing, this.blockOnRootRunFinalization = e2.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = e2.batchSizeBytesLimit, this.fetchOptions = e2.fetchOptions || {};
      }
      static getDefaultClientConfig() {
        let e2 = (0, h.HC)("API_KEY");
        return { apiUrl: (0, h.HC)("ENDPOINT") ?? "https://api.smith.langchain.com", apiKey: e2, webUrl: void 0, hideInputs: "true" === (0, h.HC)("HIDE_INPUTS"), hideOutputs: "true" === (0, h.HC)("HIDE_OUTPUTS") };
      }
      getHostUrl() {
        return this.webUrl ? this.webUrl : k(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
      }
      get headers() {
        let e2 = { "User-Agent": `langsmith-js/${p.I9}` };
        return this.apiKey && (e2["x-api-key"] = `${this.apiKey}`), e2;
      }
      processInputs(e2) {
        return false === this.hideInputs ? e2 : true === this.hideInputs ? {} : "function" == typeof this.hideInputs ? this.hideInputs(e2) : e2;
      }
      processOutputs(e2) {
        return false === this.hideOutputs ? e2 : true === this.hideOutputs ? {} : "function" == typeof this.hideOutputs ? this.hideOutputs(e2) : e2;
      }
      prepareRunCreateOrUpdateInputs(e2) {
        let t2 = { ...e2 };
        return void 0 !== t2.inputs && (t2.inputs = this.processInputs(t2.inputs)), void 0 !== t2.outputs && (t2.outputs = this.processOutputs(t2.outputs)), t2;
      }
      async _getResponse(e2, t2) {
        let r2 = t2?.toString() ?? "", a2 = `${this.apiUrl}${e2}?${r2}`, n2 = await this.caller.call((0, s.s)(), a2, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(n2, `Failed to fetch ${e2}`), n2;
      }
      async _get(e2, t2) {
        return (await this._getResponse(e2, t2)).json();
      }
      async *_getPaginated(e2, t2 = new URLSearchParams(), r2) {
        let a2 = Number(t2.get("offset")) || 0, n2 = Number(t2.get("limit")) || 100;
        for (; ; ) {
          t2.set("offset", String(a2)), t2.set("limit", String(n2));
          let i2 = `${this.apiUrl}${e2}?${t2}`, o2 = await this.caller.call((0, s.s)(), i2, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
          await v(o2, `Failed to fetch ${e2}`);
          let l2 = r2 ? r2(await o2.json()) : await o2.json();
          if (0 === l2.length || (yield l2, l2.length < n2))
            break;
          a2 += l2.length;
        }
      }
      async *_getCursorPaginatedList(e2, t2 = null, r2 = "POST", a2 = "runs") {
        let n2 = t2 ? { ...t2 } : {};
        for (; ; ) {
          let t3 = await this.caller.call((0, s.s)(), `${this.apiUrl}${e2}`, { method: r2, headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: JSON.stringify(n2) }), i2 = await t3.json();
          if (!i2 || !i2[a2])
            break;
          yield i2[a2];
          let o2 = i2.cursors;
          if (!o2 || !o2.next)
            break;
          n2.cursor = o2.next;
        }
      }
      _filterForSampling(e2, t2 = false) {
        if (void 0 === this.tracingSampleRate)
          return e2;
        if (t2) {
          let t3 = [];
          for (let r2 of e2)
            this.filteredPostUuids.has(r2.id) ? this.filteredPostUuids.delete(r2.id) : t3.push(r2);
          return t3;
        }
        {
          let t3 = [];
          for (let r2 of e2)
            r2.id !== r2.trace_id && !this.filteredPostUuids.has(r2.trace_id) || Math.random() < this.tracingSampleRate ? t3.push(r2) : this.filteredPostUuids.add(r2.id);
          return t3;
        }
      }
      async _getBatchSizeLimitBytes() {
        let e2 = await this._ensureServerInfo();
        return this.batchSizeBytesLimit ?? e2.batch_ingest_config?.size_limit_bytes ?? 20971520;
      }
      drainAutoBatchQueue(e2) {
        for (; this.autoBatchQueue.items.length > 0; ) {
          let [t2, r2] = this.autoBatchQueue.pop(e2);
          if (!t2.length) {
            r2();
            break;
          }
          this._processBatch(t2, r2).catch(console.error);
        }
      }
      async _processBatch(e2, t2) {
        if (!e2.length) {
          t2();
          return;
        }
        try {
          let t3 = { runCreates: e2.filter((e3) => "create" === e3.action).map((e3) => e3.item), runUpdates: e2.filter((e3) => "update" === e3.action).map((e3) => e3.item) }, r2 = await this._ensureServerInfo();
          r2?.batch_ingest_config?.use_multipart_endpoint ? await this.multipartIngestRuns(t3) : await this.batchIngestRuns(t3);
        } finally {
          t2();
        }
      }
      async processRunOperation(e2) {
        clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, "create" === e2.action && (e2.item = S(e2.item));
        let t2 = this.autoBatchQueue.push(e2), r2 = await this._getBatchSizeLimitBytes();
        return this.autoBatchQueue.sizeBytes > r2 && this.drainAutoBatchQueue(r2), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
          this.autoBatchTimeout = void 0, this.drainAutoBatchQueue(r2);
        }, this.autoBatchAggregationDelayMs)), t2;
      }
      async _getServerInfo() {
        let e2 = await (0, s.s)()(`${this.apiUrl}/info`, { method: "GET", headers: { Accept: "application/json" }, signal: AbortSignal.timeout(2500), ...this.fetchOptions });
        return await v(e2, "get server info"), e2.json();
      }
      async _ensureServerInfo() {
        return void 0 === this._getServerInfoPromise && (this._getServerInfoPromise = (async () => {
          if (void 0 === this._serverInfo)
            try {
              this._serverInfo = await this._getServerInfo();
            } catch (e2) {
              console.warn("[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.");
            }
          return this._serverInfo ?? {};
        })()), this._getServerInfoPromise.then((e2) => (void 0 === this._serverInfo && (this._getServerInfoPromise = void 0), e2));
      }
      async _getSettings() {
        return this.settings || (this.settings = this._get("/settings")), await this.settings;
      }
      async createRun(e2) {
        if (!this._filterForSampling([e2]).length)
          return;
        let t2 = { ...this.headers, "Content-Type": "application/json" }, r2 = e2.project_name;
        delete e2.project_name;
        let a2 = this.prepareRunCreateOrUpdateInputs({ session_name: r2, ...e2, start_time: e2.start_time ?? Date.now() });
        if (this.autoBatchTracing && void 0 !== a2.trace_id && void 0 !== a2.dotted_order) {
          this.processRunOperation({ action: "create", item: a2 }).catch(console.error);
          return;
        }
        let n2 = S(a2), i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/runs`, { method: "POST", headers: t2, body: x(n2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(i2, "create run", true);
      }
      async batchIngestRuns({ runCreates: e2, runUpdates: t2 }) {
        if (void 0 === e2 && void 0 === t2)
          return;
        let r2 = e2?.map((e3) => this.prepareRunCreateOrUpdateInputs(e3)) ?? [], a2 = t2?.map((e3) => this.prepareRunCreateOrUpdateInputs(e3)) ?? [];
        if (r2.length > 0 && a2.length > 0) {
          let e3 = r2.reduce((e4, t4) => (t4.id && (e4[t4.id] = t4), e4), {}), t3 = [];
          for (let r3 of a2)
            void 0 !== r3.id && e3[r3.id] ? e3[r3.id] = { ...e3[r3.id], ...r3 } : t3.push(r3);
          r2 = Object.values(e3), a2 = t3;
        }
        let n2 = { post: this._filterForSampling(r2), patch: this._filterForSampling(a2, true) };
        if (!n2.post.length && !n2.patch.length)
          return;
        let i2 = { post: [], patch: [] };
        for (let e3 of ["post", "patch"]) {
          let t3 = n2[e3].reverse(), r3 = t3.pop();
          for (; void 0 !== r3; )
            i2[e3].push(r3), r3 = t3.pop();
        }
        (i2.post.length > 0 || i2.patch.length > 0) && await this._postBatchIngestRuns(x(i2));
      }
      async _postBatchIngestRuns(e2) {
        let t2 = { ...this.headers, "Content-Type": "application/json", Accept: "application/json" }, r2 = await this.batchIngestCaller.call((0, s.s)(), `${this.apiUrl}/runs/batch`, { method: "POST", headers: t2, body: e2, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(r2, "batch create run", true);
      }
      async multipartIngestRuns({ runCreates: e2, runUpdates: t2 }) {
        if (void 0 === e2 && void 0 === t2)
          return;
        let r2 = {}, a2 = [];
        for (let t3 of e2 ?? []) {
          let e3 = this.prepareRunCreateOrUpdateInputs(t3);
          void 0 !== e3.id && void 0 !== e3.attachments && (r2[e3.id] = e3.attachments), delete e3.attachments, a2.push(e3);
        }
        let n2 = [];
        for (let e3 of t2 ?? [])
          n2.push(this.prepareRunCreateOrUpdateInputs(e3));
        if (void 0 !== a2.find((e3) => void 0 === e3.trace_id || void 0 === e3.dotted_order))
          throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
        if (void 0 !== n2.find((e3) => void 0 === e3.trace_id || void 0 === e3.dotted_order))
          throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
        if (a2.length > 0 && n2.length > 0) {
          let e3 = a2.reduce((e4, t4) => (t4.id && (e4[t4.id] = t4), e4), {}), t3 = [];
          for (let r3 of n2)
            void 0 !== r3.id && e3[r3.id] ? e3[r3.id] = { ...e3[r3.id], ...r3 } : t3.push(r3);
          a2 = Object.values(e3), n2 = t3;
        }
        if (0 === a2.length && 0 === n2.length)
          return;
        let i2 = [], s2 = [];
        for (let [e3, t3] of [["post", a2], ["patch", n2]])
          for (let a3 of t3) {
            let { inputs: t4, outputs: n3, events: o2, attachments: l2, ...u2 } = a3, c2 = { inputs: t4, outputs: n3, events: o2 }, d2 = x(u2);
            for (let [t5, r3] of (s2.push({ name: `${e3}.${u2.id}`, payload: new Blob([d2], { type: `application/json; length=${d2.length}` }) }), Object.entries(c2))) {
              if (void 0 === r3)
                continue;
              let a4 = x(r3);
              s2.push({ name: `${e3}.${u2.id}.${t5}`, payload: new Blob([a4], { type: `application/json; length=${a4.length}` }) });
            }
            if (void 0 !== u2.id) {
              let e4 = r2[u2.id];
              if (e4)
                for (let [t5, [a4, n4]] of (delete r2[u2.id], Object.entries(e4))) {
                  if (t5.includes(".")) {
                    console.warn(`Skipping attachment '${t5}' for run ${u2.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                    continue;
                  }
                  s2.push({ name: `attachment.${u2.id}.${t5}`, payload: new Blob([n4], { type: `${a4}; length=${n4.byteLength}` }) });
                }
            }
            i2.push(`trace=${u2.trace_id},id=${u2.id}`);
          }
        await this._sendMultipartRequest(s2, i2.join("; "));
      }
      async _sendMultipartRequest(e2, t2) {
        try {
          let t3 = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), r2 = [];
          for (let a3 of e2)
            r2.push(new Blob([`--${t3}\r
`])), r2.push(new Blob([`Content-Disposition: form-data; name="${a3.name}"\r
`, `Content-Type: ${a3.payload.type}\r
\r
`])), r2.push(a3.payload), r2.push(new Blob(["\r\n"]));
          r2.push(new Blob([`--${t3}--\r
`]));
          let a2 = new Blob(r2), n2 = await a2.arrayBuffer(), i2 = await this.batchIngestCaller.call((0, s.s)(), `${this.apiUrl}/runs/multipart`, { method: "POST", headers: { ...this.headers, "Content-Type": `multipart/form-data; boundary=${t3}` }, body: n2, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
          await v(i2, "ingest multipart runs", true);
        } catch (e3) {
          console.warn(`${e3.message.trim()}

Context: ${t2}`);
        }
      }
      async updateRun(e2, t2) {
        m(e2), t2.inputs && (t2.inputs = this.processInputs(t2.inputs)), t2.outputs && (t2.outputs = this.processOutputs(t2.outputs));
        let r2 = { ...t2, id: e2 };
        if (!this._filterForSampling([r2], true).length)
          return;
        if (this.autoBatchTracing && void 0 !== r2.trace_id && void 0 !== r2.dotted_order) {
          void 0 !== t2.end_time && void 0 === r2.parent_run_id && this.blockOnRootRunFinalization ? await this.processRunOperation({ action: "update", item: r2 }).catch(console.error) : this.processRunOperation({ action: "update", item: r2 }).catch(console.error);
          return;
        }
        let a2 = { ...this.headers, "Content-Type": "application/json" }, n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/runs/${e2}`, { method: "PATCH", headers: a2, body: x(t2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(n2, "update run", true);
      }
      async readRun(e2, { loadChildRuns: t2 } = { loadChildRuns: false }) {
        m(e2);
        let r2 = await this._get(`/runs/${e2}`);
        return t2 && r2.child_run_ids && (r2 = await this._loadChildRuns(r2)), r2;
      }
      async getRunUrl({ runId: e2, run: t2, projectOpts: r2 }) {
        if (void 0 !== t2) {
          let e3;
          e3 = t2.session_id ? t2.session_id : r2?.projectName ? (await this.readProject({ projectName: r2?.projectName })).id : r2?.projectId ? r2?.projectId : (await this.readProject({ projectName: (0, h.HC)("PROJECT") || "default" })).id;
          let a2 = await this._getTenantId();
          return `${this.getHostUrl()}/o/${a2}/projects/p/${e3}/r/${t2.id}?poll=true`;
        }
        if (void 0 !== e2) {
          let t3 = await this.readRun(e2);
          if (!t3.app_path)
            throw Error(`Run ${e2} has no app_path`);
          let r3 = this.getHostUrl();
          return `${r3}${t3.app_path}`;
        }
        throw Error("Must provide either runId or run");
      }
      async _loadChildRuns(e2) {
        let t2 = await T(this.listRuns({ id: e2.child_run_ids })), r2 = {}, a2 = {};
        for (let e3 of (t2.sort((e4, t3) => (e4?.dotted_order ?? "").localeCompare(t3?.dotted_order ?? "")), t2)) {
          if (null === e3.parent_run_id || void 0 === e3.parent_run_id)
            throw Error(`Child run ${e3.id} has no parent`);
          e3.parent_run_id in r2 || (r2[e3.parent_run_id] = []), r2[e3.parent_run_id].push(e3), a2[e3.id] = e3;
        }
        for (let t3 in e2.child_runs = r2[e2.id] || [], r2)
          t3 !== e2.id && (a2[t3].child_runs = r2[t3]);
        return e2;
      }
      async *listRuns(e2) {
        let { projectId: t2, projectName: r2, parentRunId: a2, traceId: n2, referenceExampleId: i2, startTime: s2, executionOrder: o2, isRoot: l2, runType: u2, error: c2, id: d2, query: h2, filter: p2, traceFilter: f2, treeFilter: m2, limit: g2, select: y2 } = e2, b2 = [];
        if (t2 && (b2 = Array.isArray(t2) ? t2 : [t2]), r2) {
          let e3 = Array.isArray(r2) ? r2 : [r2], t3 = await Promise.all(e3.map((e4) => this.readProject({ projectName: e4 }).then((e5) => e5.id)));
          b2.push(...t3);
        }
        let v2 = { session: b2.length ? b2 : null, run_type: u2, reference_example: i2, query: h2, filter: p2, trace_filter: f2, tree_filter: m2, execution_order: o2, parent_run: a2, start_time: s2 ? s2.toISOString() : null, error: c2, id: d2, limit: g2, trace: n2, select: y2 || ["app_path", "child_run_ids", "completion_cost", "completion_tokens", "dotted_order", "end_time", "error", "events", "extra", "feedback_stats", "first_token_time", "id", "inputs", "name", "outputs", "parent_run_id", "parent_run_ids", "prompt_cost", "prompt_tokens", "reference_example_id", "run_type", "session_id", "start_time", "status", "tags", "total_cost", "total_tokens", "trace_id"], is_root: l2 }, _2 = 0;
        for await (let e3 of this._getCursorPaginatedList("/runs/query", v2))
          if (g2) {
            if (_2 >= g2)
              break;
            if (e3.length + _2 > g2) {
              let t3 = e3.slice(0, g2 - _2);
              yield* t3;
              break;
            }
            _2 += e3.length, yield* e3;
          } else
            yield* e3;
      }
      async getRunStats({ id: e2, trace: t2, parentRun: r2, runType: a2, projectNames: n2, projectIds: i2, referenceExampleIds: o2, startTime: l2, endTime: u2, error: c2, query: d2, filter: h2, traceFilter: p2, treeFilter: f2, isRoot: m2, dataSourceType: g2 }) {
        let y2 = i2 || [];
        n2 && (y2 = [...i2 || [], ...await Promise.all(n2.map((e3) => this.readProject({ projectName: e3 }).then((e4) => e4.id)))]);
        let b2 = Object.fromEntries(Object.entries({ id: e2, trace: t2, parent_run: r2, run_type: a2, session: y2, reference_example: o2, start_time: l2, end_time: u2, error: c2, query: d2, filter: h2, trace_filter: p2, tree_filter: f2, is_root: m2, data_source_type: g2 }).filter(([e3, t3]) => void 0 !== t3)), v2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/runs/stats`, { method: "POST", headers: this.headers, body: JSON.stringify(b2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v2.json();
      }
      async shareRun(e2, { shareId: t2 } = {}) {
        let r2 = { run_id: e2, share_token: t2 || a.Z() };
        m(e2);
        let n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/runs/${e2}/share`, { method: "PUT", headers: this.headers, body: JSON.stringify(r2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions }), i2 = await n2.json();
        if (null === i2 || !("share_token" in i2))
          throw Error("Invalid response from server");
        return `${this.getHostUrl()}/public/${i2.share_token}/r`;
      }
      async unshareRun(e2) {
        m(e2);
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/runs/${e2}/share`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(t2, "unshare run", true);
      }
      async readRunSharedLink(e2) {
        m(e2);
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/runs/${e2}/share`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions }), r2 = await t2.json();
        if (null !== r2 && "share_token" in r2)
          return `${this.getHostUrl()}/public/${r2.share_token}/r`;
      }
      async listSharedRuns(e2, { runIds: t2 } = {}) {
        let r2 = new URLSearchParams({ share_token: e2 });
        if (void 0 !== t2)
          for (let e3 of t2)
            r2.append("id", e3);
        m(e2);
        let a2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/public/${e2}/runs${r2}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await a2.json();
      }
      async readDatasetSharedSchema(e2, t2) {
        if (!e2 && !t2)
          throw Error("Either datasetId or datasetName must be given");
        e2 || (e2 = (await this.readDataset({ datasetName: t2 })).id), m(e2);
        let r2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${e2}/share`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions }), a2 = await r2.json();
        return a2.url = `${this.getHostUrl()}/public/${a2.share_token}/d`, a2;
      }
      async shareDataset(e2, t2) {
        if (!e2 && !t2)
          throw Error("Either datasetId or datasetName must be given");
        e2 || (e2 = (await this.readDataset({ datasetName: t2 })).id);
        let r2 = { dataset_id: e2 };
        m(e2);
        let a2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${e2}/share`, { method: "PUT", headers: this.headers, body: JSON.stringify(r2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions }), n2 = await a2.json();
        return n2.url = `${this.getHostUrl()}/public/${n2.share_token}/d`, n2;
      }
      async unshareDataset(e2) {
        m(e2);
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${e2}/share`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(t2, "unshare dataset", true);
      }
      async readSharedDataset(e2) {
        m(e2);
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/public/${e2}/datasets`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await t2.json();
      }
      async listSharedExamples(e2, t2) {
        let r2 = {};
        t2?.exampleIds && (r2.id = t2.exampleIds);
        let a2 = new URLSearchParams();
        Object.entries(r2).forEach(([e3, t3]) => {
          Array.isArray(t3) ? t3.forEach((t4) => a2.append(e3, t4)) : a2.append(e3, t3);
        });
        let n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/public/${e2}/examples?${a2.toString()}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions }), i2 = await n2.json();
        if (!n2.ok) {
          if ("detail" in i2)
            throw Error(`Failed to list shared examples.
Status: ${n2.status}
Message: ${i2.detail.join("\n")}`);
          throw Error(`Failed to list shared examples: ${n2.status} ${n2.statusText}`);
        }
        return i2.map((e3) => ({ ...e3, _hostUrl: this.getHostUrl() }));
      }
      async createProject({ projectName: e2, description: t2 = null, metadata: r2 = null, upsert: a2 = false, projectExtra: n2 = null, referenceDatasetId: i2 = null }) {
        let o2 = `${this.apiUrl}/sessions${a2 ? "?upsert=true" : ""}`, l2 = n2 || {};
        r2 && (l2.metadata = r2);
        let u2 = { name: e2, extra: l2, description: t2 };
        null !== i2 && (u2.reference_dataset_id = i2);
        let c2 = await this.caller.call((0, s.s)(), o2, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(u2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(c2, "create project"), await c2.json();
      }
      async updateProject(e2, { name: t2 = null, description: r2 = null, metadata: a2 = null, projectExtra: n2 = null, endTime: i2 = null }) {
        let o2 = `${this.apiUrl}/sessions/${e2}`, l2 = n2;
        a2 && (l2 = { ...l2 || {}, metadata: a2 });
        let u2 = { name: t2, extra: l2, description: r2, end_time: i2 ? new Date(i2).toISOString() : null }, c2 = await this.caller.call((0, s.s)(), o2, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(u2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(c2, "update project"), await c2.json();
      }
      async hasProject({ projectId: e2, projectName: t2 }) {
        let r2 = "/sessions", a2 = new URLSearchParams();
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either projectName or projectId, not both");
        if (void 0 !== e2)
          m(e2), r2 += `/${e2}`;
        else if (void 0 !== t2)
          a2.append("name", t2);
        else
          throw Error("Must provide projectName or projectId");
        let n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}${r2}?${a2}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        try {
          let e3 = await n2.json();
          if (!n2.ok)
            return false;
          if (Array.isArray(e3))
            return e3.length > 0;
          return true;
        } catch (e3) {
          return false;
        }
      }
      async readProject({ projectId: e2, projectName: t2, includeStats: r2 }) {
        let a2, n2 = "/sessions", i2 = new URLSearchParams();
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either projectName or projectId, not both");
        if (void 0 !== e2)
          m(e2), n2 += `/${e2}`;
        else if (void 0 !== t2)
          i2.append("name", t2);
        else
          throw Error("Must provide projectName or projectId");
        void 0 !== r2 && i2.append("include_stats", r2.toString());
        let s2 = await this._get(n2, i2);
        if (Array.isArray(s2)) {
          if (0 === s2.length)
            throw Error(`Project[id=${e2}, name=${t2}] not found`);
          a2 = s2[0];
        } else
          a2 = s2;
        return a2;
      }
      async getProjectUrl({ projectId: e2, projectName: t2 }) {
        if (void 0 === e2 && void 0 === t2)
          throw Error("Must provide either projectName or projectId");
        let r2 = await this.readProject({ projectId: e2, projectName: t2 }), a2 = await this._getTenantId();
        return `${this.getHostUrl()}/o/${a2}/projects/p/${r2.id}`;
      }
      async getDatasetUrl({ datasetId: e2, datasetName: t2 }) {
        if (void 0 === e2 && void 0 === t2)
          throw Error("Must provide either datasetName or datasetId");
        let r2 = await this.readDataset({ datasetId: e2, datasetName: t2 }), a2 = await this._getTenantId();
        return `${this.getHostUrl()}/o/${a2}/datasets/${r2.id}`;
      }
      async _getTenantId() {
        if (null !== this._tenantId)
          return this._tenantId;
        let e2 = new URLSearchParams({ limit: "1" });
        for await (let t2 of this._getPaginated("/sessions", e2))
          return this._tenantId = t2[0].tenant_id, t2[0].tenant_id;
        throw Error("No projects found to resolve tenant.");
      }
      async *listProjects({ projectIds: e2, name: t2, nameContains: r2, referenceDatasetId: a2, referenceDatasetName: n2, referenceFree: i2, metadata: s2 } = {}) {
        let o2 = new URLSearchParams();
        if (void 0 !== e2)
          for (let t3 of e2)
            o2.append("id", t3);
        if (void 0 !== t2 && o2.append("name", t2), void 0 !== r2 && o2.append("name_contains", r2), void 0 !== a2)
          o2.append("reference_dataset", a2);
        else if (void 0 !== n2) {
          let e3 = await this.readDataset({ datasetName: n2 });
          o2.append("reference_dataset", e3.id);
        }
        for await (let e3 of (void 0 !== i2 && o2.append("reference_free", i2.toString()), void 0 !== s2 && o2.append("metadata", JSON.stringify(s2)), this._getPaginated("/sessions", o2)))
          yield* e3;
      }
      async deleteProject({ projectId: e2, projectName: t2 }) {
        let r2;
        if (void 0 === e2 && void 0 === t2)
          throw Error("Must provide projectName or projectId");
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either projectName or projectId, not both");
        m(r2 = void 0 === e2 ? (await this.readProject({ projectName: t2 })).id : e2);
        let a2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/sessions/${r2}`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(a2, `delete session ${r2} (${t2})`, true);
      }
      async uploadCsv({ csvFile: e2, fileName: t2, inputKeys: r2, outputKeys: a2, description: n2, dataType: i2, name: o2 }) {
        let l2 = `${this.apiUrl}/datasets/upload`, u2 = new FormData();
        u2.append("file", e2, t2), r2.forEach((e3) => {
          u2.append("input_keys", e3);
        }), a2.forEach((e3) => {
          u2.append("output_keys", e3);
        }), n2 && u2.append("description", n2), i2 && u2.append("data_type", i2), o2 && u2.append("name", o2);
        let c2 = await this.caller.call((0, s.s)(), l2, { method: "POST", headers: this.headers, body: u2, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(c2, "upload CSV"), await c2.json();
      }
      async createDataset(e2, { description: t2, dataType: r2, inputsSchema: a2, outputsSchema: n2, metadata: i2 } = {}) {
        let o2 = { name: e2, description: t2, extra: i2 ? { metadata: i2 } : void 0 };
        r2 && (o2.data_type = r2), a2 && (o2.inputs_schema_definition = a2), n2 && (o2.outputs_schema_definition = n2);
        let l2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(o2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(l2, "create dataset"), await l2.json();
      }
      async readDataset({ datasetId: e2, datasetName: t2 }) {
        let r2, a2 = "/datasets", n2 = new URLSearchParams({ limit: "1" });
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either datasetName or datasetId, not both");
        if (void 0 !== e2)
          m(e2), a2 += `/${e2}`;
        else if (void 0 !== t2)
          n2.append("name", t2);
        else
          throw Error("Must provide datasetName or datasetId");
        let i2 = await this._get(a2, n2);
        if (Array.isArray(i2)) {
          if (0 === i2.length)
            throw Error(`Dataset[id=${e2}, name=${t2}] not found`);
          r2 = i2[0];
        } else
          r2 = i2;
        return r2;
      }
      async hasDataset({ datasetId: e2, datasetName: t2 }) {
        try {
          return await this.readDataset({ datasetId: e2, datasetName: t2 }), true;
        } catch (e3) {
          if (e3 instanceof Error && e3.message.toLocaleLowerCase().includes("not found"))
            return false;
          throw e3;
        }
      }
      async diffDatasetVersions({ datasetId: e2, datasetName: t2, fromVersion: r2, toVersion: a2 }) {
        let n2 = e2;
        if (void 0 === n2 && void 0 === t2)
          throw Error("Must provide either datasetName or datasetId");
        if (void 0 !== n2 && void 0 !== t2)
          throw Error("Must provide either datasetName or datasetId, not both");
        void 0 === n2 && (n2 = (await this.readDataset({ datasetName: t2 })).id);
        let i2 = new URLSearchParams({ from_version: "string" == typeof r2 ? r2 : r2.toISOString(), to_version: "string" == typeof a2 ? a2 : a2.toISOString() });
        return await this._get(`/datasets/${n2}/versions/diff`, i2);
      }
      async readDatasetOpenaiFinetuning({ datasetId: e2, datasetName: t2 }) {
        if (void 0 !== e2)
          ;
        else if (void 0 !== t2)
          e2 = (await this.readDataset({ datasetName: t2 })).id;
        else
          throw Error("Must provide datasetName or datasetId");
        let r2 = await this._getResponse(`/datasets/${e2}/openai_ft`);
        return (await r2.text()).trim().split("\n").map((e3) => JSON.parse(e3));
      }
      async *listDatasets({ limit: e2 = 100, offset: t2 = 0, datasetIds: r2, datasetName: a2, datasetNameContains: n2, metadata: i2 } = {}) {
        let s2 = new URLSearchParams({ limit: e2.toString(), offset: t2.toString() });
        if (void 0 !== r2)
          for (let e3 of r2)
            s2.append("id", e3);
        for await (let e3 of (void 0 !== a2 && s2.append("name", a2), void 0 !== n2 && s2.append("name_contains", n2), void 0 !== i2 && s2.append("metadata", JSON.stringify(i2)), this._getPaginated("/datasets", s2)))
          yield* e3;
      }
      async updateDataset(e2) {
        let { datasetId: t2, datasetName: r2, ...a2 } = e2;
        if (!t2 && !r2)
          throw Error("Must provide either datasetName or datasetId");
        let n2 = t2 ?? (await this.readDataset({ datasetName: r2 })).id;
        m(n2);
        let i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${n2}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(a2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(i2, "update dataset"), await i2.json();
      }
      async deleteDataset({ datasetId: e2, datasetName: t2 }) {
        let r2 = "/datasets", a2 = e2;
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either datasetName or datasetId, not both");
        if (void 0 !== t2 && (a2 = (await this.readDataset({ datasetName: t2 })).id), void 0 !== a2)
          m(a2), r2 += `/${a2}`;
        else
          throw Error("Must provide datasetName or datasetId");
        let n2 = await this.caller.call((0, s.s)(), this.apiUrl + r2, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(n2, `delete ${r2}`), await n2.json();
      }
      async indexDataset({ datasetId: e2, datasetName: t2, tag: r2 }) {
        let a2 = e2;
        if (a2 || t2) {
          if (a2 && t2)
            throw Error("Must provide either datasetName or datasetId, not both");
          a2 || (a2 = (await this.readDataset({ datasetName: t2 })).id);
        } else
          throw Error("Must provide either datasetName or datasetId");
        m(a2);
        let n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${a2}/index`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify({ tag: r2 }), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(n2, "index dataset"), await n2.json();
      }
      async similarExamples(e2, t2, r2, { filter: a2 } = {}) {
        let n2 = { limit: r2, inputs: e2 };
        void 0 !== a2 && (n2.filter = a2), m(t2);
        let i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${t2}/search`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(n2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(i2, "fetch similar examples"), (await i2.json()).examples;
      }
      async createExample(e2, t2, { datasetId: r2, datasetName: a2, createdAt: n2, exampleId: i2, metadata: o2, split: l2, sourceRunId: u2 }) {
        let c2 = r2;
        if (void 0 === c2 && void 0 === a2)
          throw Error("Must provide either datasetName or datasetId");
        if (void 0 !== c2 && void 0 !== a2)
          throw Error("Must provide either datasetName or datasetId, not both");
        void 0 === c2 && (c2 = (await this.readDataset({ datasetName: a2 })).id);
        let d2 = n2 || new Date(), h2 = { dataset_id: c2, inputs: e2, outputs: t2, created_at: d2?.toISOString(), id: i2, metadata: o2, split: l2, source_run_id: u2 }, p2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/examples`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(h2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(p2, "create example"), await p2.json();
      }
      async createExamples(e2) {
        let { inputs: t2, outputs: r2, metadata: a2, sourceRunIds: n2, exampleIds: i2, datasetId: o2, datasetName: l2 } = e2, u2 = o2;
        if (void 0 === u2 && void 0 === l2)
          throw Error("Must provide either datasetName or datasetId");
        if (void 0 !== u2 && void 0 !== l2)
          throw Error("Must provide either datasetName or datasetId, not both");
        void 0 === u2 && (u2 = (await this.readDataset({ datasetName: l2 })).id);
        let c2 = t2.map((t3, s2) => ({ dataset_id: u2, inputs: t3, outputs: r2 ? r2[s2] : void 0, metadata: a2 ? a2[s2] : void 0, split: e2.splits ? e2.splits[s2] : void 0, id: i2 ? i2[s2] : void 0, source_run_id: n2 ? n2[s2] : void 0 })), d2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/examples/bulk`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(c2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(d2, "create examples"), await d2.json();
      }
      async createLLMExample(e2, t2, r2) {
        return this.createExample({ input: e2 }, { output: t2 }, r2);
      }
      async createChatExample(e2, t2, r2) {
        let a2 = e2.map((e3) => c(e3) ? d(e3) : e3), n2 = c(t2) ? d(t2) : t2;
        return this.createExample({ input: a2 }, { output: n2 }, r2);
      }
      async readExample(e2) {
        m(e2);
        let t2 = `/examples/${e2}`;
        return await this._get(t2);
      }
      async *listExamples({ datasetId: e2, datasetName: t2, exampleIds: r2, asOf: a2, splits: n2, inlineS3Urls: i2, metadata: s2, limit: o2, offset: l2, filter: u2 } = {}) {
        let c2;
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either datasetName or datasetId, not both");
        if (void 0 !== e2)
          c2 = e2;
        else if (void 0 !== t2)
          c2 = (await this.readDataset({ datasetName: t2 })).id;
        else
          throw Error("Must provide a datasetName or datasetId");
        let d2 = new URLSearchParams({ dataset: c2 }), h2 = a2 ? "string" == typeof a2 ? a2 : a2?.toISOString() : void 0;
        if (h2 && d2.append("as_of", h2), d2.append("inline_s3_urls", (i2 ?? true).toString()), void 0 !== r2)
          for (let e3 of r2)
            d2.append("id", e3);
        if (void 0 !== n2)
          for (let e3 of n2)
            d2.append("splits", e3);
        if (void 0 !== s2) {
          let e3 = JSON.stringify(s2);
          d2.append("metadata", e3);
        }
        void 0 !== o2 && d2.append("limit", o2.toString()), void 0 !== l2 && d2.append("offset", l2.toString()), void 0 !== u2 && d2.append("filter", u2);
        let p2 = 0;
        for await (let e3 of this._getPaginated("/examples", d2)) {
          for (let t3 of e3)
            yield t3, p2++;
          if (void 0 !== o2 && p2 >= o2)
            break;
        }
      }
      async deleteExample(e2) {
        m(e2);
        let t2 = `/examples/${e2}`, r2 = await this.caller.call((0, s.s)(), this.apiUrl + t2, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(r2, `delete ${t2}`), await r2.json();
      }
      async updateExample(e2, t2) {
        m(e2);
        let r2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/examples/${e2}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(t2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(r2, "update example"), await r2.json();
      }
      async updateExamples(e2) {
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/examples/bulk`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(e2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(t2, "update examples"), await t2.json();
      }
      async listDatasetSplits({ datasetId: e2, datasetName: t2, asOf: r2 }) {
        let a2;
        if (void 0 === e2 && void 0 === t2)
          throw Error("Must provide dataset name or ID");
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either datasetName or datasetId, not both");
        m(a2 = void 0 === e2 ? (await this.readDataset({ datasetName: t2 })).id : e2);
        let n2 = new URLSearchParams(), i2 = r2 ? "string" == typeof r2 ? r2 : r2?.toISOString() : void 0;
        return i2 && n2.append("as_of", i2), await this._get(`/datasets/${a2}/splits`, n2);
      }
      async updateDatasetSplits({ datasetId: e2, datasetName: t2, splitName: r2, exampleIds: a2, remove: n2 = false }) {
        let i2;
        if (void 0 === e2 && void 0 === t2)
          throw Error("Must provide dataset name or ID");
        if (void 0 !== e2 && void 0 !== t2)
          throw Error("Must provide either datasetName or datasetId, not both");
        m(i2 = void 0 === e2 ? (await this.readDataset({ datasetName: t2 })).id : e2);
        let o2 = { split_name: r2, examples: a2.map((e3) => (m(e3), e3)), remove: n2 }, l2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/${i2}/splits`, { method: "PUT", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(o2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(l2, "update dataset splits", true);
      }
      async evaluateRun(e2, t2, { sourceInfo: r2, loadChildRuns: a2, referenceExample: n2 } = { loadChildRuns: false }) {
        let i2;
        if ((0, g.O)("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead."), "string" == typeof e2)
          i2 = await this.readRun(e2, { loadChildRuns: a2 });
        else if ("object" == typeof e2 && "id" in e2)
          i2 = e2;
        else
          throw Error(`Invalid run type: ${typeof e2}`);
        null !== i2.reference_example_id && void 0 !== i2.reference_example_id && (n2 = await this.readExample(i2.reference_example_id));
        let s2 = await t2.evaluateRun(i2, n2), [o2, l2] = await this._logEvaluationFeedback(s2, i2, r2);
        return l2[0];
      }
      async createFeedback(e2, t2, { score: r2, value: n2, correction: i2, comment: o2, sourceInfo: l2, feedbackSourceType: u2 = "api", sourceRunId: c2, feedbackId: d2, feedbackConfig: h2, projectId: p2, comparativeExperimentId: f2 }) {
        if (!e2 && !p2)
          throw Error("One of runId or projectId must be provided");
        if (e2 && p2)
          throw Error("Only one of runId or projectId can be provided");
        let g2 = { type: u2 ?? "api", metadata: l2 ?? {} };
        void 0 === c2 || g2?.metadata === void 0 || g2.metadata.__run || (g2.metadata.__run = { run_id: c2 }), g2?.metadata !== void 0 && g2.metadata.__run?.run_id !== void 0 && m(g2.metadata.__run.run_id);
        let y2 = { id: d2 ?? a.Z(), run_id: e2, key: t2, score: r2, value: n2, correction: i2, comment: o2, feedback_source: g2, comparative_experiment_id: f2, feedbackConfig: h2, session_id: p2 }, b2 = `${this.apiUrl}/feedback`, _2 = await this.caller.call((0, s.s)(), b2, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(y2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(_2, "create feedback", true), y2;
      }
      async updateFeedback(e2, { score: t2, value: r2, correction: a2, comment: n2 }) {
        let i2 = {};
        null != t2 && (i2.score = t2), null != r2 && (i2.value = r2), null != a2 && (i2.correction = a2), null != n2 && (i2.comment = n2), m(e2);
        let o2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/feedback/${e2}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(i2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(o2, "update feedback", true);
      }
      async readFeedback(e2) {
        m(e2);
        let t2 = `/feedback/${e2}`;
        return await this._get(t2);
      }
      async deleteFeedback(e2) {
        m(e2);
        let t2 = `/feedback/${e2}`, r2 = await this.caller.call((0, s.s)(), this.apiUrl + t2, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(r2, `delete ${t2}`), await r2.json();
      }
      async *listFeedback({ runIds: e2, feedbackKeys: t2, feedbackSourceTypes: r2 } = {}) {
        let a2 = new URLSearchParams();
        if (e2 && a2.append("run", e2.join(",")), t2)
          for (let e3 of t2)
            a2.append("key", e3);
        if (r2)
          for (let e3 of r2)
            a2.append("source", e3);
        for await (let e3 of this._getPaginated("/feedback", a2))
          yield* e3;
      }
      async createPresignedFeedbackToken(e2, t2, { expiration: r2, feedbackConfig: a2 } = {}) {
        let n2 = { run_id: e2, feedback_key: t2, feedback_config: a2 };
        r2 ? "string" == typeof r2 ? n2.expires_at = r2 : (r2?.hours || r2?.minutes || r2?.days) && (n2.expires_in = r2) : n2.expires_in = { hours: 3 };
        let i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/feedback/tokens`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(n2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await i2.json();
      }
      async createComparativeExperiment({ name: e2, experimentIds: t2, referenceDatasetId: r2, createdAt: a2, description: n2, metadata: i2, id: o2 }) {
        if (0 === t2.length)
          throw Error("At least one experiment is required");
        if (r2 || (r2 = (await this.readProject({ projectId: t2[0] })).reference_dataset_id), null == !r2)
          throw Error("A reference dataset is required");
        let l2 = { id: o2, name: e2, experiment_ids: t2, reference_dataset_id: r2, description: n2, created_at: (a2 ?? new Date())?.toISOString(), extra: {} };
        i2 && (l2.extra.metadata = i2);
        let u2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/datasets/comparative`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(l2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await u2.json();
      }
      async *listPresignedFeedbackTokens(e2) {
        m(e2);
        let t2 = new URLSearchParams({ run_id: e2 });
        for await (let e3 of this._getPaginated("/feedback/tokens", t2))
          yield* e3;
      }
      _selectEvalResults(e2) {
        return "results" in e2 ? e2.results : [e2];
      }
      async _logEvaluationFeedback(e2, t2, r2) {
        let a2 = this._selectEvalResults(e2), n2 = [];
        for (let e3 of a2) {
          let a3 = r2 || {};
          e3.evaluatorInfo && (a3 = { ...e3.evaluatorInfo, ...a3 });
          let i2 = null;
          e3.targetRunId ? i2 = e3.targetRunId : t2 && (i2 = t2.id), n2.push(await this.createFeedback(i2, e3.key, { score: e3.score, value: e3.value, comment: e3.comment, correction: e3.correction, sourceInfo: a3, sourceRunId: e3.sourceRunId, feedbackConfig: e3.feedbackConfig, feedbackSourceType: "model" }));
        }
        return [a2, n2];
      }
      async logEvaluationFeedback(e2, t2, r2) {
        let [a2] = await this._logEvaluationFeedback(e2, t2, r2);
        return a2;
      }
      async *listAnnotationQueues(e2 = {}) {
        let { queueIds: t2, name: r2, nameContains: a2, limit: n2 } = e2, i2 = new URLSearchParams();
        t2 && t2.forEach((e3, t3) => {
          m(e3, `queueIds[${t3}]`), i2.append("ids", e3);
        }), r2 && i2.append("name", r2), a2 && i2.append("name_contains", a2), i2.append("limit", (void 0 !== n2 ? Math.min(n2, 100) : 100).toString());
        let s2 = 0;
        for await (let e3 of this._getPaginated("/annotation-queues", i2))
          if (yield* e3, s2++, void 0 !== n2 && s2 >= n2)
            break;
      }
      async createAnnotationQueue(e2) {
        let { name: t2, description: r2, queueId: n2 } = e2, i2 = { name: t2, description: r2, id: n2 || a.Z() }, o2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/annotation-queues`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(Object.fromEntries(Object.entries(i2).filter(([e3, t3]) => void 0 !== t3))), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(o2, "create annotation queue"), await o2.json();
      }
      async readAnnotationQueue(e2) {
        let t2 = await this.listAnnotationQueues({ queueIds: [e2] }).next();
        if (t2.done)
          throw Error(`Annotation queue with ID ${e2} not found`);
        return t2.value;
      }
      async updateAnnotationQueue(e2, t2) {
        let { name: r2, description: a2 } = t2, n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/annotation-queues/${m(e2, "queueId")}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify({ name: r2, description: a2 }), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(n2, "update annotation queue");
      }
      async deleteAnnotationQueue(e2) {
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/annotation-queues/${m(e2, "queueId")}`, { method: "DELETE", headers: { ...this.headers, Accept: "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(t2, "delete annotation queue");
      }
      async addRunsToAnnotationQueue(e2, t2) {
        let r2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/annotation-queues/${m(e2, "queueId")}/runs`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(t2.map((e3, t3) => m(e3, `runIds[${t3}]`).toString())), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(r2, "add runs to annotation queue");
      }
      async getRunFromAnnotationQueue(e2, t2) {
        let r2 = `/annotation-queues/${m(e2, "queueId")}/run`, a2 = await this.caller.call((0, s.s)(), `${this.apiUrl}${r2}/${t2}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(a2, "get run from annotation queue"), await a2.json();
      }
      async _currentTenantIsOwner(e2) {
        let t2 = await this._getSettings();
        return "-" == e2 || t2.tenant_handle === e2;
      }
      async _ownerConflictError(e2, t2) {
        let r2 = await this._getSettings();
        return Error(`Cannot ${e2} for another tenant.

      Current tenant: ${r2.tenant_handle}

      Requested tenant: ${t2}`);
      }
      async _getLatestCommitHash(e2) {
        let t2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/commits/${e2}/?limit=1&offset=0`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions }), r2 = await t2.json();
        if (!t2.ok) {
          let e3 = "string" == typeof r2.detail ? r2.detail : JSON.stringify(r2.detail), a2 = Error(`Error ${t2.status}: ${t2.statusText}
${e3}`);
          throw a2.statusCode = t2.status, a2;
        }
        if (0 !== r2.commits.length)
          return r2.commits[0].commit_hash;
      }
      async _likeOrUnlikePrompt(e2, t2) {
        let [r2, a2, n2] = y(e2), i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/likes/${r2}/${a2}`, { method: "POST", body: JSON.stringify({ like: t2 }), headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(i2, `${t2 ? "like" : "unlike"} prompt`), await i2.json();
      }
      async _getPromptUrl(e2) {
        let [t2, r2, a2] = y(e2);
        if (await this._currentTenantIsOwner(t2)) {
          let e3 = await this._getSettings();
          return "latest" !== a2 ? `${this.getHostUrl()}/prompts/${r2}/${a2.substring(0, 8)}?organizationId=${e3.id}` : `${this.getHostUrl()}/prompts/${r2}?organizationId=${e3.id}`;
        }
        return "latest" !== a2 ? `${this.getHostUrl()}/hub/${t2}/${r2}/${a2.substring(0, 8)}` : `${this.getHostUrl()}/hub/${t2}/${r2}`;
      }
      async promptExists(e2) {
        return !!await this.getPrompt(e2);
      }
      async likePrompt(e2) {
        return this._likeOrUnlikePrompt(e2, true);
      }
      async unlikePrompt(e2) {
        return this._likeOrUnlikePrompt(e2, false);
      }
      async *listCommits(e2) {
        for await (let t2 of this._getPaginated(`/commits/${e2}/`, new URLSearchParams(), (e3) => e3.commits))
          yield* t2;
      }
      async *listPrompts(e2) {
        let t2 = new URLSearchParams();
        for await (let r2 of (t2.append("sort_field", e2?.sortField ?? "updated_at"), t2.append("sort_direction", "desc"), t2.append("is_archived", (!!e2?.isArchived).toString()), e2?.isPublic !== void 0 && t2.append("is_public", e2.isPublic.toString()), e2?.query && t2.append("query", e2.query), this._getPaginated("/repos", t2, (e3) => e3.repos)))
          yield* r2;
      }
      async getPrompt(e2) {
        let [t2, r2, a2] = y(e2), n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/repos/${t2}/${r2}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        if (404 === n2.status)
          return null;
        await v(n2, "get prompt");
        let i2 = await n2.json();
        return i2.repo ? i2.repo : null;
      }
      async createPrompt(e2, t2) {
        let r2 = await this._getSettings();
        if (t2?.isPublic && !r2.tenant_handle)
          throw Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
        let [a2, n2, i2] = y(e2);
        if (!await this._currentTenantIsOwner(a2))
          throw await this._ownerConflictError("create a prompt", a2);
        let o2 = { repo_handle: n2, ...t2?.description && { description: t2.description }, ...t2?.readme && { readme: t2.readme }, ...t2?.tags && { tags: t2.tags }, is_public: !!t2?.isPublic }, l2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/repos/`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(o2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(l2, "create prompt");
        let { repo: u2 } = await l2.json();
        return u2;
      }
      async createCommit(e2, t2, r2) {
        if (!await this.promptExists(e2))
          throw Error("Prompt does not exist, you must create it first.");
        let [a2, n2, i2] = y(e2), o2 = r2?.parentCommitHash !== "latest" && r2?.parentCommitHash ? r2?.parentCommitHash : await this._getLatestCommitHash(`${a2}/${n2}`), l2 = { manifest: JSON.parse(JSON.stringify(t2)), parent_commit: o2 }, u2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/commits/${a2}/${n2}`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, body: JSON.stringify(l2), signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(u2, "create commit");
        let c2 = await u2.json();
        return this._getPromptUrl(`${a2}/${n2}${c2.commit_hash ? `:${c2.commit_hash}` : ""}`);
      }
      async updatePrompt(e2, t2) {
        if (!await this.promptExists(e2))
          throw Error("Prompt does not exist, you must create it first.");
        let [r2, a2] = y(e2);
        if (!await this._currentTenantIsOwner(r2))
          throw await this._ownerConflictError("update a prompt", r2);
        let n2 = {};
        if (t2?.description !== void 0 && (n2.description = t2.description), t2?.readme !== void 0 && (n2.readme = t2.readme), t2?.tags !== void 0 && (n2.tags = t2.tags), t2?.isPublic !== void 0 && (n2.is_public = t2.isPublic), t2?.isArchived !== void 0 && (n2.is_archived = t2.isArchived), 0 === Object.keys(n2).length)
          throw Error("No valid update options provided");
        let i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/repos/${r2}/${a2}`, { method: "PATCH", body: JSON.stringify(n2), headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await v(i2, "update prompt"), i2.json();
      }
      async deletePrompt(e2) {
        if (!await this.promptExists(e2))
          throw Error("Prompt does not exist, you must create it first.");
        let [t2, r2, a2] = y(e2);
        if (!await this._currentTenantIsOwner(t2))
          throw await this._ownerConflictError("delete a prompt", t2);
        let n2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/repos/${t2}/${r2}`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await n2.json();
      }
      async pullPromptCommit(e2, t2) {
        let [r2, a2, n2] = y(e2), i2 = await this.caller.call((0, s.s)(), `${this.apiUrl}/commits/${r2}/${a2}/${n2}${t2?.includeModel ? "?include_model=true" : ""}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        await v(i2, "pull prompt commit");
        let o2 = await i2.json();
        return { owner: r2, repo: a2, commit_hash: o2.commit_hash, manifest: o2.manifest, examples: o2.examples };
      }
      async _pullPrompt(e2, t2) {
        return JSON.stringify((await this.pullPromptCommit(e2, { includeModel: t2?.includeModel })).manifest);
      }
      async pushPrompt(e2, t2) {
        return (await this.promptExists(e2) ? t2 && Object.keys(t2).some((e3) => "object" !== e3) && await this.updatePrompt(e2, { description: t2?.description, readme: t2?.readme, tags: t2?.tags, isPublic: t2?.isPublic }) : await this.createPrompt(e2, { description: t2?.description, readme: t2?.readme, tags: t2?.tags, isPublic: t2?.isPublic }), t2?.object) ? await this.createCommit(e2, t2?.object, { parentCommitHash: t2?.parentCommitHash }) : await this._getPromptUrl(e2);
      }
      async clonePublicDataset(e2, t2 = {}) {
        let { sourceApiUrl: r2 = this.apiUrl, datasetName: a2 } = t2, [n2, i2] = this.parseTokenOrUrl(e2, r2), s2 = new R({ apiUrl: n2, apiKey: "placeholder" }), o2 = await s2.readSharedDataset(i2), l2 = a2 || o2.name;
        try {
          if (await this.hasDataset({ datasetId: l2 })) {
            console.log(`Dataset ${l2} already exists in your tenant. Skipping.`);
            return;
          }
        } catch (e3) {
        }
        let u2 = await s2.listSharedExamples(i2), c2 = await this.createDataset(l2, { description: o2.description, dataType: o2.data_type || "kv", inputsSchema: o2.inputs_schema_definition ?? void 0, outputsSchema: o2.outputs_schema_definition ?? void 0 });
        try {
          await this.createExamples({ inputs: u2.map((e3) => e3.inputs), outputs: u2.flatMap((e3) => e3.outputs ? [e3.outputs] : []), datasetId: c2.id });
        } catch (e3) {
          throw console.error(`An error occurred while creating dataset ${l2}. You should delete it manually.`), e3;
        }
      }
      parseTokenOrUrl(e2, t2, r2 = 2, a2 = "dataset") {
        try {
          return m(e2), [t2, e2];
        } catch (e3) {
        }
        try {
          let n2 = new URL(e2).pathname.split("/").filter((e3) => "" !== e3);
          if (n2.length >= r2) {
            let e3 = n2[n2.length - r2];
            return [t2, e3];
          }
          throw Error(`Invalid public ${a2} URL: ${e2}`);
        } catch (t3) {
          throw Error(`Invalid public ${a2} URL or token: ${e2}`);
        }
      }
      awaitPendingTraceBatches() {
        return Promise.all([...this.autoBatchQueue.items.map(({ itemPromise: e2 }) => e2), this.batchIngestCaller.queue.onIdle()]);
      }
    }
  };
  __namedExportsObject["__chunk_4601"] = (e, t, r) => {
    "use strict";
    let a, n, i, s, o, l, u, c, d, h, p;
    r.d(t, { z7: () => aL, V6: () => aF });
    let f = "RFC3986", m = { RFC1738: (e10) => String(e10).replace(/%20/g, "+"), RFC3986: (e10) => String(e10) }, g = (Object.prototype.hasOwnProperty, Array.isArray), y = (() => {
      let e10 = [];
      for (let t10 = 0; t10 < 256; ++t10)
        e10.push("%" + ((t10 < 16 ? "0" : "") + t10.toString(16)).toUpperCase());
      return e10;
    })();
    function b(e10, t10) {
      if (g(e10)) {
        let r10 = [];
        for (let a2 = 0; a2 < e10.length; a2 += 1)
          r10.push(t10(e10[a2]));
        return r10;
      }
      return t10(e10);
    }
    let v = Object.prototype.hasOwnProperty, _ = { brackets: (e10) => String(e10) + "[]", comma: "comma", indices: (e10, t10) => String(e10) + "[" + t10 + "]", repeat: (e10) => String(e10) }, w = Array.isArray, E = Array.prototype.push, x = function(e10, t10) {
      E.apply(e10, w(t10) ? t10 : [t10]);
    }, O = Date.prototype.toISOString, S = { addQueryPrefix: false, allowDots: false, allowEmptyArrays: false, arrayFormat: "indices", charset: "utf-8", charsetSentinel: false, delimiter: "&", encode: true, encodeDotInKeys: false, encoder: (e10, t10, r10, a2, n2) => {
      if (0 === e10.length)
        return e10;
      let i2 = e10;
      if ("symbol" == typeof e10 ? i2 = Symbol.prototype.toString.call(e10) : "string" != typeof e10 && (i2 = String(e10)), "iso-8859-1" === r10)
        return escape(i2).replace(/%u[0-9a-f]{4}/gi, function(e11) {
          return "%26%23" + parseInt(e11.slice(2), 16) + "%3B";
        });
      let s2 = "";
      for (let e11 = 0; e11 < i2.length; e11 += 1024) {
        let t11 = i2.length >= 1024 ? i2.slice(e11, e11 + 1024) : i2, r11 = [];
        for (let e12 = 0; e12 < t11.length; ++e12) {
          let a3 = t11.charCodeAt(e12);
          if (45 === a3 || 46 === a3 || 95 === a3 || 126 === a3 || a3 >= 48 && a3 <= 57 || a3 >= 65 && a3 <= 90 || a3 >= 97 && a3 <= 122 || "RFC1738" === n2 && (40 === a3 || 41 === a3)) {
            r11[r11.length] = t11.charAt(e12);
            continue;
          }
          if (a3 < 128) {
            r11[r11.length] = y[a3];
            continue;
          }
          if (a3 < 2048) {
            r11[r11.length] = y[192 | a3 >> 6] + y[128 | 63 & a3];
            continue;
          }
          if (a3 < 55296 || a3 >= 57344) {
            r11[r11.length] = y[224 | a3 >> 12] + y[128 | a3 >> 6 & 63] + y[128 | 63 & a3];
            continue;
          }
          e12 += 1, a3 = 65536 + ((1023 & a3) << 10 | 1023 & t11.charCodeAt(e12)), r11[r11.length] = y[240 | a3 >> 18] + y[128 | a3 >> 12 & 63] + y[128 | a3 >> 6 & 63] + y[128 | 63 & a3];
        }
        s2 += r11.join("");
      }
      return s2;
    }, encodeValuesOnly: false, format: f, formatter: m[f], indices: false, serializeDate: (e10) => O.call(e10), skipNulls: false, strictNullHandling: false }, A = {}, k = "4.76.0", T = false;
    class P {
      constructor(e10) {
        this.body = e10;
      }
      get [Symbol.toStringTag]() {
        return "MultipartBody";
      }
    }
    i || function(e10, t10 = { auto: false }) {
      if (T)
        throw Error(`you must \`import 'openai/shims/${e10.kind}'\` before importing anything else from openai`);
      if (i)
        throw Error(`can't \`import 'openai/shims/${e10.kind}'\` after \`import 'openai/shims/${i}'\``);
      T = t10.auto, i = e10.kind, s = e10.fetch, e10.Request, e10.Response, e10.Headers, o = e10.FormData, e10.Blob, l = e10.File, u = e10.ReadableStream, c = e10.getMultipartRequestOptions, d = e10.getDefaultAgent, h = e10.fileFromPath, p = e10.isFsReadStream;
    }(function({ manuallyImported: e10 } = {}) {
      let t10, r10, a2, n2;
      let i2 = e10 ? "You may need to use polyfills" : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
      try {
        t10 = fetch, r10 = Request, a2 = Response, n2 = Headers;
      } catch (e11) {
        throw Error(`this environment is missing the following Web Fetch API type: ${e11.message}. ${i2}`);
      }
      return { kind: "web", fetch: t10, Request: r10, Response: a2, Headers: n2, FormData: "undefined" != typeof FormData ? FormData : class {
        constructor() {
          throw Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${i2}`);
        }
      }, Blob: "undefined" != typeof Blob ? Blob : class {
        constructor() {
          throw Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${i2}`);
        }
      }, File: "undefined" != typeof File ? File : class {
        constructor() {
          throw Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${i2}`);
        }
      }, ReadableStream: "undefined" != typeof ReadableStream ? ReadableStream : class {
        constructor() {
          throw Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${i2}`);
        }
      }, getMultipartRequestOptions: async (e11, t11) => ({ ...t11, body: new P(e11) }), getDefaultAgent: (e11) => void 0, fileFromPath: () => {
        throw Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
      }, isFsReadStream: (e11) => false };
    }(), { auto: true });
    class C extends Error {
    }
    class I extends C {
      constructor(e10, t10, r10, a2) {
        super(`${I.makeMessage(e10, t10, r10)}`), this.status = e10, this.headers = a2, this.request_id = a2?.["x-request-id"], this.error = t10, this.code = t10?.code, this.param = t10?.param, this.type = t10?.type;
      }
      static makeMessage(e10, t10, r10) {
        let a2 = t10?.message ? "string" == typeof t10.message ? t10.message : JSON.stringify(t10.message) : t10 ? JSON.stringify(t10) : r10;
        return e10 && a2 ? `${e10} ${a2}` : e10 ? `${e10} status code (no body)` : a2 || "(no status code or body)";
      }
      static generate(e10, t10, r10, a2) {
        if (!e10)
          return new N({ message: r10, cause: tS(t10) });
        let n2 = t10?.error;
        return 400 === e10 ? new j(e10, n2, r10, a2) : 401 === e10 ? new L(e10, n2, r10, a2) : 403 === e10 ? new M(e10, n2, r10, a2) : 404 === e10 ? new D(e10, n2, r10, a2) : 409 === e10 ? new U(e10, n2, r10, a2) : 422 === e10 ? new F(e10, n2, r10, a2) : 429 === e10 ? new z(e10, n2, r10, a2) : e10 >= 500 ? new B(e10, n2, r10, a2) : new I(e10, n2, r10, a2);
      }
    }
    class R extends I {
      constructor({ message: e10 } = {}) {
        super(void 0, void 0, e10 || "Request was aborted.", void 0), this.status = void 0;
      }
    }
    class N extends I {
      constructor({ message: e10, cause: t10 }) {
        super(void 0, void 0, e10 || "Connection error.", void 0), this.status = void 0, t10 && (this.cause = t10);
      }
    }
    class $ extends N {
      constructor({ message: e10 } = {}) {
        super({ message: e10 ?? "Request timed out." });
      }
    }
    class j extends I {
      constructor() {
        super(...arguments), this.status = 400;
      }
    }
    class L extends I {
      constructor() {
        super(...arguments), this.status = 401;
      }
    }
    class M extends I {
      constructor() {
        super(...arguments), this.status = 403;
      }
    }
    class D extends I {
      constructor() {
        super(...arguments), this.status = 404;
      }
    }
    class U extends I {
      constructor() {
        super(...arguments), this.status = 409;
      }
    }
    class F extends I {
      constructor() {
        super(...arguments), this.status = 422;
      }
    }
    class z extends I {
      constructor() {
        super(...arguments), this.status = 429;
      }
    }
    class B extends I {
    }
    class q extends C {
      constructor() {
        super("Could not parse response content as the length limit was reached");
      }
    }
    class H extends C {
      constructor() {
        super("Could not parse response content as the request was rejected by the content filter");
      }
    }
    var Z, G, V, W, J, K, X, Y, Q, ee, et, er, ea, en, ei, es, eo, el, eu, ec, ed, eh, ep, ef, em, eg, ey, eb, ev, e_, ew, eE, ex, eO, eS, eA, ek, eT, eP, eC, eI, eR, eN, e$, ej, eL, eM, eD, eU, eF, ez, eB, eq, eH, eZ, eG, eV = r(6195).Buffer;
    class eW {
      constructor() {
        this.buffer = [], this.trailingCR = false;
      }
      decode(e10) {
        let t10 = this.decodeText(e10);
        if (this.trailingCR && (t10 = "\r" + t10, this.trailingCR = false), t10.endsWith("\r") && (this.trailingCR = true, t10 = t10.slice(0, -1)), !t10)
          return [];
        let r10 = eW.NEWLINE_CHARS.has(t10[t10.length - 1] || ""), a2 = t10.split(eW.NEWLINE_REGEXP);
        return (r10 && a2.pop(), 1 !== a2.length || r10) ? (this.buffer.length > 0 && (a2 = [this.buffer.join("") + a2[0], ...a2.slice(1)], this.buffer = []), r10 || (this.buffer = [a2.pop() || ""]), a2) : (this.buffer.push(a2[0]), []);
      }
      decodeText(e10) {
        if (null == e10)
          return "";
        if ("string" == typeof e10)
          return e10;
        if (void 0 !== eV) {
          if (e10 instanceof eV)
            return e10.toString();
          if (e10 instanceof Uint8Array)
            return eV.from(e10).toString();
          throw new C(`Unexpected: received non-Uint8Array (${e10.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        if ("undefined" != typeof TextDecoder) {
          if (e10 instanceof Uint8Array || e10 instanceof ArrayBuffer)
            return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(e10);
          throw new C(`Unexpected: received non-Uint8Array/ArrayBuffer (${e10.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new C("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
      }
      flush() {
        if (!this.buffer.length && !this.trailingCR)
          return [];
        let e10 = [this.buffer.join("")];
        return this.buffer = [], this.trailingCR = false, e10;
      }
    }
    eW.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]), eW.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
    class eJ {
      constructor(e10, t10) {
        this.iterator = e10, this.controller = t10;
      }
      static fromSSEResponse(e10, t10) {
        let r10 = false;
        return new eJ(async function* () {
          if (r10)
            throw Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          r10 = true;
          let a2 = false;
          try {
            for await (let r11 of eK(e10, t10))
              if (!a2) {
                if (r11.data.startsWith("[DONE]")) {
                  a2 = true;
                  continue;
                }
                if (null === r11.event) {
                  let e11;
                  try {
                    e11 = JSON.parse(r11.data);
                  } catch (e12) {
                    throw console.error("Could not parse message into JSON:", r11.data), console.error("From chunk:", r11.raw), e12;
                  }
                  if (e11 && e11.error)
                    throw new I(void 0, e11.error, void 0, void 0);
                  yield e11;
                } else {
                  let e11;
                  try {
                    e11 = JSON.parse(r11.data);
                  } catch (e12) {
                    throw console.error("Could not parse message into JSON:", r11.data), console.error("From chunk:", r11.raw), e12;
                  }
                  if ("error" == r11.event)
                    throw new I(void 0, e11.error, e11.message, void 0);
                  yield { event: r11.event, data: e11 };
                }
              }
            a2 = true;
          } catch (e11) {
            if (e11 instanceof Error && "AbortError" === e11.name)
              return;
            throw e11;
          } finally {
            a2 || t10.abort();
          }
        }, t10);
      }
      static fromReadableStream(e10, t10) {
        let r10 = false;
        async function* a2() {
          let t11 = new eW();
          for await (let r11 of eQ(e10))
            for (let e11 of t11.decode(r11))
              yield e11;
          for (let e11 of t11.flush())
            yield e11;
        }
        return new eJ(async function* () {
          if (r10)
            throw Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          r10 = true;
          let e11 = false;
          try {
            for await (let t11 of a2())
              !e11 && t11 && (yield JSON.parse(t11));
            e11 = true;
          } catch (e12) {
            if (e12 instanceof Error && "AbortError" === e12.name)
              return;
            throw e12;
          } finally {
            e11 || t10.abort();
          }
        }, t10);
      }
      [Symbol.asyncIterator]() {
        return this.iterator();
      }
      tee() {
        let e10 = [], t10 = [], r10 = this.iterator(), a2 = (a3) => ({ next: () => {
          if (0 === a3.length) {
            let a4 = r10.next();
            e10.push(a4), t10.push(a4);
          }
          return a3.shift();
        } });
        return [new eJ(() => a2(e10), this.controller), new eJ(() => a2(t10), this.controller)];
      }
      toReadableStream() {
        let e10;
        let t10 = this, r10 = new TextEncoder();
        return new u({ async start() {
          e10 = t10[Symbol.asyncIterator]();
        }, async pull(t11) {
          try {
            let { value: a2, done: n2 } = await e10.next();
            if (n2)
              return t11.close();
            let i2 = r10.encode(JSON.stringify(a2) + "\n");
            t11.enqueue(i2);
          } catch (e11) {
            t11.error(e11);
          }
        }, async cancel() {
          await e10.return?.();
        } });
      }
    }
    async function* eK(e10, t10) {
      if (!e10.body)
        throw t10.abort(), new C("Attempted to iterate over a response with no body");
      let r10 = new eY(), a2 = new eW();
      for await (let t11 of eX(eQ(e10.body)))
        for (let e11 of a2.decode(t11)) {
          let t12 = r10.decode(e11);
          t12 && (yield t12);
        }
      for (let e11 of a2.flush()) {
        let t11 = r10.decode(e11);
        t11 && (yield t11);
      }
    }
    async function* eX(e10) {
      let t10 = new Uint8Array();
      for await (let r10 of e10) {
        let e11;
        if (null == r10)
          continue;
        let a2 = r10 instanceof ArrayBuffer ? new Uint8Array(r10) : "string" == typeof r10 ? new TextEncoder().encode(r10) : r10, n2 = new Uint8Array(t10.length + a2.length);
        for (n2.set(t10), n2.set(a2, t10.length), t10 = n2; -1 !== (e11 = function(e12) {
          for (let t11 = 0; t11 < e12.length - 2; t11++) {
            if (10 === e12[t11] && 10 === e12[t11 + 1] || 13 === e12[t11] && 13 === e12[t11 + 1])
              return t11 + 2;
            if (13 === e12[t11] && 10 === e12[t11 + 1] && t11 + 3 < e12.length && 13 === e12[t11 + 2] && 10 === e12[t11 + 3])
              return t11 + 4;
          }
          return -1;
        }(t10)); )
          yield t10.slice(0, e11), t10 = t10.slice(e11);
      }
      t10.length > 0 && (yield t10);
    }
    class eY {
      constructor() {
        this.event = null, this.data = [], this.chunks = [];
      }
      decode(e10) {
        if (e10.endsWith("\r") && (e10 = e10.substring(0, e10.length - 1)), !e10) {
          if (!this.event && !this.data.length)
            return null;
          let e11 = { event: this.event, data: this.data.join("\n"), raw: this.chunks };
          return this.event = null, this.data = [], this.chunks = [], e11;
        }
        if (this.chunks.push(e10), e10.startsWith(":"))
          return null;
        let [t10, r10, a2] = function(e11, t11) {
          let r11 = e11.indexOf(":");
          return -1 !== r11 ? [e11.substring(0, r11), ":", e11.substring(r11 + t11.length)] : [e11, "", ""];
        }(e10, ":");
        return a2.startsWith(" ") && (a2 = a2.substring(1)), "event" === t10 ? this.event = a2 : "data" === t10 && this.data.push(a2), null;
      }
    }
    function eQ(e10) {
      if (e10[Symbol.asyncIterator])
        return e10;
      let t10 = e10.getReader();
      return { async next() {
        try {
          let e11 = await t10.read();
          return e11?.done && t10.releaseLock(), e11;
        } catch (e11) {
          throw t10.releaseLock(), e11;
        }
      }, async return() {
        let e11 = t10.cancel();
        return t10.releaseLock(), await e11, { done: true, value: void 0 };
      }, [Symbol.asyncIterator]() {
        return this;
      } };
    }
    var e0 = r(6195).Buffer;
    let e1 = (e10) => null != e10 && "object" == typeof e10 && "string" == typeof e10.url && "function" == typeof e10.blob, e2 = (e10) => null != e10 && "object" == typeof e10 && "string" == typeof e10.name && "number" == typeof e10.lastModified && e4(e10), e4 = (e10) => null != e10 && "object" == typeof e10 && "number" == typeof e10.size && "string" == typeof e10.type && "function" == typeof e10.text && "function" == typeof e10.slice && "function" == typeof e10.arrayBuffer, e9 = (e10) => e2(e10) || e1(e10) || p(e10);
    async function e3(e10, t10, r10) {
      var a2;
      if (e2(e10 = await e10))
        return e10;
      if (e1(e10)) {
        let a3 = await e10.blob();
        t10 || (t10 = new URL(e10.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
        let n3 = e4(a3) ? [await a3.arrayBuffer()] : [a3];
        return new l(n3, t10, r10);
      }
      let n2 = await e5(e10);
      if (t10 || (t10 = (e6((a2 = e10).name) || e6(a2.filename) || e6(a2.path)?.split(/[\\/]/).pop()) ?? "unknown_file"), !r10?.type) {
        let e11 = n2[0]?.type;
        "string" == typeof e11 && (r10 = { ...r10, type: e11 });
      }
      return new l(n2, t10, r10);
    }
    async function e5(e10) {
      let t10 = [];
      if ("string" == typeof e10 || ArrayBuffer.isView(e10) || e10 instanceof ArrayBuffer)
        t10.push(e10);
      else if (e4(e10))
        t10.push(await e10.arrayBuffer());
      else if (e8(e10))
        for await (let r10 of e10)
          t10.push(r10);
      else
        throw Error(`Unexpected data type: ${typeof e10}; constructor: ${e10?.constructor?.name}; props: ${function(e11) {
          let t11 = Object.getOwnPropertyNames(e11);
          return `[${t11.map((e12) => `"${e12}"`).join(", ")}]`;
        }(e10)}`);
      return t10;
    }
    let e6 = (e10) => "string" == typeof e10 ? e10 : void 0 !== e0 && e10 instanceof e0 ? String(e10) : void 0, e8 = (e10) => null != e10 && "object" == typeof e10 && "function" == typeof e10[Symbol.asyncIterator], e7 = (e10) => e10 && "object" == typeof e10 && e10.body && "MultipartBody" === e10[Symbol.toStringTag], te = async (e10) => {
      let t10 = await tt(e10.body);
      return c(t10, e10);
    }, tt = async (e10) => {
      let t10 = new o();
      return await Promise.all(Object.entries(e10 || {}).map(([e11, r10]) => ta(t10, e11, r10))), t10;
    }, tr = (e10) => {
      if (e9(e10))
        return true;
      if (Array.isArray(e10))
        return e10.some(tr);
      if (e10 && "object" == typeof e10) {
        for (let t10 in e10)
          if (tr(e10[t10]))
            return true;
      }
      return false;
    }, ta = async (e10, t10, r10) => {
      if (void 0 !== r10) {
        if (null == r10)
          throw TypeError(`Received null for "${t10}"; to pass null in FormData, you must use the string 'null'`);
        if ("string" == typeof r10 || "number" == typeof r10 || "boolean" == typeof r10)
          e10.append(t10, String(r10));
        else if (e9(r10)) {
          let a2 = await e3(r10);
          e10.append(t10, a2);
        } else if (Array.isArray(r10))
          await Promise.all(r10.map((r11) => ta(e10, t10 + "[]", r11)));
        else if ("object" == typeof r10)
          await Promise.all(Object.entries(r10).map(([r11, a2]) => ta(e10, `${t10}[${r11}]`, a2)));
        else
          throw TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${r10} instead`);
      }
    };
    var tn = r(6195).Buffer, ti = function(e10, t10, r10, a2, n2) {
      if ("m" === a2)
        throw TypeError("Private method is not writable");
      if ("a" === a2 && !n2)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof t10 ? e10 !== t10 || !n2 : !t10.has(e10))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === a2 ? n2.call(e10, r10) : n2 ? n2.value = r10 : t10.set(e10, r10), r10;
    }, ts = function(e10, t10, r10, a2) {
      if ("a" === r10 && !a2)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t10 ? e10 !== t10 || !a2 : !t10.has(e10))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === r10 ? a2 : "a" === r10 ? a2.call(e10) : a2 ? a2.value : t10.get(e10);
    };
    async function to(e10) {
      let { response: t10 } = e10;
      if (e10.options.stream)
        return (tC("response", t10.status, t10.url, t10.headers, t10.body), e10.options.__streamClass) ? e10.options.__streamClass.fromSSEResponse(t10, e10.controller) : eJ.fromSSEResponse(t10, e10.controller);
      if (204 === t10.status)
        return null;
      if (e10.options.__binaryResponse)
        return t10;
      let r10 = t10.headers.get("content-type");
      if (r10?.includes("application/json") || r10?.includes("application/vnd.api+json")) {
        let e11 = await t10.json();
        return tC("response", t10.status, t10.url, t10.headers, e11), tl(e11, t10);
      }
      let a2 = await t10.text();
      return tC("response", t10.status, t10.url, t10.headers, a2), a2;
    }
    function tl(e10, t10) {
      return !e10 || "object" != typeof e10 || Array.isArray(e10) ? e10 : Object.defineProperty(e10, "_request_id", { value: t10.headers.get("x-request-id"), enumerable: false });
    }
    class tu extends Promise {
      constructor(e10, t10 = to) {
        super((e11) => {
          e11(null);
        }), this.responsePromise = e10, this.parseResponse = t10;
      }
      _thenUnwrap(e10) {
        return new tu(this.responsePromise, async (t10) => tl(e10(await this.parseResponse(t10), t10), t10.response));
      }
      asResponse() {
        return this.responsePromise.then((e10) => e10.response);
      }
      async withResponse() {
        let [e10, t10] = await Promise.all([this.parse(), this.asResponse()]);
        return { data: e10, response: t10, request_id: t10.headers.get("x-request-id") };
      }
      parse() {
        return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
      }
      then(e10, t10) {
        return this.parse().then(e10, t10);
      }
      catch(e10) {
        return this.parse().catch(e10);
      }
      finally(e10) {
        return this.parse().finally(e10);
      }
    }
    class tc {
      constructor({ baseURL: e10, maxRetries: t10 = 2, timeout: r10 = 6e5, httpAgent: a2, fetch: n2 }) {
        this.baseURL = e10, this.maxRetries = tO("maxRetries", t10), this.timeout = tO("timeout", r10), this.httpAgent = a2, this.fetch = n2 ?? s;
      }
      authHeaders(e10) {
        return {};
      }
      defaultHeaders(e10) {
        return { Accept: "application/json", "Content-Type": "application/json", "User-Agent": this.getUserAgent(), ...tv(), ...this.authHeaders(e10) };
      }
      validateHeaders(e10, t10) {
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${tI()}`;
      }
      get(e10, t10) {
        return this.methodRequest("get", e10, t10);
      }
      post(e10, t10) {
        return this.methodRequest("post", e10, t10);
      }
      patch(e10, t10) {
        return this.methodRequest("patch", e10, t10);
      }
      put(e10, t10) {
        return this.methodRequest("put", e10, t10);
      }
      delete(e10, t10) {
        return this.methodRequest("delete", e10, t10);
      }
      methodRequest(e10, t10, r10) {
        return this.request(Promise.resolve(r10).then(async (r11) => {
          let a2 = r11 && e4(r11?.body) ? new DataView(await r11.body.arrayBuffer()) : r11?.body instanceof DataView ? r11.body : r11?.body instanceof ArrayBuffer ? new DataView(r11.body) : r11 && ArrayBuffer.isView(r11?.body) ? new DataView(r11.body.buffer) : r11?.body;
          return { method: e10, path: t10, ...r11, body: a2 };
        }));
      }
      getAPIList(e10, t10, r10) {
        return this.requestAPIList(t10, { method: "get", path: e10, ...r10 });
      }
      calculateContentLength(e10) {
        if ("string" == typeof e10) {
          if (void 0 !== tn)
            return tn.byteLength(e10, "utf8").toString();
          if ("undefined" != typeof TextEncoder)
            return new TextEncoder().encode(e10).length.toString();
        } else if (ArrayBuffer.isView(e10))
          return e10.byteLength.toString();
        return null;
      }
      buildRequest(e10, { retryCount: t10 = 0 } = {}) {
        let { method: r10, path: a2, query: n2, headers: i2 = {} } = e10, s2 = ArrayBuffer.isView(e10.body) || e10.__binaryRequest && "string" == typeof e10.body ? e10.body : e7(e10.body) ? e10.body.body : e10.body ? JSON.stringify(e10.body, null, 2) : null, o2 = this.calculateContentLength(s2), l2 = this.buildURL(a2, n2);
        "timeout" in e10 && tO("timeout", e10.timeout);
        let u2 = e10.timeout ?? this.timeout, c2 = e10.httpAgent ?? this.httpAgent ?? d(l2), h2 = u2 + 1e3;
        "number" == typeof c2?.options?.timeout && h2 > (c2.options.timeout ?? 0) && (c2.options.timeout = h2), this.idempotencyHeader && "get" !== r10 && (e10.idempotencyKey || (e10.idempotencyKey = this.defaultIdempotencyKey()), i2[this.idempotencyHeader] = e10.idempotencyKey);
        let p2 = this.buildHeaders({ options: e10, headers: i2, contentLength: o2, retryCount: t10 });
        return { req: { method: r10, ...s2 && { body: s2 }, headers: p2, ...c2 && { agent: c2 }, signal: e10.signal ?? null }, url: l2, timeout: u2 };
      }
      buildHeaders({ options: e10, headers: t10, contentLength: r10, retryCount: a2 }) {
        let n2 = {};
        r10 && (n2["content-length"] = r10);
        let s2 = this.defaultHeaders(e10);
        return tP(n2, s2), tP(n2, t10), e7(e10.body) && "node" !== i && delete n2["content-type"], void 0 === t$(s2, "x-stainless-retry-count") && void 0 === t$(t10, "x-stainless-retry-count") && (n2["x-stainless-retry-count"] = String(a2)), this.validateHeaders(n2, t10), n2;
      }
      async prepareOptions(e10) {
      }
      async prepareRequest(e10, { url: t10, options: r10 }) {
      }
      parseHeaders(e10) {
        return e10 ? Symbol.iterator in e10 ? Object.fromEntries(Array.from(e10).map((e11) => [...e11])) : { ...e10 } : {};
      }
      makeStatusError(e10, t10, r10, a2) {
        return I.generate(e10, t10, r10, a2);
      }
      request(e10, t10 = null) {
        return new tu(this.makeRequest(e10, t10));
      }
      async makeRequest(e10, t10) {
        let r10 = await e10, a2 = r10.maxRetries ?? this.maxRetries;
        null == t10 && (t10 = a2), await this.prepareOptions(r10);
        let { req: n2, url: i2, timeout: s2 } = this.buildRequest(r10, { retryCount: a2 - t10 });
        if (await this.prepareRequest(n2, { url: i2, options: r10 }), tC("request", i2, r10, n2.headers), r10.signal?.aborted)
          throw new R();
        let o2 = new AbortController(), l2 = await this.fetchWithTimeout(i2, n2, s2, o2).catch(tS);
        if (l2 instanceof Error) {
          if (r10.signal?.aborted)
            throw new R();
          if (t10)
            return this.retryRequest(r10, t10);
          if ("AbortError" === l2.name)
            throw new $();
          throw new N({ cause: l2 });
        }
        let u2 = tp(l2.headers);
        if (!l2.ok) {
          if (t10 && this.shouldRetry(l2)) {
            let e12 = `retrying, ${t10} attempts remaining`;
            return tC(`response (error; ${e12})`, l2.status, i2, u2), this.retryRequest(r10, t10, u2);
          }
          let e11 = await l2.text().catch((e12) => tS(e12).message), a3 = t_(e11), n3 = a3 ? void 0 : e11, s3 = t10 ? "(error; no more retries left)" : "(error; not retryable)";
          throw tC(`response (error; ${s3})`, l2.status, i2, u2, n3), this.makeStatusError(l2.status, a3, n3, u2);
        }
        return { response: l2, options: r10, controller: o2 };
      }
      requestAPIList(e10, t10) {
        return new th(this, this.makeRequest(t10, null), e10);
      }
      buildURL(e10, t10) {
        let r10 = new URL(tE(e10) ? e10 : this.baseURL + (this.baseURL.endsWith("/") && e10.startsWith("/") ? e10.slice(1) : e10)), a2 = this.defaultQuery();
        return tk(a2) || (t10 = { ...a2, ...t10 }), "object" == typeof t10 && t10 && !Array.isArray(t10) && (r10.search = this.stringifyQuery(t10)), r10.toString();
      }
      stringifyQuery(e10) {
        return Object.entries(e10).filter(([e11, t10]) => void 0 !== t10).map(([e11, t10]) => {
          if ("string" == typeof t10 || "number" == typeof t10 || "boolean" == typeof t10)
            return `${encodeURIComponent(e11)}=${encodeURIComponent(t10)}`;
          if (null === t10)
            return `${encodeURIComponent(e11)}=`;
          throw new C(`Cannot stringify type ${typeof t10}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      async fetchWithTimeout(e10, t10, r10, a2) {
        let { signal: n2, ...i2 } = t10 || {};
        n2 && n2.addEventListener("abort", () => a2.abort());
        let s2 = setTimeout(() => a2.abort(), r10);
        return this.getRequestClient().fetch.call(void 0, e10, { signal: a2.signal, ...i2 }).finally(() => {
          clearTimeout(s2);
        });
      }
      getRequestClient() {
        return { fetch: this.fetch };
      }
      shouldRetry(e10) {
        let t10 = e10.headers.get("x-should-retry");
        return "true" === t10 || "false" !== t10 && (408 === e10.status || 409 === e10.status || 429 === e10.status || e10.status >= 500);
      }
      async retryRequest(e10, t10, r10) {
        let a2;
        let n2 = r10?.["retry-after-ms"];
        if (n2) {
          let e11 = parseFloat(n2);
          Number.isNaN(e11) || (a2 = e11);
        }
        let i2 = r10?.["retry-after"];
        if (i2 && !a2) {
          let e11 = parseFloat(i2);
          a2 = Number.isNaN(e11) ? Date.parse(i2) - Date.now() : 1e3 * e11;
        }
        if (!(a2 && 0 <= a2 && a2 < 6e4)) {
          let r11 = e10.maxRetries ?? this.maxRetries;
          a2 = this.calculateDefaultRetryTimeoutMillis(t10, r11);
        }
        return await tx(a2), this.makeRequest(e10, t10 - 1);
      }
      calculateDefaultRetryTimeoutMillis(e10, t10) {
        return Math.min(0.5 * Math.pow(2, t10 - e10), 8) * (1 - 0.25 * Math.random()) * 1e3;
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${k}`;
      }
    }
    class td {
      constructor(e10, t10, r10, a2) {
        Z.set(this, void 0), ti(this, Z, e10, "f"), this.options = a2, this.response = t10, this.body = r10;
      }
      hasNextPage() {
        return !!this.getPaginatedItems().length && null != this.nextPageInfo();
      }
      async getNextPage() {
        let e10 = this.nextPageInfo();
        if (!e10)
          throw new C("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        let t10 = { ...this.options };
        if ("params" in e10 && "object" == typeof t10.query)
          t10.query = { ...t10.query, ...e10.params };
        else if ("url" in e10) {
          for (let [r10, a2] of [...Object.entries(t10.query || {}), ...e10.url.searchParams.entries()])
            e10.url.searchParams.set(r10, a2);
          t10.query = void 0, t10.path = e10.url.toString();
        }
        return await ts(this, Z, "f").requestAPIList(this.constructor, t10);
      }
      async *iterPages() {
        let e10 = this;
        for (yield e10; e10.hasNextPage(); )
          e10 = await e10.getNextPage(), yield e10;
      }
      async *[(Z = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (let e10 of this.iterPages())
          for (let t10 of e10.getPaginatedItems())
            yield t10;
      }
    }
    class th extends tu {
      constructor(e10, t10, r10) {
        super(t10, async (t11) => new r10(e10, t11.response, await to(t11), t11.options));
      }
      async *[Symbol.asyncIterator]() {
        for await (let e10 of await this)
          yield e10;
      }
    }
    let tp = (e10) => new Proxy(Object.fromEntries(e10.entries()), { get(e11, t10) {
      let r10 = t10.toString();
      return e11[r10.toLowerCase()] || e11[r10];
    } }), tf = { method: true, path: true, query: true, body: true, headers: true, maxRetries: true, stream: true, timeout: true, httpAgent: true, signal: true, idempotencyKey: true, __binaryRequest: true, __binaryResponse: true, __streamClass: true }, tm = (e10) => "object" == typeof e10 && null !== e10 && !tk(e10) && Object.keys(e10).every((e11) => tT(tf, e11)), tg = () => "undefined" != typeof Deno && null != Deno.build ? { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": k, "X-Stainless-OS": tb(Deno.build.os), "X-Stainless-Arch": ty(Deno.build.arch), "X-Stainless-Runtime": "deno", "X-Stainless-Runtime-Version": "string" == typeof Deno.version ? Deno.version : Deno.version?.deno ?? "unknown" } : { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": k, "X-Stainless-OS": "Unknown", "X-Stainless-Arch": "other:vercel", "X-Stainless-Runtime": "edge", "X-Stainless-Runtime-Version": process.version }, ty = (e10) => "x32" === e10 ? "x32" : "x86_64" === e10 || "x64" === e10 ? "x64" : "arm" === e10 ? "arm" : "aarch64" === e10 || "arm64" === e10 ? "arm64" : e10 ? `other:${e10}` : "unknown", tb = (e10) => (e10 = e10.toLowerCase()).includes("ios") ? "iOS" : "android" === e10 ? "Android" : "darwin" === e10 ? "MacOS" : "win32" === e10 ? "Windows" : "freebsd" === e10 ? "FreeBSD" : "openbsd" === e10 ? "OpenBSD" : "linux" === e10 ? "Linux" : e10 ? `Other:${e10}` : "Unknown", tv = () => a ?? (a = tg()), t_ = (e10) => {
      try {
        return JSON.parse(e10);
      } catch (e11) {
        return;
      }
    }, tw = RegExp("^(?:[a-z]+:)?//", "i"), tE = (e10) => tw.test(e10), tx = (e10) => new Promise((t10) => setTimeout(t10, e10)), tO = (e10, t10) => {
      if ("number" != typeof t10 || !Number.isInteger(t10))
        throw new C(`${e10} must be an integer`);
      if (t10 < 0)
        throw new C(`${e10} must be a positive integer`);
      return t10;
    }, tS = (e10) => {
      if (e10 instanceof Error)
        return e10;
      if ("object" == typeof e10 && null !== e10)
        try {
          return Error(JSON.stringify(e10));
        } catch {
        }
      return Error(e10);
    }, tA = (e10) => "undefined" != typeof process ? process.env?.[e10]?.trim() ?? void 0 : "undefined" != typeof Deno ? Deno.env?.get?.(e10)?.trim() : void 0;
    function tk(e10) {
      if (!e10)
        return true;
      for (let t10 in e10)
        return false;
      return true;
    }
    function tT(e10, t10) {
      return Object.prototype.hasOwnProperty.call(e10, t10);
    }
    function tP(e10, t10) {
      for (let r10 in t10) {
        if (!tT(t10, r10))
          continue;
        let a2 = r10.toLowerCase();
        if (!a2)
          continue;
        let n2 = t10[r10];
        null === n2 ? delete e10[a2] : void 0 !== n2 && (e10[a2] = n2);
      }
    }
    function tC(e10, ...t10) {
      "undefined" != typeof process && process?.env?.DEBUG === "true" && console.log(`OpenAI:DEBUG:${e10}`, ...t10);
    }
    let tI = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e10) => {
      let t10 = 16 * Math.random() | 0;
      return ("x" === e10 ? t10 : 3 & t10 | 8).toString(16);
    }), tR = () => "undefined" != typeof window && void 0 !== window.document && "undefined" != typeof navigator, tN = (e10) => "function" == typeof e10?.get, t$ = (e10, t10) => {
      let r10 = t10.toLowerCase();
      if (tN(e10)) {
        let a2 = t10[0]?.toUpperCase() + t10.substring(1).replace(/([^\w])(\w)/g, (e11, t11, r11) => t11 + r11.toUpperCase());
        for (let n2 of [t10, r10, t10.toUpperCase(), a2]) {
          let t11 = e10.get(n2);
          if (t11)
            return t11;
        }
      }
      for (let [a2, n2] of Object.entries(e10))
        if (a2.toLowerCase() === r10) {
          if (Array.isArray(n2)) {
            if (n2.length <= 1)
              return n2[0];
            return console.warn(`Received ${n2.length} entries for the ${t10} header, using the first entry.`), n2[0];
          }
          return n2;
        }
    };
    function tj(e10) {
      return null != e10 && "object" == typeof e10 && !Array.isArray(e10);
    }
    class tL {
      constructor(e10) {
        this._client = e10;
      }
    }
    class tM extends tL {
      create(e10, t10) {
        return this._client.post("/completions", { body: e10, ...t10, stream: e10.stream ?? false });
      }
    }
    class tD extends tL {
      create(e10, t10) {
        return this._client.post("/chat/completions", { body: e10, ...t10, stream: e10.stream ?? false });
      }
    }
    class tU extends tL {
      constructor() {
        super(...arguments), this.completions = new tD(this._client);
      }
    }
    tU.Completions = tD;
    class tF extends tL {
      create(e10, t10) {
        return this._client.post("/embeddings", { body: e10, ...t10 });
      }
    }
    class tz extends td {
      constructor(e10, t10, r10, a2) {
        super(e10, t10, r10, a2), this.data = r10.data || [], this.object = r10.object;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      nextPageParams() {
        return null;
      }
      nextPageInfo() {
        return null;
      }
    }
    class tB extends td {
      constructor(e10, t10, r10, a2) {
        super(e10, t10, r10, a2), this.data = r10.data || [];
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      nextPageParams() {
        let e10 = this.nextPageInfo();
        if (!e10)
          return null;
        if ("params" in e10)
          return e10.params;
        let t10 = Object.fromEntries(e10.url.searchParams);
        return Object.keys(t10).length ? t10 : null;
      }
      nextPageInfo() {
        let e10 = this.getPaginatedItems();
        if (!e10.length)
          return null;
        let t10 = e10[e10.length - 1]?.id;
        return t10 ? { params: { after: t10 } } : null;
      }
    }
    class tq extends tL {
      create(e10, t10) {
        return this._client.post("/files", te({ body: e10, ...t10 }));
      }
      retrieve(e10, t10) {
        return this._client.get(`/files/${e10}`, t10);
      }
      list(e10 = {}, t10) {
        return tm(e10) ? this.list({}, e10) : this._client.getAPIList("/files", tH, { query: e10, ...t10 });
      }
      del(e10, t10) {
        return this._client.delete(`/files/${e10}`, t10);
      }
      content(e10, t10) {
        return this._client.get(`/files/${e10}/content`, { ...t10, __binaryResponse: true });
      }
      retrieveContent(e10, t10) {
        return this._client.get(`/files/${e10}/content`, { ...t10, headers: { Accept: "application/json", ...t10?.headers } });
      }
      async waitForProcessing(e10, { pollInterval: t10 = 5e3, maxWait: r10 = 18e5 } = {}) {
        let a2 = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), n2 = Date.now(), i2 = await this.retrieve(e10);
        for (; !i2.status || !a2.has(i2.status); )
          if (await tx(t10), i2 = await this.retrieve(e10), Date.now() - n2 > r10)
            throw new $({ message: `Giving up on waiting for file ${e10} to finish processing after ${r10} milliseconds.` });
        return i2;
      }
    }
    class tH extends tB {
    }
    tq.FileObjectsPage = tH;
    class tZ extends tL {
      createVariation(e10, t10) {
        return this._client.post("/images/variations", te({ body: e10, ...t10 }));
      }
      edit(e10, t10) {
        return this._client.post("/images/edits", te({ body: e10, ...t10 }));
      }
      generate(e10, t10) {
        return this._client.post("/images/generations", { body: e10, ...t10 });
      }
    }
    class tG extends tL {
      create(e10, t10) {
        return this._client.post("/audio/speech", { body: e10, ...t10, __binaryResponse: true });
      }
    }
    class tV extends tL {
      create(e10, t10) {
        return this._client.post("/audio/transcriptions", te({ body: e10, ...t10 }));
      }
    }
    class tW extends tL {
      create(e10, t10) {
        return this._client.post("/audio/translations", te({ body: e10, ...t10 }));
      }
    }
    class tJ extends tL {
      constructor() {
        super(...arguments), this.transcriptions = new tV(this._client), this.translations = new tW(this._client), this.speech = new tG(this._client);
      }
    }
    tJ.Transcriptions = tV, tJ.Translations = tW, tJ.Speech = tG;
    class tK extends tL {
      create(e10, t10) {
        return this._client.post("/moderations", { body: e10, ...t10 });
      }
    }
    class tX extends tL {
      retrieve(e10, t10) {
        return this._client.get(`/models/${e10}`, t10);
      }
      list(e10) {
        return this._client.getAPIList("/models", tY, e10);
      }
      del(e10, t10) {
        return this._client.delete(`/models/${e10}`, t10);
      }
    }
    class tY extends tz {
    }
    tX.ModelsPage = tY;
    class tQ extends tL {
      list(e10, t10 = {}, r10) {
        return tm(t10) ? this.list(e10, {}, t10) : this._client.getAPIList(`/fine_tuning/jobs/${e10}/checkpoints`, t0, { query: t10, ...r10 });
      }
    }
    class t0 extends tB {
    }
    tQ.FineTuningJobCheckpointsPage = t0;
    class t1 extends tL {
      constructor() {
        super(...arguments), this.checkpoints = new tQ(this._client);
      }
      create(e10, t10) {
        return this._client.post("/fine_tuning/jobs", { body: e10, ...t10 });
      }
      retrieve(e10, t10) {
        return this._client.get(`/fine_tuning/jobs/${e10}`, t10);
      }
      list(e10 = {}, t10) {
        return tm(e10) ? this.list({}, e10) : this._client.getAPIList("/fine_tuning/jobs", t2, { query: e10, ...t10 });
      }
      cancel(e10, t10) {
        return this._client.post(`/fine_tuning/jobs/${e10}/cancel`, t10);
      }
      listEvents(e10, t10 = {}, r10) {
        return tm(t10) ? this.listEvents(e10, {}, t10) : this._client.getAPIList(`/fine_tuning/jobs/${e10}/events`, t4, { query: t10, ...r10 });
      }
    }
    class t2 extends tB {
    }
    class t4 extends tB {
    }
    t1.FineTuningJobsPage = t2, t1.FineTuningJobEventsPage = t4, t1.Checkpoints = tQ, t1.FineTuningJobCheckpointsPage = t0;
    class t9 extends tL {
      constructor() {
        super(...arguments), this.jobs = new t1(this._client);
      }
    }
    t9.Jobs = t1, t9.FineTuningJobsPage = t2, t9.FineTuningJobEventsPage = t4;
    class t3 extends tL {
      create(e10, t10) {
        return this._client.post("/assistants", { body: e10, ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      retrieve(e10, t10) {
        return this._client.get(`/assistants/${e10}`, { ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      update(e10, t10, r10) {
        return this._client.post(`/assistants/${e10}`, { body: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      list(e10 = {}, t10) {
        return tm(e10) ? this.list({}, e10) : this._client.getAPIList("/assistants", t5, { query: e10, ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      del(e10, t10) {
        return this._client.delete(`/assistants/${e10}`, { ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
    }
    class t5 extends tB {
    }
    function t6(e10) {
      return "function" == typeof e10.parse;
    }
    t3.AssistantsPage = t5;
    let t8 = (e10) => e10?.role === "assistant", t7 = (e10) => e10?.role === "function", re = (e10) => e10?.role === "tool";
    var rt = function(e10, t10, r10, a2, n2) {
      if ("m" === a2)
        throw TypeError("Private method is not writable");
      if ("a" === a2 && !n2)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof t10 ? e10 !== t10 || !n2 : !t10.has(e10))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === a2 ? n2.call(e10, r10) : n2 ? n2.value = r10 : t10.set(e10, r10), r10;
    }, rr = function(e10, t10, r10, a2) {
      if ("a" === r10 && !a2)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t10 ? e10 !== t10 || !a2 : !t10.has(e10))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === r10 ? a2 : "a" === r10 ? a2.call(e10) : a2 ? a2.value : t10.get(e10);
    };
    class ra {
      constructor() {
        G.add(this), this.controller = new AbortController(), V.set(this, void 0), W.set(this, () => {
        }), J.set(this, () => {
        }), K.set(this, void 0), X.set(this, () => {
        }), Y.set(this, () => {
        }), Q.set(this, {}), ee.set(this, false), et.set(this, false), er.set(this, false), ea.set(this, false), rt(this, V, new Promise((e10, t10) => {
          rt(this, W, e10, "f"), rt(this, J, t10, "f");
        }), "f"), rt(this, K, new Promise((e10, t10) => {
          rt(this, X, e10, "f"), rt(this, Y, t10, "f");
        }), "f"), rr(this, V, "f").catch(() => {
        }), rr(this, K, "f").catch(() => {
        });
      }
      _run(e10) {
        setTimeout(() => {
          e10().then(() => {
            this._emitFinal(), this._emit("end");
          }, rr(this, G, "m", en).bind(this));
        }, 0);
      }
      _connected() {
        this.ended || (rr(this, W, "f").call(this), this._emit("connect"));
      }
      get ended() {
        return rr(this, ee, "f");
      }
      get errored() {
        return rr(this, et, "f");
      }
      get aborted() {
        return rr(this, er, "f");
      }
      abort() {
        this.controller.abort();
      }
      on(e10, t10) {
        return (rr(this, Q, "f")[e10] || (rr(this, Q, "f")[e10] = [])).push({ listener: t10 }), this;
      }
      off(e10, t10) {
        let r10 = rr(this, Q, "f")[e10];
        if (!r10)
          return this;
        let a2 = r10.findIndex((e11) => e11.listener === t10);
        return a2 >= 0 && r10.splice(a2, 1), this;
      }
      once(e10, t10) {
        return (rr(this, Q, "f")[e10] || (rr(this, Q, "f")[e10] = [])).push({ listener: t10, once: true }), this;
      }
      emitted(e10) {
        return new Promise((t10, r10) => {
          rt(this, ea, true, "f"), "error" !== e10 && this.once("error", r10), this.once(e10, t10);
        });
      }
      async done() {
        rt(this, ea, true, "f"), await rr(this, K, "f");
      }
      _emit(e10, ...t10) {
        if (rr(this, ee, "f"))
          return;
        "end" === e10 && (rt(this, ee, true, "f"), rr(this, X, "f").call(this));
        let r10 = rr(this, Q, "f")[e10];
        if (r10 && (rr(this, Q, "f")[e10] = r10.filter((e11) => !e11.once), r10.forEach(({ listener: e11 }) => e11(...t10))), "abort" === e10) {
          let e11 = t10[0];
          rr(this, ea, "f") || r10?.length || Promise.reject(e11), rr(this, J, "f").call(this, e11), rr(this, Y, "f").call(this, e11), this._emit("end");
          return;
        }
        if ("error" === e10) {
          let e11 = t10[0];
          rr(this, ea, "f") || r10?.length || Promise.reject(e11), rr(this, J, "f").call(this, e11), rr(this, Y, "f").call(this, e11), this._emit("end");
        }
      }
      _emitFinal() {
      }
    }
    function rn(e10) {
      return e10?.$brand === "auto-parseable-response-format";
    }
    function ri(e10) {
      return e10?.$brand === "auto-parseable-tool";
    }
    function rs(e10, t10) {
      let r10 = e10.choices.map((e11) => {
        var r11;
        if ("length" === e11.finish_reason)
          throw new q();
        if ("content_filter" === e11.finish_reason)
          throw new H();
        return { ...e11, message: { ...e11.message, tool_calls: e11.message.tool_calls?.map((e12) => function(e13, t11) {
          let r12 = e13.tools?.find((e14) => e14.function?.name === t11.function.name);
          return { ...t11, function: { ...t11.function, parsed_arguments: ri(r12) ? r12.$parseRaw(t11.function.arguments) : r12?.function.strict ? JSON.parse(t11.function.arguments) : null } };
        }(t10, e12)) ?? [], parsed: e11.message.content && !e11.message.refusal ? (r11 = e11.message.content, t10.response_format?.type !== "json_schema" ? null : t10.response_format?.type === "json_schema" ? "$parseRaw" in t10.response_format ? t10.response_format.$parseRaw(r11) : JSON.parse(r11) : null) : null } };
      });
      return { ...e10, choices: r10 };
    }
    function ro(e10) {
      return !!rn(e10.response_format) || (e10.tools?.some((e11) => ri(e11) || "function" === e11.type && true === e11.function.strict) ?? false);
    }
    V = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), ee = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), er = /* @__PURE__ */ new WeakMap(), ea = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakSet(), en = function(e10) {
      if (rt(this, et, true, "f"), e10 instanceof Error && "AbortError" === e10.name && (e10 = new R()), e10 instanceof R)
        return rt(this, er, true, "f"), this._emit("abort", e10);
      if (e10 instanceof C)
        return this._emit("error", e10);
      if (e10 instanceof Error) {
        let t10 = new C(e10.message);
        return t10.cause = e10, this._emit("error", t10);
      }
      return this._emit("error", new C(String(e10)));
    };
    var rl = function(e10, t10, r10, a2) {
      if ("a" === r10 && !a2)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t10 ? e10 !== t10 || !a2 : !t10.has(e10))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === r10 ? a2 : "a" === r10 ? a2.call(e10) : a2 ? a2.value : t10.get(e10);
    };
    class ru extends ra {
      constructor() {
        super(...arguments), ei.add(this), this._chatCompletions = [], this.messages = [];
      }
      _addChatCompletion(e10) {
        this._chatCompletions.push(e10), this._emit("chatCompletion", e10);
        let t10 = e10.choices[0]?.message;
        return t10 && this._addMessage(t10), e10;
      }
      _addMessage(e10, t10 = true) {
        if ("content" in e10 || (e10.content = null), this.messages.push(e10), t10) {
          if (this._emit("message", e10), (t7(e10) || re(e10)) && e10.content)
            this._emit("functionCallResult", e10.content);
          else if (t8(e10) && e10.function_call)
            this._emit("functionCall", e10.function_call);
          else if (t8(e10) && e10.tool_calls)
            for (let t11 of e10.tool_calls)
              "function" === t11.type && this._emit("functionCall", t11.function);
        }
      }
      async finalChatCompletion() {
        await this.done();
        let e10 = this._chatCompletions[this._chatCompletions.length - 1];
        if (!e10)
          throw new C("stream ended without producing a ChatCompletion");
        return e10;
      }
      async finalContent() {
        return await this.done(), rl(this, ei, "m", es).call(this);
      }
      async finalMessage() {
        return await this.done(), rl(this, ei, "m", eo).call(this);
      }
      async finalFunctionCall() {
        return await this.done(), rl(this, ei, "m", el).call(this);
      }
      async finalFunctionCallResult() {
        return await this.done(), rl(this, ei, "m", eu).call(this);
      }
      async totalUsage() {
        return await this.done(), rl(this, ei, "m", ec).call(this);
      }
      allChatCompletions() {
        return [...this._chatCompletions];
      }
      _emitFinal() {
        let e10 = this._chatCompletions[this._chatCompletions.length - 1];
        e10 && this._emit("finalChatCompletion", e10);
        let t10 = rl(this, ei, "m", eo).call(this);
        t10 && this._emit("finalMessage", t10);
        let r10 = rl(this, ei, "m", es).call(this);
        r10 && this._emit("finalContent", r10);
        let a2 = rl(this, ei, "m", el).call(this);
        a2 && this._emit("finalFunctionCall", a2);
        let n2 = rl(this, ei, "m", eu).call(this);
        null != n2 && this._emit("finalFunctionCallResult", n2), this._chatCompletions.some((e11) => e11.usage) && this._emit("totalUsage", rl(this, ei, "m", ec).call(this));
      }
      async _createChatCompletion(e10, t10, r10) {
        let a2 = r10?.signal;
        a2 && (a2.aborted && this.controller.abort(), a2.addEventListener("abort", () => this.controller.abort())), rl(this, ei, "m", ed).call(this, t10);
        let n2 = await e10.chat.completions.create({ ...t10, stream: false }, { ...r10, signal: this.controller.signal });
        return this._connected(), this._addChatCompletion(rs(n2, t10));
      }
      async _runChatCompletion(e10, t10, r10) {
        for (let e11 of t10.messages)
          this._addMessage(e11, false);
        return await this._createChatCompletion(e10, t10, r10);
      }
      async _runFunctions(e10, t10, r10) {
        let a2 = "function", { function_call: n2 = "auto", stream: i2, ...s2 } = t10, o2 = "string" != typeof n2 && n2?.name, { maxChatCompletions: l2 = 10 } = r10 || {}, u2 = {};
        for (let e11 of t10.functions)
          u2[e11.name || e11.function.name] = e11;
        let c2 = t10.functions.map((e11) => ({ name: e11.name || e11.function.name, parameters: e11.parameters, description: e11.description }));
        for (let e11 of t10.messages)
          this._addMessage(e11, false);
        for (let t11 = 0; t11 < l2; ++t11) {
          let t12;
          let i3 = await this._createChatCompletion(e10, { ...s2, function_call: n2, functions: c2, messages: [...this.messages] }, r10), l3 = i3.choices[0]?.message;
          if (!l3)
            throw new C("missing message in ChatCompletion response");
          if (!l3.function_call)
            return;
          let { name: d2, arguments: h2 } = l3.function_call, p2 = u2[d2];
          if (p2) {
            if (o2 && o2 !== d2) {
              let e11 = `Invalid function_call: ${JSON.stringify(d2)}. ${JSON.stringify(o2)} requested. Please try again`;
              this._addMessage({ role: a2, name: d2, content: e11 });
              continue;
            }
          } else {
            let e11 = `Invalid function_call: ${JSON.stringify(d2)}. Available options are: ${c2.map((e12) => JSON.stringify(e12.name)).join(", ")}. Please try again`;
            this._addMessage({ role: a2, name: d2, content: e11 });
            continue;
          }
          try {
            t12 = t6(p2) ? await p2.parse(h2) : h2;
          } catch (e11) {
            this._addMessage({ role: a2, name: d2, content: e11 instanceof Error ? e11.message : String(e11) });
            continue;
          }
          let f2 = await p2.function(t12, this), m2 = rl(this, ei, "m", eh).call(this, f2);
          if (this._addMessage({ role: a2, name: d2, content: m2 }), o2)
            return;
        }
      }
      async _runTools(e10, t10, r10) {
        let a2 = "tool", { tool_choice: n2 = "auto", stream: i2, ...s2 } = t10, o2 = "string" != typeof n2 && n2?.function?.name, { maxChatCompletions: l2 = 10 } = r10 || {}, u2 = t10.tools.map((e11) => {
          if (ri(e11)) {
            if (!e11.$callback)
              throw new C("Tool given to `.runTools()` that does not have an associated function");
            return { type: "function", function: { function: e11.$callback, name: e11.function.name, description: e11.function.description || "", parameters: e11.function.parameters, parse: e11.$parseRaw, strict: true } };
          }
          return e11;
        }), c2 = {};
        for (let e11 of u2)
          "function" === e11.type && (c2[e11.function.name || e11.function.function.name] = e11.function);
        let d2 = "tools" in t10 ? u2.map((e11) => "function" === e11.type ? { type: "function", function: { name: e11.function.name || e11.function.function.name, parameters: e11.function.parameters, description: e11.function.description, strict: e11.function.strict } } : e11) : void 0;
        for (let e11 of t10.messages)
          this._addMessage(e11, false);
        for (let t11 = 0; t11 < l2; ++t11) {
          let t12 = await this._createChatCompletion(e10, { ...s2, tool_choice: n2, tools: d2, messages: [...this.messages] }, r10), i3 = t12.choices[0]?.message;
          if (!i3)
            throw new C("missing message in ChatCompletion response");
          if (!i3.tool_calls?.length)
            break;
          for (let e11 of i3.tool_calls) {
            let t13;
            if ("function" !== e11.type)
              continue;
            let r11 = e11.id, { name: n3, arguments: i4 } = e11.function, s3 = c2[n3];
            if (s3) {
              if (o2 && o2 !== n3) {
                let e12 = `Invalid tool_call: ${JSON.stringify(n3)}. ${JSON.stringify(o2)} requested. Please try again`;
                this._addMessage({ role: a2, tool_call_id: r11, content: e12 });
                continue;
              }
            } else {
              let e12 = `Invalid tool_call: ${JSON.stringify(n3)}. Available options are: ${Object.keys(c2).map((e13) => JSON.stringify(e13)).join(", ")}. Please try again`;
              this._addMessage({ role: a2, tool_call_id: r11, content: e12 });
              continue;
            }
            try {
              t13 = t6(s3) ? await s3.parse(i4) : i4;
            } catch (t14) {
              let e12 = t14 instanceof Error ? t14.message : String(t14);
              this._addMessage({ role: a2, tool_call_id: r11, content: e12 });
              continue;
            }
            let l3 = await s3.function(t13, this), u3 = rl(this, ei, "m", eh).call(this, l3);
            if (this._addMessage({ role: a2, tool_call_id: r11, content: u3 }), o2)
              return;
          }
        }
      }
    }
    ei = /* @__PURE__ */ new WeakSet(), es = function() {
      return rl(this, ei, "m", eo).call(this).content ?? null;
    }, eo = function() {
      let e10 = this.messages.length;
      for (; e10-- > 0; ) {
        let t10 = this.messages[e10];
        if (t8(t10)) {
          let { function_call: e11, ...r10 } = t10, a2 = { ...r10, content: t10.content ?? null, refusal: t10.refusal ?? null };
          return e11 && (a2.function_call = e11), a2;
        }
      }
      throw new C("stream ended without producing a ChatCompletionMessage with role=assistant");
    }, el = function() {
      for (let e10 = this.messages.length - 1; e10 >= 0; e10--) {
        let t10 = this.messages[e10];
        if (t8(t10) && t10?.function_call)
          return t10.function_call;
        if (t8(t10) && t10?.tool_calls?.length)
          return t10.tool_calls.at(-1)?.function;
      }
    }, eu = function() {
      for (let e10 = this.messages.length - 1; e10 >= 0; e10--) {
        let t10 = this.messages[e10];
        if (t7(t10) && null != t10.content || re(t10) && null != t10.content && "string" == typeof t10.content && this.messages.some((e11) => "assistant" === e11.role && e11.tool_calls?.some((e12) => "function" === e12.type && e12.id === t10.tool_call_id)))
          return t10.content;
      }
    }, ec = function() {
      let e10 = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
      for (let { usage: t10 } of this._chatCompletions)
        t10 && (e10.completion_tokens += t10.completion_tokens, e10.prompt_tokens += t10.prompt_tokens, e10.total_tokens += t10.total_tokens);
      return e10;
    }, ed = function(e10) {
      if (null != e10.n && e10.n > 1)
        throw new C("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
    }, eh = function(e10) {
      return "string" == typeof e10 ? e10 : void 0 === e10 ? "undefined" : JSON.stringify(e10);
    };
    class rc extends ru {
      static runFunctions(e10, t10, r10) {
        let a2 = new rc(), n2 = { ...r10, headers: { ...r10?.headers, "X-Stainless-Helper-Method": "runFunctions" } };
        return a2._run(() => a2._runFunctions(e10, t10, n2)), a2;
      }
      static runTools(e10, t10, r10) {
        let a2 = new rc(), n2 = { ...r10, headers: { ...r10?.headers, "X-Stainless-Helper-Method": "runTools" } };
        return a2._run(() => a2._runTools(e10, t10, n2)), a2;
      }
      _addMessage(e10, t10 = true) {
        super._addMessage(e10, t10), t8(e10) && e10.content && this._emit("content", e10.content);
      }
    }
    let rd = { STR: 1, NUM: 2, ARR: 4, OBJ: 8, NULL: 16, BOOL: 32, NAN: 64, INFINITY: 128, MINUS_INFINITY: 256, ALL: 511 };
    class rh extends Error {
    }
    class rp extends Error {
    }
    let rf = (e10, t10) => {
      let r10 = e10.length, a2 = 0, n2 = (e11) => {
        throw new rh(`${e11} at position ${a2}`);
      }, i2 = (e11) => {
        throw new rp(`${e11} at position ${a2}`);
      }, s2 = () => (d2(), a2 >= r10 && n2("Unexpected end of input"), '"' === e10[a2]) ? o2() : "{" === e10[a2] ? l2() : "[" === e10[a2] ? u2() : "null" === e10.substring(a2, a2 + 4) || rd.NULL & t10 && r10 - a2 < 4 && "null".startsWith(e10.substring(a2)) ? (a2 += 4, null) : "true" === e10.substring(a2, a2 + 4) || rd.BOOL & t10 && r10 - a2 < 4 && "true".startsWith(e10.substring(a2)) ? (a2 += 4, true) : "false" === e10.substring(a2, a2 + 5) || rd.BOOL & t10 && r10 - a2 < 5 && "false".startsWith(e10.substring(a2)) ? (a2 += 5, false) : "Infinity" === e10.substring(a2, a2 + 8) || rd.INFINITY & t10 && r10 - a2 < 8 && "Infinity".startsWith(e10.substring(a2)) ? (a2 += 8, 1 / 0) : "-Infinity" === e10.substring(a2, a2 + 9) || rd.MINUS_INFINITY & t10 && 1 < r10 - a2 && r10 - a2 < 9 && "-Infinity".startsWith(e10.substring(a2)) ? (a2 += 9, -1 / 0) : "NaN" === e10.substring(a2, a2 + 3) || rd.NAN & t10 && r10 - a2 < 3 && "NaN".startsWith(e10.substring(a2)) ? (a2 += 3, NaN) : c2(), o2 = () => {
        let s3 = a2, o3 = false;
        for (a2++; a2 < r10 && ('"' !== e10[a2] || o3 && "\\" === e10[a2 - 1]); )
          o3 = "\\" === e10[a2] && !o3, a2++;
        if ('"' == e10.charAt(a2))
          try {
            return JSON.parse(e10.substring(s3, ++a2 - Number(o3)));
          } catch (e11) {
            i2(String(e11));
          }
        else if (rd.STR & t10)
          try {
            return JSON.parse(e10.substring(s3, a2 - Number(o3)) + '"');
          } catch (t11) {
            return JSON.parse(e10.substring(s3, e10.lastIndexOf("\\")) + '"');
          }
        n2("Unterminated string literal");
      }, l2 = () => {
        a2++, d2();
        let i3 = {};
        try {
          for (; "}" !== e10[a2]; ) {
            if (d2(), a2 >= r10 && rd.OBJ & t10)
              return i3;
            let n3 = o2();
            d2(), a2++;
            try {
              let e11 = s2();
              Object.defineProperty(i3, n3, { value: e11, writable: true, enumerable: true, configurable: true });
            } catch (e11) {
              if (rd.OBJ & t10)
                return i3;
              throw e11;
            }
            d2(), "," === e10[a2] && a2++;
          }
        } catch (e11) {
          if (rd.OBJ & t10)
            return i3;
          n2("Expected '}' at end of object");
        }
        return a2++, i3;
      }, u2 = () => {
        a2++;
        let r11 = [];
        try {
          for (; "]" !== e10[a2]; )
            r11.push(s2()), d2(), "," === e10[a2] && a2++;
        } catch (e11) {
          if (rd.ARR & t10)
            return r11;
          n2("Expected ']' at end of array");
        }
        return a2++, r11;
      }, c2 = () => {
        if (0 === a2) {
          "-" === e10 && rd.NUM & t10 && n2("Not sure what '-' is");
          try {
            return JSON.parse(e10);
          } catch (r11) {
            if (rd.NUM & t10)
              try {
                if ("." === e10[e10.length - 1])
                  return JSON.parse(e10.substring(0, e10.lastIndexOf(".")));
                return JSON.parse(e10.substring(0, e10.lastIndexOf("e")));
              } catch (e11) {
              }
            i2(String(r11));
          }
        }
        let s3 = a2;
        for ("-" === e10[a2] && a2++; e10[a2] && !",]}".includes(e10[a2]); )
          a2++;
        a2 != r10 || rd.NUM & t10 || n2("Unterminated number literal");
        try {
          return JSON.parse(e10.substring(s3, a2));
        } catch (r11) {
          "-" === e10.substring(s3, a2) && rd.NUM & t10 && n2("Not sure what '-' is");
          try {
            return JSON.parse(e10.substring(s3, e10.lastIndexOf("e")));
          } catch (e11) {
            i2(String(e11));
          }
        }
      }, d2 = () => {
        for (; a2 < r10 && " \n\r	".includes(e10[a2]); )
          a2++;
      };
      return s2();
    }, rm = (e10) => function(e11, t10 = rd.ALL) {
      if ("string" != typeof e11)
        throw TypeError(`expecting str, got ${typeof e11}`);
      if (!e11.trim())
        throw Error(`${e11} is empty`);
      return rf(e11.trim(), t10);
    }(e10, rd.ALL ^ rd.NUM);
    var rg = function(e10, t10, r10, a2, n2) {
      if ("m" === a2)
        throw TypeError("Private method is not writable");
      if ("a" === a2 && !n2)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof t10 ? e10 !== t10 || !n2 : !t10.has(e10))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === a2 ? n2.call(e10, r10) : n2 ? n2.value = r10 : t10.set(e10, r10), r10;
    }, ry = function(e10, t10, r10, a2) {
      if ("a" === r10 && !a2)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t10 ? e10 !== t10 || !a2 : !t10.has(e10))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === r10 ? a2 : "a" === r10 ? a2.call(e10) : a2 ? a2.value : t10.get(e10);
    };
    class rb extends ru {
      constructor(e10) {
        super(), ep.add(this), ef.set(this, void 0), em.set(this, void 0), eg.set(this, void 0), rg(this, ef, e10, "f"), rg(this, em, [], "f");
      }
      get currentChatCompletionSnapshot() {
        return ry(this, eg, "f");
      }
      static fromReadableStream(e10) {
        let t10 = new rb(null);
        return t10._run(() => t10._fromReadableStream(e10)), t10;
      }
      static createChatCompletion(e10, t10, r10) {
        let a2 = new rb(t10);
        return a2._run(() => a2._runChatCompletion(e10, { ...t10, stream: true }, { ...r10, headers: { ...r10?.headers, "X-Stainless-Helper-Method": "stream" } })), a2;
      }
      async _createChatCompletion(e10, t10, r10) {
        super._createChatCompletion;
        let a2 = r10?.signal;
        a2 && (a2.aborted && this.controller.abort(), a2.addEventListener("abort", () => this.controller.abort())), ry(this, ep, "m", ey).call(this);
        let n2 = await e10.chat.completions.create({ ...t10, stream: true }, { ...r10, signal: this.controller.signal });
        for await (let e11 of (this._connected(), n2))
          ry(this, ep, "m", ev).call(this, e11);
        if (n2.controller.signal?.aborted)
          throw new R();
        return this._addChatCompletion(ry(this, ep, "m", eE).call(this));
      }
      async _fromReadableStream(e10, t10) {
        let r10;
        let a2 = t10?.signal;
        a2 && (a2.aborted && this.controller.abort(), a2.addEventListener("abort", () => this.controller.abort())), ry(this, ep, "m", ey).call(this), this._connected();
        let n2 = eJ.fromReadableStream(e10, this.controller);
        for await (let e11 of n2)
          r10 && r10 !== e11.id && this._addChatCompletion(ry(this, ep, "m", eE).call(this)), ry(this, ep, "m", ev).call(this, e11), r10 = e11.id;
        if (n2.controller.signal?.aborted)
          throw new R();
        return this._addChatCompletion(ry(this, ep, "m", eE).call(this));
      }
      [(ef = /* @__PURE__ */ new WeakMap(), em = /* @__PURE__ */ new WeakMap(), eg = /* @__PURE__ */ new WeakMap(), ep = /* @__PURE__ */ new WeakSet(), ey = function() {
        this.ended || rg(this, eg, void 0, "f");
      }, eb = function(e10) {
        let t10 = ry(this, em, "f")[e10.index];
        return t10 || (t10 = { content_done: false, refusal_done: false, logprobs_content_done: false, logprobs_refusal_done: false, done_tool_calls: /* @__PURE__ */ new Set(), current_tool_call_index: null }, ry(this, em, "f")[e10.index] = t10), t10;
      }, ev = function(e10) {
        if (this.ended)
          return;
        let t10 = ry(this, ep, "m", eO).call(this, e10);
        for (let r10 of (this._emit("chunk", e10, t10), e10.choices)) {
          let e11 = t10.choices[r10.index];
          null != r10.delta.content && e11.message?.role === "assistant" && e11.message?.content && (this._emit("content", r10.delta.content, e11.message.content), this._emit("content.delta", { delta: r10.delta.content, snapshot: e11.message.content, parsed: e11.message.parsed })), null != r10.delta.refusal && e11.message?.role === "assistant" && e11.message?.refusal && this._emit("refusal.delta", { delta: r10.delta.refusal, snapshot: e11.message.refusal }), r10.logprobs?.content != null && e11.message?.role === "assistant" && this._emit("logprobs.content.delta", { content: r10.logprobs?.content, snapshot: e11.logprobs?.content ?? [] }), r10.logprobs?.refusal != null && e11.message?.role === "assistant" && this._emit("logprobs.refusal.delta", { refusal: r10.logprobs?.refusal, snapshot: e11.logprobs?.refusal ?? [] });
          let a2 = ry(this, ep, "m", eb).call(this, e11);
          for (let t11 of (e11.finish_reason && (ry(this, ep, "m", ew).call(this, e11), null != a2.current_tool_call_index && ry(this, ep, "m", e_).call(this, e11, a2.current_tool_call_index)), r10.delta.tool_calls ?? []))
            a2.current_tool_call_index !== t11.index && (ry(this, ep, "m", ew).call(this, e11), null != a2.current_tool_call_index && ry(this, ep, "m", e_).call(this, e11, a2.current_tool_call_index)), a2.current_tool_call_index = t11.index;
          for (let t11 of r10.delta.tool_calls ?? []) {
            let r11 = e11.message.tool_calls?.[t11.index];
            r11?.type && (r11?.type === "function" ? this._emit("tool_calls.function.arguments.delta", { name: r11.function?.name, index: t11.index, arguments: r11.function.arguments, parsed_arguments: r11.function.parsed_arguments, arguments_delta: t11.function?.arguments ?? "" }) : r11?.type);
          }
        }
      }, e_ = function(e10, t10) {
        if (ry(this, ep, "m", eb).call(this, e10).done_tool_calls.has(t10))
          return;
        let r10 = e10.message.tool_calls?.[t10];
        if (!r10)
          throw Error("no tool call snapshot");
        if (!r10.type)
          throw Error("tool call snapshot missing `type`");
        if ("function" === r10.type) {
          let e11 = ry(this, ef, "f")?.tools?.find((e12) => "function" === e12.type && e12.function.name === r10.function.name);
          this._emit("tool_calls.function.arguments.done", { name: r10.function.name, index: t10, arguments: r10.function.arguments, parsed_arguments: ri(e11) ? e11.$parseRaw(r10.function.arguments) : e11?.function.strict ? JSON.parse(r10.function.arguments) : null });
        } else
          r10.type;
      }, ew = function(e10) {
        let t10 = ry(this, ep, "m", eb).call(this, e10);
        if (e10.message.content && !t10.content_done) {
          t10.content_done = true;
          let r10 = ry(this, ep, "m", ex).call(this);
          this._emit("content.done", { content: e10.message.content, parsed: r10 ? r10.$parseRaw(e10.message.content) : null });
        }
        e10.message.refusal && !t10.refusal_done && (t10.refusal_done = true, this._emit("refusal.done", { refusal: e10.message.refusal })), e10.logprobs?.content && !t10.logprobs_content_done && (t10.logprobs_content_done = true, this._emit("logprobs.content.done", { content: e10.logprobs.content })), e10.logprobs?.refusal && !t10.logprobs_refusal_done && (t10.logprobs_refusal_done = true, this._emit("logprobs.refusal.done", { refusal: e10.logprobs.refusal }));
      }, eE = function() {
        if (this.ended)
          throw new C("stream has ended, this shouldn't happen");
        let e10 = ry(this, eg, "f");
        if (!e10)
          throw new C("request ended without sending any chunks");
        return rg(this, eg, void 0, "f"), rg(this, em, [], "f"), function(e11, t10) {
          var r10;
          let { id: a2, choices: n2, created: i2, model: s2, system_fingerprint: o2, ...l2 } = e11;
          return r10 = { ...l2, id: a2, choices: n2.map(({ message: t11, finish_reason: r11, index: a3, logprobs: n3, ...i3 }) => {
            if (!r11)
              throw new C(`missing finish_reason for choice ${a3}`);
            let { content: s3 = null, function_call: o3, tool_calls: l3, ...u2 } = t11, c2 = t11.role;
            if (!c2)
              throw new C(`missing role for choice ${a3}`);
            if (o3) {
              let { arguments: e12, name: l4 } = o3;
              if (null == e12)
                throw new C(`missing function_call.arguments for choice ${a3}`);
              if (!l4)
                throw new C(`missing function_call.name for choice ${a3}`);
              return { ...i3, message: { content: s3, function_call: { arguments: e12, name: l4 }, role: c2, refusal: t11.refusal ?? null }, finish_reason: r11, index: a3, logprobs: n3 };
            }
            return l3 ? { ...i3, index: a3, finish_reason: r11, logprobs: n3, message: { ...u2, role: c2, content: s3, refusal: t11.refusal ?? null, tool_calls: l3.map((t12, r12) => {
              let { function: n4, type: i4, id: s4, ...o4 } = t12, { arguments: l4, name: u3, ...c3 } = n4 || {};
              if (null == s4)
                throw new C(`missing choices[${a3}].tool_calls[${r12}].id
${rv(e11)}`);
              if (null == i4)
                throw new C(`missing choices[${a3}].tool_calls[${r12}].type
${rv(e11)}`);
              if (null == u3)
                throw new C(`missing choices[${a3}].tool_calls[${r12}].function.name
${rv(e11)}`);
              if (null == l4)
                throw new C(`missing choices[${a3}].tool_calls[${r12}].function.arguments
${rv(e11)}`);
              return { ...o4, id: s4, type: i4, function: { ...c3, name: u3, arguments: l4 } };
            }) } } : { ...i3, message: { ...u2, content: s3, role: c2, refusal: t11.refusal ?? null }, finish_reason: r11, index: a3, logprobs: n3 };
          }), created: i2, model: s2, object: "chat.completion", ...o2 ? { system_fingerprint: o2 } : {} }, t10 && ro(t10) ? rs(r10, t10) : { ...r10, choices: r10.choices.map((e12) => ({ ...e12, message: { ...e12.message, parsed: null, tool_calls: e12.message.tool_calls ?? [] } })) };
        }(e10, ry(this, ef, "f"));
      }, ex = function() {
        let e10 = ry(this, ef, "f")?.response_format;
        return rn(e10) ? e10 : null;
      }, eO = function(e10) {
        var t10, r10, a2, n2;
        let i2 = ry(this, eg, "f"), { choices: s2, ...o2 } = e10;
        for (let { delta: s3, finish_reason: l2, index: u2, logprobs: c2 = null, ...d2 } of (i2 ? Object.assign(i2, o2) : i2 = rg(this, eg, { ...o2, choices: [] }, "f"), e10.choices)) {
          let e11 = i2.choices[u2];
          if (e11 || (e11 = i2.choices[u2] = { finish_reason: l2, index: u2, message: {}, logprobs: c2, ...d2 }), c2) {
            if (e11.logprobs) {
              let { content: a3, refusal: n3, ...i3 } = c2;
              Object.assign(e11.logprobs, i3), a3 && ((t10 = e11.logprobs).content ?? (t10.content = []), e11.logprobs.content.push(...a3)), n3 && ((r10 = e11.logprobs).refusal ?? (r10.refusal = []), e11.logprobs.refusal.push(...n3));
            } else
              e11.logprobs = Object.assign({}, c2);
          }
          if (l2 && (e11.finish_reason = l2, ry(this, ef, "f") && ro(ry(this, ef, "f")))) {
            if ("length" === l2)
              throw new q();
            if ("content_filter" === l2)
              throw new H();
          }
          if (Object.assign(e11, d2), !s3)
            continue;
          let { content: o3, refusal: h2, function_call: p2, role: f2, tool_calls: m2, ...g2 } = s3;
          if (Object.assign(e11.message, g2), h2 && (e11.message.refusal = (e11.message.refusal || "") + h2), f2 && (e11.message.role = f2), p2 && (e11.message.function_call ? (p2.name && (e11.message.function_call.name = p2.name), p2.arguments && ((a2 = e11.message.function_call).arguments ?? (a2.arguments = ""), e11.message.function_call.arguments += p2.arguments)) : e11.message.function_call = p2), o3 && (e11.message.content = (e11.message.content || "") + o3, !e11.message.refusal && ry(this, ep, "m", ex).call(this) && (e11.message.parsed = rm(e11.message.content))), m2)
            for (let { index: t11, id: r11, type: a3, function: i3, ...s4 } of (e11.message.tool_calls || (e11.message.tool_calls = []), m2)) {
              let o4 = (n2 = e11.message.tool_calls)[t11] ?? (n2[t11] = {});
              Object.assign(o4, s4), r11 && (o4.id = r11), a3 && (o4.type = a3), i3 && (o4.function ?? (o4.function = { name: i3.name ?? "", arguments: "" })), i3?.name && (o4.function.name = i3.name), i3?.arguments && (o4.function.arguments += i3.arguments, function(e12, t12) {
                if (!e12)
                  return false;
                let r12 = e12.tools?.find((e13) => e13.function?.name === t12.function.name);
                return ri(r12) || r12?.function.strict || false;
              }(ry(this, ef, "f"), o4) && (o4.function.parsed_arguments = rm(o4.function.arguments)));
            }
        }
        return i2;
      }, Symbol.asyncIterator)]() {
        let e10 = [], t10 = [], r10 = false;
        return this.on("chunk", (r11) => {
          let a2 = t10.shift();
          a2 ? a2.resolve(r11) : e10.push(r11);
        }), this.on("end", () => {
          for (let e11 of (r10 = true, t10))
            e11.resolve(void 0);
          t10.length = 0;
        }), this.on("abort", (e11) => {
          for (let a2 of (r10 = true, t10))
            a2.reject(e11);
          t10.length = 0;
        }), this.on("error", (e11) => {
          for (let a2 of (r10 = true, t10))
            a2.reject(e11);
          t10.length = 0;
        }), { next: async () => e10.length ? { value: e10.shift(), done: false } : r10 ? { value: void 0, done: true } : new Promise((e11, r11) => t10.push({ resolve: e11, reject: r11 })).then((e11) => e11 ? { value: e11, done: false } : { value: void 0, done: true }), return: async () => (this.abort(), { value: void 0, done: true }) };
      }
      toReadableStream() {
        return new eJ(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
      }
    }
    function rv(e10) {
      return JSON.stringify(e10);
    }
    class r_ extends rb {
      static fromReadableStream(e10) {
        let t10 = new r_(null);
        return t10._run(() => t10._fromReadableStream(e10)), t10;
      }
      static runFunctions(e10, t10, r10) {
        let a2 = new r_(null), n2 = { ...r10, headers: { ...r10?.headers, "X-Stainless-Helper-Method": "runFunctions" } };
        return a2._run(() => a2._runFunctions(e10, t10, n2)), a2;
      }
      static runTools(e10, t10, r10) {
        let a2 = new r_(t10), n2 = { ...r10, headers: { ...r10?.headers, "X-Stainless-Helper-Method": "runTools" } };
        return a2._run(() => a2._runTools(e10, t10, n2)), a2;
      }
    }
    class rw extends tL {
      parse(e10, t10) {
        return !function(e11) {
          for (let t11 of e11 ?? []) {
            if ("function" !== t11.type)
              throw new C(`Currently only \`function\` tool types support auto-parsing; Received \`${t11.type}\``);
            if (true !== t11.function.strict)
              throw new C(`The \`${t11.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
          }
        }(e10.tools), this._client.chat.completions.create(e10, { ...t10, headers: { ...t10?.headers, "X-Stainless-Helper-Method": "beta.chat.completions.parse" } })._thenUnwrap((t11) => rs(t11, e10));
      }
      runFunctions(e10, t10) {
        return e10.stream ? r_.runFunctions(this._client, e10, t10) : rc.runFunctions(this._client, e10, t10);
      }
      runTools(e10, t10) {
        return e10.stream ? r_.runTools(this._client, e10, t10) : rc.runTools(this._client, e10, t10);
      }
      stream(e10, t10) {
        return rb.createChatCompletion(this._client, e10, t10);
      }
    }
    class rE extends tL {
      constructor() {
        super(...arguments), this.completions = new rw(this._client);
      }
    }
    (rE || (rE = {})).Completions = rw;
    var rx = function(e10, t10, r10, a2) {
      if ("a" === r10 && !a2)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t10 ? e10 !== t10 || !a2 : !t10.has(e10))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === r10 ? a2 : "a" === r10 ? a2.call(e10) : a2 ? a2.value : t10.get(e10);
    }, rO = function(e10, t10, r10, a2, n2) {
      if ("m" === a2)
        throw TypeError("Private method is not writable");
      if ("a" === a2 && !n2)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof t10 ? e10 !== t10 || !n2 : !t10.has(e10))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === a2 ? n2.call(e10, r10) : n2 ? n2.value = r10 : t10.set(e10, r10), r10;
    };
    class rS extends ra {
      constructor() {
        super(...arguments), eS.add(this), eA.set(this, []), ek.set(this, {}), eT.set(this, {}), eP.set(this, void 0), eC.set(this, void 0), eI.set(this, void 0), eR.set(this, void 0), eN.set(this, void 0), e$.set(this, void 0), ej.set(this, void 0), eL.set(this, void 0), eM.set(this, void 0);
      }
      [(eA = /* @__PURE__ */ new WeakMap(), ek = /* @__PURE__ */ new WeakMap(), eT = /* @__PURE__ */ new WeakMap(), eP = /* @__PURE__ */ new WeakMap(), eC = /* @__PURE__ */ new WeakMap(), eI = /* @__PURE__ */ new WeakMap(), eR = /* @__PURE__ */ new WeakMap(), eN = /* @__PURE__ */ new WeakMap(), e$ = /* @__PURE__ */ new WeakMap(), ej = /* @__PURE__ */ new WeakMap(), eL = /* @__PURE__ */ new WeakMap(), eM = /* @__PURE__ */ new WeakMap(), eS = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
        let e10 = [], t10 = [], r10 = false;
        return this.on("event", (r11) => {
          let a2 = t10.shift();
          a2 ? a2.resolve(r11) : e10.push(r11);
        }), this.on("end", () => {
          for (let e11 of (r10 = true, t10))
            e11.resolve(void 0);
          t10.length = 0;
        }), this.on("abort", (e11) => {
          for (let a2 of (r10 = true, t10))
            a2.reject(e11);
          t10.length = 0;
        }), this.on("error", (e11) => {
          for (let a2 of (r10 = true, t10))
            a2.reject(e11);
          t10.length = 0;
        }), { next: async () => e10.length ? { value: e10.shift(), done: false } : r10 ? { value: void 0, done: true } : new Promise((e11, r11) => t10.push({ resolve: e11, reject: r11 })).then((e11) => e11 ? { value: e11, done: false } : { value: void 0, done: true }), return: async () => (this.abort(), { value: void 0, done: true }) };
      }
      static fromReadableStream(e10) {
        let t10 = new rS();
        return t10._run(() => t10._fromReadableStream(e10)), t10;
      }
      async _fromReadableStream(e10, t10) {
        let r10 = t10?.signal;
        r10 && (r10.aborted && this.controller.abort(), r10.addEventListener("abort", () => this.controller.abort())), this._connected();
        let a2 = eJ.fromReadableStream(e10, this.controller);
        for await (let e11 of a2)
          rx(this, eS, "m", eD).call(this, e11);
        if (a2.controller.signal?.aborted)
          throw new R();
        return this._addRun(rx(this, eS, "m", eU).call(this));
      }
      toReadableStream() {
        return new eJ(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
      }
      static createToolAssistantStream(e10, t10, r10, a2, n2) {
        let i2 = new rS();
        return i2._run(() => i2._runToolAssistantStream(e10, t10, r10, a2, { ...n2, headers: { ...n2?.headers, "X-Stainless-Helper-Method": "stream" } })), i2;
      }
      async _createToolAssistantStream(e10, t10, r10, a2, n2) {
        let i2 = n2?.signal;
        i2 && (i2.aborted && this.controller.abort(), i2.addEventListener("abort", () => this.controller.abort()));
        let s2 = { ...a2, stream: true }, o2 = await e10.submitToolOutputs(t10, r10, s2, { ...n2, signal: this.controller.signal });
        for await (let e11 of (this._connected(), o2))
          rx(this, eS, "m", eD).call(this, e11);
        if (o2.controller.signal?.aborted)
          throw new R();
        return this._addRun(rx(this, eS, "m", eU).call(this));
      }
      static createThreadAssistantStream(e10, t10, r10) {
        let a2 = new rS();
        return a2._run(() => a2._threadAssistantStream(e10, t10, { ...r10, headers: { ...r10?.headers, "X-Stainless-Helper-Method": "stream" } })), a2;
      }
      static createAssistantStream(e10, t10, r10, a2) {
        let n2 = new rS();
        return n2._run(() => n2._runAssistantStream(e10, t10, r10, { ...a2, headers: { ...a2?.headers, "X-Stainless-Helper-Method": "stream" } })), n2;
      }
      currentEvent() {
        return rx(this, ej, "f");
      }
      currentRun() {
        return rx(this, eL, "f");
      }
      currentMessageSnapshot() {
        return rx(this, eP, "f");
      }
      currentRunStepSnapshot() {
        return rx(this, eM, "f");
      }
      async finalRunSteps() {
        return await this.done(), Object.values(rx(this, ek, "f"));
      }
      async finalMessages() {
        return await this.done(), Object.values(rx(this, eT, "f"));
      }
      async finalRun() {
        if (await this.done(), !rx(this, eC, "f"))
          throw Error("Final run was not received.");
        return rx(this, eC, "f");
      }
      async _createThreadAssistantStream(e10, t10, r10) {
        let a2 = r10?.signal;
        a2 && (a2.aborted && this.controller.abort(), a2.addEventListener("abort", () => this.controller.abort()));
        let n2 = { ...t10, stream: true }, i2 = await e10.createAndRun(n2, { ...r10, signal: this.controller.signal });
        for await (let e11 of (this._connected(), i2))
          rx(this, eS, "m", eD).call(this, e11);
        if (i2.controller.signal?.aborted)
          throw new R();
        return this._addRun(rx(this, eS, "m", eU).call(this));
      }
      async _createAssistantStream(e10, t10, r10, a2) {
        let n2 = a2?.signal;
        n2 && (n2.aborted && this.controller.abort(), n2.addEventListener("abort", () => this.controller.abort()));
        let i2 = { ...r10, stream: true }, s2 = await e10.create(t10, i2, { ...a2, signal: this.controller.signal });
        for await (let e11 of (this._connected(), s2))
          rx(this, eS, "m", eD).call(this, e11);
        if (s2.controller.signal?.aborted)
          throw new R();
        return this._addRun(rx(this, eS, "m", eU).call(this));
      }
      static accumulateDelta(e10, t10) {
        for (let [r10, a2] of Object.entries(t10)) {
          if (!e10.hasOwnProperty(r10)) {
            e10[r10] = a2;
            continue;
          }
          let t11 = e10[r10];
          if (null == t11 || "index" === r10 || "type" === r10) {
            e10[r10] = a2;
            continue;
          }
          if ("string" == typeof t11 && "string" == typeof a2)
            t11 += a2;
          else if ("number" == typeof t11 && "number" == typeof a2)
            t11 += a2;
          else if (tj(t11) && tj(a2))
            t11 = this.accumulateDelta(t11, a2);
          else if (Array.isArray(t11) && Array.isArray(a2)) {
            if (t11.every((e11) => "string" == typeof e11 || "number" == typeof e11)) {
              t11.push(...a2);
              continue;
            }
            for (let e11 of a2) {
              if (!tj(e11))
                throw Error(`Expected array delta entry to be an object but got: ${e11}`);
              let r11 = e11.index;
              if (null == r11)
                throw console.error(e11), Error("Expected array delta entry to have an `index` property");
              if ("number" != typeof r11)
                throw Error(`Expected array delta entry \`index\` property to be a number but got ${r11}`);
              let a3 = t11[r11];
              null == a3 ? t11.push(e11) : t11[r11] = this.accumulateDelta(a3, e11);
            }
            continue;
          } else
            throw Error(`Unhandled record type: ${r10}, deltaValue: ${a2}, accValue: ${t11}`);
          e10[r10] = t11;
        }
        return e10;
      }
      _addRun(e10) {
        return e10;
      }
      async _threadAssistantStream(e10, t10, r10) {
        return await this._createThreadAssistantStream(t10, e10, r10);
      }
      async _runAssistantStream(e10, t10, r10, a2) {
        return await this._createAssistantStream(t10, e10, r10, a2);
      }
      async _runToolAssistantStream(e10, t10, r10, a2, n2) {
        return await this._createToolAssistantStream(r10, e10, t10, a2, n2);
      }
    }
    eD = function(e10) {
      if (!this.ended)
        switch (rO(this, ej, e10, "f"), rx(this, eS, "m", eB).call(this, e10), e10.event) {
          case "thread.created":
            break;
          case "thread.run.created":
          case "thread.run.queued":
          case "thread.run.in_progress":
          case "thread.run.requires_action":
          case "thread.run.completed":
          case "thread.run.failed":
          case "thread.run.cancelling":
          case "thread.run.cancelled":
          case "thread.run.expired":
            rx(this, eS, "m", eG).call(this, e10);
            break;
          case "thread.run.step.created":
          case "thread.run.step.in_progress":
          case "thread.run.step.delta":
          case "thread.run.step.completed":
          case "thread.run.step.failed":
          case "thread.run.step.cancelled":
          case "thread.run.step.expired":
            rx(this, eS, "m", ez).call(this, e10);
            break;
          case "thread.message.created":
          case "thread.message.in_progress":
          case "thread.message.delta":
          case "thread.message.completed":
          case "thread.message.incomplete":
            rx(this, eS, "m", eF).call(this, e10);
            break;
          case "error":
            throw Error("Encountered an error event in event processing - errors should be processed earlier");
        }
    }, eU = function() {
      if (this.ended)
        throw new C("stream has ended, this shouldn't happen");
      if (!rx(this, eC, "f"))
        throw Error("Final run has not been received");
      return rx(this, eC, "f");
    }, eF = function(e10) {
      let [t10, r10] = rx(this, eS, "m", eH).call(this, e10, rx(this, eP, "f"));
      for (let e11 of (rO(this, eP, t10, "f"), rx(this, eT, "f")[t10.id] = t10, r10)) {
        let r11 = t10.content[e11.index];
        r11?.type == "text" && this._emit("textCreated", r11.text);
      }
      switch (e10.event) {
        case "thread.message.created":
          this._emit("messageCreated", e10.data);
          break;
        case "thread.message.in_progress":
          break;
        case "thread.message.delta":
          if (this._emit("messageDelta", e10.data.delta, t10), e10.data.delta.content)
            for (let r11 of e10.data.delta.content) {
              if ("text" == r11.type && r11.text) {
                let e11 = r11.text, a2 = t10.content[r11.index];
                if (a2 && "text" == a2.type)
                  this._emit("textDelta", e11, a2.text);
                else
                  throw Error("The snapshot associated with this text delta is not text or missing");
              }
              if (r11.index != rx(this, eI, "f")) {
                if (rx(this, eR, "f"))
                  switch (rx(this, eR, "f").type) {
                    case "text":
                      this._emit("textDone", rx(this, eR, "f").text, rx(this, eP, "f"));
                      break;
                    case "image_file":
                      this._emit("imageFileDone", rx(this, eR, "f").image_file, rx(this, eP, "f"));
                  }
                rO(this, eI, r11.index, "f");
              }
              rO(this, eR, t10.content[r11.index], "f");
            }
          break;
        case "thread.message.completed":
        case "thread.message.incomplete":
          if (void 0 !== rx(this, eI, "f")) {
            let t11 = e10.data.content[rx(this, eI, "f")];
            if (t11)
              switch (t11.type) {
                case "image_file":
                  this._emit("imageFileDone", t11.image_file, rx(this, eP, "f"));
                  break;
                case "text":
                  this._emit("textDone", t11.text, rx(this, eP, "f"));
              }
          }
          rx(this, eP, "f") && this._emit("messageDone", e10.data), rO(this, eP, void 0, "f");
      }
    }, ez = function(e10) {
      let t10 = rx(this, eS, "m", eq).call(this, e10);
      switch (rO(this, eM, t10, "f"), e10.event) {
        case "thread.run.step.created":
          this._emit("runStepCreated", e10.data);
          break;
        case "thread.run.step.delta":
          let r10 = e10.data.delta;
          if (r10.step_details && "tool_calls" == r10.step_details.type && r10.step_details.tool_calls && "tool_calls" == t10.step_details.type)
            for (let e11 of r10.step_details.tool_calls)
              e11.index == rx(this, eN, "f") ? this._emit("toolCallDelta", e11, t10.step_details.tool_calls[e11.index]) : (rx(this, e$, "f") && this._emit("toolCallDone", rx(this, e$, "f")), rO(this, eN, e11.index, "f"), rO(this, e$, t10.step_details.tool_calls[e11.index], "f"), rx(this, e$, "f") && this._emit("toolCallCreated", rx(this, e$, "f")));
          this._emit("runStepDelta", e10.data.delta, t10);
          break;
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
          rO(this, eM, void 0, "f"), "tool_calls" == e10.data.step_details.type && rx(this, e$, "f") && (this._emit("toolCallDone", rx(this, e$, "f")), rO(this, e$, void 0, "f")), this._emit("runStepDone", e10.data, t10);
      }
    }, eB = function(e10) {
      rx(this, eA, "f").push(e10), this._emit("event", e10);
    }, eq = function(e10) {
      switch (e10.event) {
        case "thread.run.step.created":
          return rx(this, ek, "f")[e10.data.id] = e10.data, e10.data;
        case "thread.run.step.delta":
          let t10 = rx(this, ek, "f")[e10.data.id];
          if (!t10)
            throw Error("Received a RunStepDelta before creation of a snapshot");
          let r10 = e10.data;
          if (r10.delta) {
            let a2 = rS.accumulateDelta(t10, r10.delta);
            rx(this, ek, "f")[e10.data.id] = a2;
          }
          return rx(this, ek, "f")[e10.data.id];
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
        case "thread.run.step.in_progress":
          rx(this, ek, "f")[e10.data.id] = e10.data;
      }
      if (rx(this, ek, "f")[e10.data.id])
        return rx(this, ek, "f")[e10.data.id];
      throw Error("No snapshot available");
    }, eH = function(e10, t10) {
      let r10 = [];
      switch (e10.event) {
        case "thread.message.created":
          return [e10.data, r10];
        case "thread.message.delta":
          if (!t10)
            throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
          let a2 = e10.data;
          if (a2.delta.content)
            for (let e11 of a2.delta.content)
              if (e11.index in t10.content) {
                let r11 = t10.content[e11.index];
                t10.content[e11.index] = rx(this, eS, "m", eZ).call(this, e11, r11);
              } else
                t10.content[e11.index] = e11, r10.push(e11);
          return [t10, r10];
        case "thread.message.in_progress":
        case "thread.message.completed":
        case "thread.message.incomplete":
          if (t10)
            return [t10, r10];
          throw Error("Received thread message event with no existing snapshot");
      }
      throw Error("Tried to accumulate a non-message event");
    }, eZ = function(e10, t10) {
      return rS.accumulateDelta(t10, e10);
    }, eG = function(e10) {
      switch (rO(this, eL, e10.data, "f"), e10.event) {
        case "thread.run.created":
        case "thread.run.queued":
        case "thread.run.in_progress":
          break;
        case "thread.run.requires_action":
        case "thread.run.cancelled":
        case "thread.run.failed":
        case "thread.run.completed":
        case "thread.run.expired":
          rO(this, eC, e10.data, "f"), rx(this, e$, "f") && (this._emit("toolCallDone", rx(this, e$, "f")), rO(this, e$, void 0, "f"));
      }
    };
    class rA extends tL {
      create(e10, t10, r10) {
        return this._client.post(`/threads/${e10}/messages`, { body: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      retrieve(e10, t10, r10) {
        return this._client.get(`/threads/${e10}/messages/${t10}`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      update(e10, t10, r10, a2) {
        return this._client.post(`/threads/${e10}/messages/${t10}`, { body: r10, ...a2, headers: { "OpenAI-Beta": "assistants=v2", ...a2?.headers } });
      }
      list(e10, t10 = {}, r10) {
        return tm(t10) ? this.list(e10, {}, t10) : this._client.getAPIList(`/threads/${e10}/messages`, rk, { query: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      del(e10, t10, r10) {
        return this._client.delete(`/threads/${e10}/messages/${t10}`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
    }
    class rk extends tB {
    }
    rA.MessagesPage = rk;
    class rT extends tL {
      retrieve(e10, t10, r10, a2 = {}, n2) {
        return tm(a2) ? this.retrieve(e10, t10, r10, {}, a2) : this._client.get(`/threads/${e10}/runs/${t10}/steps/${r10}`, { query: a2, ...n2, headers: { "OpenAI-Beta": "assistants=v2", ...n2?.headers } });
      }
      list(e10, t10, r10 = {}, a2) {
        return tm(r10) ? this.list(e10, t10, {}, r10) : this._client.getAPIList(`/threads/${e10}/runs/${t10}/steps`, rP, { query: r10, ...a2, headers: { "OpenAI-Beta": "assistants=v2", ...a2?.headers } });
      }
    }
    class rP extends tB {
    }
    rT.RunStepsPage = rP;
    class rC extends tL {
      constructor() {
        super(...arguments), this.steps = new rT(this._client);
      }
      create(e10, t10, r10) {
        let { include: a2, ...n2 } = t10;
        return this._client.post(`/threads/${e10}/runs`, { query: { include: a2 }, body: n2, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers }, stream: t10.stream ?? false });
      }
      retrieve(e10, t10, r10) {
        return this._client.get(`/threads/${e10}/runs/${t10}`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      update(e10, t10, r10, a2) {
        return this._client.post(`/threads/${e10}/runs/${t10}`, { body: r10, ...a2, headers: { "OpenAI-Beta": "assistants=v2", ...a2?.headers } });
      }
      list(e10, t10 = {}, r10) {
        return tm(t10) ? this.list(e10, {}, t10) : this._client.getAPIList(`/threads/${e10}/runs`, rI, { query: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      cancel(e10, t10, r10) {
        return this._client.post(`/threads/${e10}/runs/${t10}/cancel`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      async createAndPoll(e10, t10, r10) {
        let a2 = await this.create(e10, t10, r10);
        return await this.poll(e10, a2.id, r10);
      }
      createAndStream(e10, t10, r10) {
        return rS.createAssistantStream(e10, this._client.beta.threads.runs, t10, r10);
      }
      async poll(e10, t10, r10) {
        let a2 = { ...r10?.headers, "X-Stainless-Poll-Helper": "true" };
        for (r10?.pollIntervalMs && (a2["X-Stainless-Custom-Poll-Interval"] = r10.pollIntervalMs.toString()); ; ) {
          let { data: n2, response: i2 } = await this.retrieve(e10, t10, { ...r10, headers: { ...r10?.headers, ...a2 } }).withResponse();
          switch (n2.status) {
            case "queued":
            case "in_progress":
            case "cancelling":
              let s2 = 5e3;
              if (r10?.pollIntervalMs)
                s2 = r10.pollIntervalMs;
              else {
                let e11 = i2.headers.get("openai-poll-after-ms");
                if (e11) {
                  let t11 = parseInt(e11);
                  isNaN(t11) || (s2 = t11);
                }
              }
              await tx(s2);
              break;
            case "requires_action":
            case "incomplete":
            case "cancelled":
            case "completed":
            case "failed":
            case "expired":
              return n2;
          }
        }
      }
      stream(e10, t10, r10) {
        return rS.createAssistantStream(e10, this._client.beta.threads.runs, t10, r10);
      }
      submitToolOutputs(e10, t10, r10, a2) {
        return this._client.post(`/threads/${e10}/runs/${t10}/submit_tool_outputs`, { body: r10, ...a2, headers: { "OpenAI-Beta": "assistants=v2", ...a2?.headers }, stream: r10.stream ?? false });
      }
      async submitToolOutputsAndPoll(e10, t10, r10, a2) {
        let n2 = await this.submitToolOutputs(e10, t10, r10, a2);
        return await this.poll(e10, n2.id, a2);
      }
      submitToolOutputsStream(e10, t10, r10, a2) {
        return rS.createToolAssistantStream(e10, t10, this._client.beta.threads.runs, r10, a2);
      }
    }
    class rI extends tB {
    }
    rC.RunsPage = rI, rC.Steps = rT, rC.RunStepsPage = rP;
    class rR extends tL {
      constructor() {
        super(...arguments), this.runs = new rC(this._client), this.messages = new rA(this._client);
      }
      create(e10 = {}, t10) {
        return tm(e10) ? this.create({}, e10) : this._client.post("/threads", { body: e10, ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      retrieve(e10, t10) {
        return this._client.get(`/threads/${e10}`, { ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      update(e10, t10, r10) {
        return this._client.post(`/threads/${e10}`, { body: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      del(e10, t10) {
        return this._client.delete(`/threads/${e10}`, { ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      createAndRun(e10, t10) {
        return this._client.post("/threads/runs", { body: e10, ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers }, stream: e10.stream ?? false });
      }
      async createAndRunPoll(e10, t10) {
        let r10 = await this.createAndRun(e10, t10);
        return await this.runs.poll(r10.thread_id, r10.id, t10);
      }
      createAndRunStream(e10, t10) {
        return rS.createThreadAssistantStream(e10, this._client.beta.threads, t10);
      }
    }
    rR.Runs = rC, rR.RunsPage = rI, rR.Messages = rA, rR.MessagesPage = rk;
    let rN = async (e10) => {
      let t10 = await Promise.allSettled(e10), r10 = t10.filter((e11) => "rejected" === e11.status);
      if (r10.length) {
        for (let e11 of r10)
          console.error(e11.reason);
        throw Error(`${r10.length} promise(s) failed - see the above errors`);
      }
      let a2 = [];
      for (let e11 of t10)
        "fulfilled" === e11.status && a2.push(e11.value);
      return a2;
    };
    class r$ extends tL {
      create(e10, t10, r10) {
        return this._client.post(`/vector_stores/${e10}/files`, { body: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      retrieve(e10, t10, r10) {
        return this._client.get(`/vector_stores/${e10}/files/${t10}`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      list(e10, t10 = {}, r10) {
        return tm(t10) ? this.list(e10, {}, t10) : this._client.getAPIList(`/vector_stores/${e10}/files`, rj, { query: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      del(e10, t10, r10) {
        return this._client.delete(`/vector_stores/${e10}/files/${t10}`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      async createAndPoll(e10, t10, r10) {
        let a2 = await this.create(e10, t10, r10);
        return await this.poll(e10, a2.id, r10);
      }
      async poll(e10, t10, r10) {
        let a2 = { ...r10?.headers, "X-Stainless-Poll-Helper": "true" };
        for (r10?.pollIntervalMs && (a2["X-Stainless-Custom-Poll-Interval"] = r10.pollIntervalMs.toString()); ; ) {
          let n2 = await this.retrieve(e10, t10, { ...r10, headers: a2 }).withResponse(), i2 = n2.data;
          switch (i2.status) {
            case "in_progress":
              let s2 = 5e3;
              if (r10?.pollIntervalMs)
                s2 = r10.pollIntervalMs;
              else {
                let e11 = n2.response.headers.get("openai-poll-after-ms");
                if (e11) {
                  let t11 = parseInt(e11);
                  isNaN(t11) || (s2 = t11);
                }
              }
              await tx(s2);
              break;
            case "failed":
            case "completed":
              return i2;
          }
        }
      }
      async upload(e10, t10, r10) {
        let a2 = await this._client.files.create({ file: t10, purpose: "assistants" }, r10);
        return this.create(e10, { file_id: a2.id }, r10);
      }
      async uploadAndPoll(e10, t10, r10) {
        let a2 = await this.upload(e10, t10, r10);
        return await this.poll(e10, a2.id, r10);
      }
    }
    class rj extends tB {
    }
    r$.VectorStoreFilesPage = rj;
    class rL extends tL {
      create(e10, t10, r10) {
        return this._client.post(`/vector_stores/${e10}/file_batches`, { body: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      retrieve(e10, t10, r10) {
        return this._client.get(`/vector_stores/${e10}/file_batches/${t10}`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      cancel(e10, t10, r10) {
        return this._client.post(`/vector_stores/${e10}/file_batches/${t10}/cancel`, { ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      async createAndPoll(e10, t10, r10) {
        let a2 = await this.create(e10, t10);
        return await this.poll(e10, a2.id, r10);
      }
      listFiles(e10, t10, r10 = {}, a2) {
        return tm(r10) ? this.listFiles(e10, t10, {}, r10) : this._client.getAPIList(`/vector_stores/${e10}/file_batches/${t10}/files`, rj, { query: r10, ...a2, headers: { "OpenAI-Beta": "assistants=v2", ...a2?.headers } });
      }
      async poll(e10, t10, r10) {
        let a2 = { ...r10?.headers, "X-Stainless-Poll-Helper": "true" };
        for (r10?.pollIntervalMs && (a2["X-Stainless-Custom-Poll-Interval"] = r10.pollIntervalMs.toString()); ; ) {
          let { data: n2, response: i2 } = await this.retrieve(e10, t10, { ...r10, headers: a2 }).withResponse();
          switch (n2.status) {
            case "in_progress":
              let s2 = 5e3;
              if (r10?.pollIntervalMs)
                s2 = r10.pollIntervalMs;
              else {
                let e11 = i2.headers.get("openai-poll-after-ms");
                if (e11) {
                  let t11 = parseInt(e11);
                  isNaN(t11) || (s2 = t11);
                }
              }
              await tx(s2);
              break;
            case "failed":
            case "cancelled":
            case "completed":
              return n2;
          }
        }
      }
      async uploadAndPoll(e10, { files: t10, fileIds: r10 = [] }, a2) {
        if (null == t10 || 0 == t10.length)
          throw Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
        let n2 = Math.min(a2?.maxConcurrency ?? 5, t10.length), i2 = this._client, s2 = t10.values(), o2 = [...r10];
        async function l2(e11) {
          for (let t11 of e11) {
            let e12 = await i2.files.create({ file: t11, purpose: "assistants" }, a2);
            o2.push(e12.id);
          }
        }
        let u2 = Array(n2).fill(s2).map(l2);
        return await rN(u2), await this.createAndPoll(e10, { file_ids: o2 });
      }
    }
    class rM extends tL {
      constructor() {
        super(...arguments), this.files = new r$(this._client), this.fileBatches = new rL(this._client);
      }
      create(e10, t10) {
        return this._client.post("/vector_stores", { body: e10, ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      retrieve(e10, t10) {
        return this._client.get(`/vector_stores/${e10}`, { ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      update(e10, t10, r10) {
        return this._client.post(`/vector_stores/${e10}`, { body: t10, ...r10, headers: { "OpenAI-Beta": "assistants=v2", ...r10?.headers } });
      }
      list(e10 = {}, t10) {
        return tm(e10) ? this.list({}, e10) : this._client.getAPIList("/vector_stores", rD, { query: e10, ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
      del(e10, t10) {
        return this._client.delete(`/vector_stores/${e10}`, { ...t10, headers: { "OpenAI-Beta": "assistants=v2", ...t10?.headers } });
      }
    }
    class rD extends tB {
    }
    rM.VectorStoresPage = rD, rM.Files = r$, rM.VectorStoreFilesPage = rj, rM.FileBatches = rL;
    class rU extends tL {
      constructor() {
        super(...arguments), this.vectorStores = new rM(this._client), this.chat = new rE(this._client), this.assistants = new t3(this._client), this.threads = new rR(this._client);
      }
    }
    rU.VectorStores = rM, rU.VectorStoresPage = rD, rU.Assistants = t3, rU.AssistantsPage = t5, rU.Threads = rR;
    class rF extends tL {
      create(e10, t10) {
        return this._client.post("/batches", { body: e10, ...t10 });
      }
      retrieve(e10, t10) {
        return this._client.get(`/batches/${e10}`, t10);
      }
      list(e10 = {}, t10) {
        return tm(e10) ? this.list({}, e10) : this._client.getAPIList("/batches", rz, { query: e10, ...t10 });
      }
      cancel(e10, t10) {
        return this._client.post(`/batches/${e10}/cancel`, t10);
      }
    }
    class rz extends tB {
    }
    rF.BatchesPage = rz;
    class rB extends tL {
      create(e10, t10, r10) {
        return this._client.post(`/uploads/${e10}/parts`, te({ body: t10, ...r10 }));
      }
    }
    class rq extends tL {
      constructor() {
        super(...arguments), this.parts = new rB(this._client);
      }
      create(e10, t10) {
        return this._client.post("/uploads", { body: e10, ...t10 });
      }
      cancel(e10, t10) {
        return this._client.post(`/uploads/${e10}/cancel`, t10);
      }
      complete(e10, t10, r10) {
        return this._client.post(`/uploads/${e10}/complete`, { body: t10, ...r10 });
      }
    }
    rq.Parts = rB;
    class rH extends tc {
      constructor({ baseURL: e10 = tA("OPENAI_BASE_URL"), apiKey: t10 = tA("OPENAI_API_KEY"), organization: r10 = tA("OPENAI_ORG_ID") ?? null, project: a2 = tA("OPENAI_PROJECT_ID") ?? null, ...n2 } = {}) {
        if (void 0 === t10)
          throw new C("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
        let i2 = { apiKey: t10, organization: r10, project: a2, ...n2, baseURL: e10 || "https://api.openai.com/v1" };
        if (!i2.dangerouslyAllowBrowser && tR())
          throw new C("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
        super({ baseURL: i2.baseURL, timeout: i2.timeout ?? 6e5, httpAgent: i2.httpAgent, maxRetries: i2.maxRetries, fetch: i2.fetch }), this.completions = new tM(this), this.chat = new tU(this), this.embeddings = new tF(this), this.files = new tq(this), this.images = new tZ(this), this.audio = new tJ(this), this.moderations = new tK(this), this.models = new tX(this), this.fineTuning = new t9(this), this.beta = new rU(this), this.batches = new rF(this), this.uploads = new rq(this), this._options = i2, this.apiKey = t10, this.organization = r10, this.project = a2;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      defaultHeaders(e10) {
        return { ...super.defaultHeaders(e10), "OpenAI-Organization": this.organization, "OpenAI-Project": this.project, ...this._options.defaultHeaders };
      }
      authHeaders(e10) {
        return { Authorization: `Bearer ${this.apiKey}` };
      }
      stringifyQuery(e10) {
        return function(e11, t10 = {}) {
          let r10, a2 = e11, n2 = function(e12 = S) {
            let t11;
            if (void 0 !== e12.allowEmptyArrays && "boolean" != typeof e12.allowEmptyArrays)
              throw TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
            if (void 0 !== e12.encodeDotInKeys && "boolean" != typeof e12.encodeDotInKeys)
              throw TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
            if (null !== e12.encoder && void 0 !== e12.encoder && "function" != typeof e12.encoder)
              throw TypeError("Encoder has to be a function.");
            let r11 = e12.charset || S.charset;
            if (void 0 !== e12.charset && "utf-8" !== e12.charset && "iso-8859-1" !== e12.charset)
              throw TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            let a3 = f;
            if (void 0 !== e12.format) {
              if (!v.call(m, e12.format))
                throw TypeError("Unknown format option provided.");
              a3 = e12.format;
            }
            let n3 = m[a3], i3 = S.filter;
            if (("function" == typeof e12.filter || w(e12.filter)) && (i3 = e12.filter), t11 = e12.arrayFormat && e12.arrayFormat in _ ? e12.arrayFormat : "indices" in e12 ? e12.indices ? "indices" : "repeat" : S.arrayFormat, "commaRoundTrip" in e12 && "boolean" != typeof e12.commaRoundTrip)
              throw TypeError("`commaRoundTrip` must be a boolean, or absent");
            let s3 = void 0 === e12.allowDots ? true == !!e12.encodeDotInKeys || S.allowDots : !!e12.allowDots;
            return { addQueryPrefix: "boolean" == typeof e12.addQueryPrefix ? e12.addQueryPrefix : S.addQueryPrefix, allowDots: s3, allowEmptyArrays: "boolean" == typeof e12.allowEmptyArrays ? !!e12.allowEmptyArrays : S.allowEmptyArrays, arrayFormat: t11, charset: r11, charsetSentinel: "boolean" == typeof e12.charsetSentinel ? e12.charsetSentinel : S.charsetSentinel, commaRoundTrip: !!e12.commaRoundTrip, delimiter: void 0 === e12.delimiter ? S.delimiter : e12.delimiter, encode: "boolean" == typeof e12.encode ? e12.encode : S.encode, encodeDotInKeys: "boolean" == typeof e12.encodeDotInKeys ? e12.encodeDotInKeys : S.encodeDotInKeys, encoder: "function" == typeof e12.encoder ? e12.encoder : S.encoder, encodeValuesOnly: "boolean" == typeof e12.encodeValuesOnly ? e12.encodeValuesOnly : S.encodeValuesOnly, filter: i3, format: a3, formatter: n3, serializeDate: "function" == typeof e12.serializeDate ? e12.serializeDate : S.serializeDate, skipNulls: "boolean" == typeof e12.skipNulls ? e12.skipNulls : S.skipNulls, sort: "function" == typeof e12.sort ? e12.sort : null, strictNullHandling: "boolean" == typeof e12.strictNullHandling ? e12.strictNullHandling : S.strictNullHandling };
          }(t10);
          "function" == typeof n2.filter ? a2 = (0, n2.filter)("", a2) : w(n2.filter) && (r10 = n2.filter);
          let i2 = [];
          if ("object" != typeof a2 || null === a2)
            return "";
          let s2 = _[n2.arrayFormat], o2 = "comma" === s2 && n2.commaRoundTrip;
          r10 || (r10 = Object.keys(a2)), n2.sort && r10.sort(n2.sort);
          let l2 = /* @__PURE__ */ new WeakMap();
          for (let e12 = 0; e12 < r10.length; ++e12) {
            let t11 = r10[e12];
            n2.skipNulls && null === a2[t11] || x(i2, function e13(t12, r11, a3, n3, i3, s3, o3, l3, u3, c3, d2, h2, p2, f2, m2, g2, y2, v2) {
              var _2, E2;
              let O2, k2 = t12, T2 = v2, P2 = 0, C2 = false;
              for (; void 0 !== (T2 = T2.get(A)) && !C2; ) {
                let e14 = T2.get(t12);
                if (P2 += 1, void 0 !== e14) {
                  if (e14 === P2)
                    throw RangeError("Cyclic object value");
                  C2 = true;
                }
                void 0 === T2.get(A) && (P2 = 0);
              }
              if ("function" == typeof c3 ? k2 = c3(r11, k2) : k2 instanceof Date ? k2 = p2?.(k2) : "comma" === a3 && w(k2) && (k2 = b(k2, function(e14) {
                return e14 instanceof Date ? p2?.(e14) : e14;
              })), null === k2) {
                if (s3)
                  return u3 && !g2 ? u3(r11, S.encoder, y2, "key", f2) : r11;
                k2 = "";
              }
              if ("string" == typeof (_2 = k2) || "number" == typeof _2 || "boolean" == typeof _2 || "symbol" == typeof _2 || "bigint" == typeof _2 || (E2 = k2) && "object" == typeof E2 && E2.constructor && E2.constructor.isBuffer && E2.constructor.isBuffer(E2)) {
                if (u3) {
                  let e14 = g2 ? r11 : u3(r11, S.encoder, y2, "key", f2);
                  return [m2?.(e14) + "=" + m2?.(u3(k2, S.encoder, y2, "value", f2))];
                }
                return [m2?.(r11) + "=" + m2?.(String(k2))];
              }
              let I2 = [];
              if (void 0 === k2)
                return I2;
              if ("comma" === a3 && w(k2))
                g2 && u3 && (k2 = b(k2, u3)), O2 = [{ value: k2.length > 0 ? k2.join(",") || null : void 0 }];
              else if (w(c3))
                O2 = c3;
              else {
                let e14 = Object.keys(k2);
                O2 = d2 ? e14.sort(d2) : e14;
              }
              let R2 = l3 ? String(r11).replace(/\./g, "%2E") : String(r11), N2 = n3 && w(k2) && 1 === k2.length ? R2 + "[]" : R2;
              if (i3 && w(k2) && 0 === k2.length)
                return N2 + "[]";
              for (let r12 = 0; r12 < O2.length; ++r12) {
                let b2 = O2[r12], _3 = "object" == typeof b2 && void 0 !== b2.value ? b2.value : k2[b2];
                if (o3 && null === _3)
                  continue;
                let E3 = h2 && l3 ? b2.replace(/\./g, "%2E") : b2, S2 = w(k2) ? "function" == typeof a3 ? a3(N2, E3) : N2 : N2 + (h2 ? "." + E3 : "[" + E3 + "]");
                v2.set(t12, P2);
                let T3 = /* @__PURE__ */ new WeakMap();
                T3.set(A, v2), x(I2, e13(_3, S2, a3, n3, i3, s3, o3, l3, "comma" === a3 && g2 && w(k2) ? null : u3, c3, d2, h2, p2, f2, m2, g2, y2, T3));
              }
              return I2;
            }(a2[t11], t11, s2, o2, n2.allowEmptyArrays, n2.strictNullHandling, n2.skipNulls, n2.encodeDotInKeys, n2.encode ? n2.encoder : null, n2.filter, n2.sort, n2.allowDots, n2.serializeDate, n2.format, n2.formatter, n2.encodeValuesOnly, n2.charset, l2));
          }
          let u2 = i2.join(n2.delimiter), c2 = true === n2.addQueryPrefix ? "?" : "";
          return n2.charsetSentinel && ("iso-8859-1" === n2.charset ? c2 += "utf8=%26%2310003%3B&" : c2 += "utf8=%E2%9C%93&"), u2.length > 0 ? c2 + u2 : "";
        }(e10, { arrayFormat: "brackets" });
      }
    }
    rH.OpenAI = rH, rH.DEFAULT_TIMEOUT = 6e5, rH.OpenAIError = C, rH.APIError = I, rH.APIConnectionError = N, rH.APIConnectionTimeoutError = $, rH.APIUserAbortError = R, rH.NotFoundError = D, rH.ConflictError = U, rH.RateLimitError = z, rH.BadRequestError = j, rH.AuthenticationError = L, rH.InternalServerError = B, rH.PermissionDeniedError = M, rH.UnprocessableEntityError = F, rH.toFile = e3, rH.fileFromPath = h, rH.Completions = tM, rH.Chat = tU, rH.Embeddings = tF, rH.Files = tq, rH.FileObjectsPage = tH, rH.Images = tZ, rH.Audio = tJ, rH.Moderations = tK, rH.Models = tX, rH.ModelsPage = tY, rH.FineTuning = t9, rH.Beta = rU, rH.Batches = rF, rH.BatchesPage = rz, rH.Uploads = rq;
    var rZ = r(9279), rG = r(3285), rV = r(5266), rW = r(4220), rJ = r(9904), rK = r(3050), rX = r(4336), rY = r(2811), rQ = r(5747), r0 = r(9757), r1 = r(1582);
    function r2(e10, t10) {
      let r10;
      if (void 0 === e10.function)
        return;
      if (t10?.partial)
        try {
          r10 = (0, rQ.gP)(e10.function.arguments ?? "{}");
        } catch (e11) {
          return;
        }
      else
        try {
          r10 = JSON.parse(e10.function.arguments);
        } catch (t11) {
          throw new rY.dS([`Function "${e10.function.name}" arguments:`, "", e10.function.arguments, "", "are not valid JSON.", `Error: ${t11.message}`].join("\n"));
        }
      let a2 = { name: e10.function.name, args: r10, type: "tool_call" };
      return t10?.returnId && (a2.id = e10.id), a2;
    }
    function r4(e10) {
      if (void 0 === e10.id)
        throw Error('All OpenAI tool calls must have an "id" field.');
      return { id: e10.id, type: "function", function: { name: e10.name, arguments: JSON.stringify(e10.args) } };
    }
    class r9 extends r0.g {
      static lc_name() {
        return "JsonOutputToolsParser";
      }
      constructor(e10) {
        super(e10), Object.defineProperty(this, "returnId", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain", "output_parsers", "openai_tools"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), this.returnId = e10?.returnId ?? this.returnId;
      }
      _diff() {
        throw Error("Not supported.");
      }
      async parse() {
        throw Error("Not implemented.");
      }
      async parseResult(e10) {
        return await this.parsePartialResult(e10, false);
      }
      async parsePartialResult(e10, t10 = true) {
        let r10;
        let a2 = e10[0].message;
        if ((0, r1.Z0)(a2) && a2.tool_calls?.length ? r10 = a2.tool_calls.map((e11) => {
          let { id: t11, ...r11 } = e11;
          return this.returnId ? { id: t11, ...r11 } : r11;
        }) : void 0 !== a2.additional_kwargs.tool_calls && (r10 = JSON.parse(JSON.stringify(a2.additional_kwargs.tool_calls)).map((e11) => r2(e11, { returnId: this.returnId, partial: t10 }))), !r10)
          return [];
        let n2 = [];
        for (let e11 of r10)
          if (void 0 !== e11) {
            let t11 = { type: e11.name, args: e11.args, id: e11.id };
            n2.push(t11);
          }
        return n2;
      }
    }
    class r3 extends r9 {
      static lc_name() {
        return "JsonOutputKeyToolsParser";
      }
      constructor(e10) {
        super(e10), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain", "output_parsers", "openai_tools"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "returnId", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "keyName", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "returnSingle", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "zodSchema", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.keyName = e10.keyName, this.returnSingle = e10.returnSingle ?? this.returnSingle, this.zodSchema = e10.zodSchema;
      }
      async _validateResult(e10) {
        if (void 0 === this.zodSchema)
          return e10;
        let t10 = await this.zodSchema.safeParseAsync(e10);
        if (t10.success)
          return t10.data;
        throw new rY.dS(`Failed to parse. Text: "${JSON.stringify(e10, null, 2)}". Error: ${JSON.stringify(t10.error.errors)}`, JSON.stringify(e10, null, 2));
      }
      async parsePartialResult(e10) {
        let t10 = (await super.parsePartialResult(e10)).filter((e11) => e11.type === this.keyName), r10 = t10;
        return t10.length ? (this.returnId || (r10 = t10.map((e11) => e11.args)), this.returnSingle) ? r10[0] : r10 : void 0;
      }
      async parseResult(e10) {
        let t10 = (await super.parsePartialResult(e10, false)).filter((e11) => e11.type === this.keyName), r10 = t10;
        return t10.length ? (this.returnId || (r10 = t10.map((e11) => e11.args)), this.returnSingle) ? this._validateResult(r10[0]) : await Promise.all(r10.map((e11) => this._validateResult(e11))) : void 0;
      }
    }
    var r5 = r(7026), r6 = r(5817);
    function r8(e10, t10, r10, a2) {
      a2?.errorMessages && r10 && (e10.errorMessage = { ...e10.errorMessage, [t10]: r10 });
    }
    function r7(e10, t10, r10, a2, n2) {
      e10[t10] = r10, r8(e10, t10, a2, n2);
    }
    let ae = (e10, t10) => ab(e10.innerType._def, t10), at = (e10, t10) => {
      let r10 = { type: "integer", format: "unix-time" };
      if ("openApi3" === t10.target)
        return r10;
      for (let a2 of e10.checks)
        switch (a2.kind) {
          case "min":
            r7(r10, "minimum", a2.value, a2.message, t10);
            break;
          case "max":
            r7(r10, "maximum", a2.value, a2.message, t10);
        }
      return r10;
    }, ar = (e10) => (!("type" in e10) || "string" !== e10.type) && "allOf" in e10, aa = { cuid: /^[cC][^\s-]{8,}$/, cuid2: /^[0-9a-z]+$/, ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/, email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/, emoji: () => (void 0 === n && (n = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), n), base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, nanoid: /^[a-zA-Z0-9_-]{21}$/ };
    function an(e10, t10) {
      let r10 = { type: "string" };
      function a2(e11) {
        return "escape" === t10.patternStrategy ? ai(e11) : e11;
      }
      if (e10.checks)
        for (let n2 of e10.checks)
          switch (n2.kind) {
            case "min":
              r7(r10, "minLength", "number" == typeof r10.minLength ? Math.max(r10.minLength, n2.value) : n2.value, n2.message, t10);
              break;
            case "max":
              r7(r10, "maxLength", "number" == typeof r10.maxLength ? Math.min(r10.maxLength, n2.value) : n2.value, n2.message, t10);
              break;
            case "email":
              switch (t10.emailStrategy) {
                case "format:email":
                  as(r10, "email", n2.message, t10);
                  break;
                case "format:idn-email":
                  as(r10, "idn-email", n2.message, t10);
                  break;
                case "pattern:zod":
                  ao(r10, aa.email, n2.message, t10);
              }
              break;
            case "url":
              as(r10, "uri", n2.message, t10);
              break;
            case "uuid":
              as(r10, "uuid", n2.message, t10);
              break;
            case "regex":
              ao(r10, n2.regex, n2.message, t10);
              break;
            case "cuid":
              ao(r10, aa.cuid, n2.message, t10);
              break;
            case "cuid2":
              ao(r10, aa.cuid2, n2.message, t10);
              break;
            case "startsWith":
              ao(r10, RegExp(`^${a2(n2.value)}`), n2.message, t10);
              break;
            case "endsWith":
              ao(r10, RegExp(`${a2(n2.value)}$`), n2.message, t10);
              break;
            case "datetime":
              as(r10, "date-time", n2.message, t10);
              break;
            case "date":
              as(r10, "date", n2.message, t10);
              break;
            case "time":
              as(r10, "time", n2.message, t10);
              break;
            case "duration":
              as(r10, "duration", n2.message, t10);
              break;
            case "length":
              r7(r10, "minLength", "number" == typeof r10.minLength ? Math.max(r10.minLength, n2.value) : n2.value, n2.message, t10), r7(r10, "maxLength", "number" == typeof r10.maxLength ? Math.min(r10.maxLength, n2.value) : n2.value, n2.message, t10);
              break;
            case "includes":
              ao(r10, RegExp(a2(n2.value)), n2.message, t10);
              break;
            case "ip":
              "v6" !== n2.version && as(r10, "ipv4", n2.message, t10), "v4" !== n2.version && as(r10, "ipv6", n2.message, t10);
              break;
            case "emoji":
              ao(r10, aa.emoji, n2.message, t10);
              break;
            case "ulid":
              ao(r10, aa.ulid, n2.message, t10);
              break;
            case "base64":
              switch (t10.base64Strategy) {
                case "format:binary":
                  as(r10, "binary", n2.message, t10);
                  break;
                case "contentEncoding:base64":
                  r7(r10, "contentEncoding", "base64", n2.message, t10);
                  break;
                case "pattern:zod":
                  ao(r10, aa.base64, n2.message, t10);
              }
              break;
            case "nanoid":
              ao(r10, aa.nanoid, n2.message, t10);
          }
      return r10;
    }
    let ai = (e10) => Array.from(e10).map((e11) => /[a-zA-Z0-9]/.test(e11) ? e11 : `\\${e11}`).join(""), as = (e10, t10, r10, a2) => {
      e10.format || e10.anyOf?.some((e11) => e11.format) ? (e10.anyOf || (e10.anyOf = []), e10.format && (e10.anyOf.push({ format: e10.format, ...e10.errorMessage && a2.errorMessages && { errorMessage: { format: e10.errorMessage.format } } }), delete e10.format, e10.errorMessage && (delete e10.errorMessage.format, 0 === Object.keys(e10.errorMessage).length && delete e10.errorMessage)), e10.anyOf.push({ format: t10, ...r10 && a2.errorMessages && { errorMessage: { format: r10 } } })) : r7(e10, "format", t10, r10, a2);
    }, ao = (e10, t10, r10, a2) => {
      e10.pattern || e10.allOf?.some((e11) => e11.pattern) ? (e10.allOf || (e10.allOf = []), e10.pattern && (e10.allOf.push({ pattern: e10.pattern, ...e10.errorMessage && a2.errorMessages && { errorMessage: { pattern: e10.errorMessage.pattern } } }), delete e10.pattern, e10.errorMessage && (delete e10.errorMessage.pattern, 0 === Object.keys(e10.errorMessage).length && delete e10.errorMessage)), e10.allOf.push({ pattern: al(t10, a2), ...r10 && a2.errorMessages && { errorMessage: { pattern: r10 } } })) : r7(e10, "pattern", al(t10, a2), r10, a2);
    }, al = (e10, t10) => {
      let r10 = "function" == typeof e10 ? e10() : e10;
      if (!t10.applyRegexFlags || !r10.flags)
        return r10.source;
      let a2 = { i: r10.flags.includes("i"), m: r10.flags.includes("m"), s: r10.flags.includes("s") }, n2 = a2.i ? r10.source.toLowerCase() : r10.source, i2 = "", s2 = false, o2 = false, l2 = false;
      for (let e11 = 0; e11 < n2.length; e11++) {
        if (s2) {
          i2 += n2[e11], s2 = false;
          continue;
        }
        if (a2.i) {
          if (o2) {
            if (n2[e11].match(/[a-z]/)) {
              l2 ? (i2 += n2[e11] + `${n2[e11 - 2]}-${n2[e11]}`.toUpperCase(), l2 = false) : "-" === n2[e11 + 1] && n2[e11 + 2]?.match(/[a-z]/) ? (i2 += n2[e11], l2 = true) : i2 += `${n2[e11]}${n2[e11].toUpperCase()}`;
              continue;
            }
          } else if (n2[e11].match(/[a-z]/)) {
            i2 += `[${n2[e11]}${n2[e11].toUpperCase()}]`;
            continue;
          }
        }
        if (a2.m) {
          if ("^" === n2[e11]) {
            i2 += `(^|(?<=[\r
]))`;
            continue;
          }
          if ("$" === n2[e11]) {
            i2 += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (a2.s && "." === n2[e11]) {
          i2 += o2 ? `${n2[e11]}\r
` : `[${n2[e11]}\r
]`;
          continue;
        }
        i2 += n2[e11], "\\" === n2[e11] ? s2 = true : o2 && "]" === n2[e11] ? o2 = false : o2 || "[" !== n2[e11] || (o2 = true);
      }
      try {
        new RegExp(i2);
      } catch {
        return console.warn(`Could not convert regex pattern at ${t10.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), r10.source;
      }
      return i2;
    };
    function au(e10, t10) {
      if ("openApi3" === t10.target && e10.keyType?._def.typeName === r6.pA.ZodEnum)
        return { type: "object", required: e10.keyType._def.values, properties: e10.keyType._def.values.reduce((r11, a2) => ({ ...r11, [a2]: ab(e10.valueType._def, { ...t10, currentPath: [...t10.currentPath, "properties", a2] }) ?? {} }), {}), additionalProperties: false };
      let r10 = { type: "object", additionalProperties: ab(e10.valueType._def, { ...t10, currentPath: [...t10.currentPath, "additionalProperties"] }) ?? {} };
      if ("openApi3" === t10.target)
        return r10;
      if (e10.keyType?._def.typeName === r6.pA.ZodString && e10.keyType._def.checks?.length) {
        let a2 = Object.entries(an(e10.keyType._def, t10)).reduce((e11, [t11, r11]) => "type" === t11 ? e11 : { ...e11, [t11]: r11 }, {});
        return { ...r10, propertyNames: a2 };
      }
      return e10.keyType?._def.typeName === r6.pA.ZodEnum ? { ...r10, propertyNames: { enum: e10.keyType._def.values } } : r10;
    }
    let ac = { ZodString: "string", ZodNumber: "number", ZodBigInt: "integer", ZodBoolean: "boolean", ZodNull: "null" }, ad = (e10, t10) => {
      let r10 = (e10.options instanceof Map ? Array.from(e10.options.values()) : e10.options).map((e11, r11) => ab(e11._def, { ...t10, currentPath: [...t10.currentPath, "anyOf", `${r11}`] })).filter((e11) => !!e11 && (!t10.strictUnions || "object" == typeof e11 && Object.keys(e11).length > 0));
      return r10.length ? { anyOf: r10 } : void 0;
    }, ah = (e10, t10) => {
      if (t10.currentPath.toString() === t10.propertyPath?.toString())
        return ab(e10.innerType._def, t10);
      let r10 = ab(e10.innerType._def, { ...t10, currentPath: [...t10.currentPath, "anyOf", "1"] });
      return r10 ? { anyOf: [{ not: {} }, r10] } : {};
    }, ap = (e10, t10) => {
      if ("input" === t10.pipeStrategy)
        return ab(e10.in._def, t10);
      if ("output" === t10.pipeStrategy)
        return ab(e10.out._def, t10);
      let r10 = ab(e10.in._def, { ...t10, currentPath: [...t10.currentPath, "allOf", "0"] }), a2 = ab(e10.out._def, { ...t10, currentPath: [...t10.currentPath, "allOf", r10 ? "1" : "0"] });
      return { allOf: [r10, a2].filter((e11) => void 0 !== e11) };
    }, af = (e10, t10) => ab(e10.innerType._def, t10), am = Symbol("Let zodToJsonSchema decide on which parser to use"), ag = { name: void 0, $refStrategy: "root", effectStrategy: "input", pipeStrategy: "all", dateStrategy: "format:date-time", mapStrategy: "entries", nullableStrategy: "from-target", removeAdditionalStrategy: "passthrough", definitionPath: "definitions", target: "jsonSchema7", strictUnions: false, errorMessages: false, markdownDescription: false, patternStrategy: "escape", applyRegexFlags: false, emailStrategy: "format:email", base64Strategy: "contentEncoding:base64", nameStrategy: "ref" }, ay = (e10) => "string" == typeof e10 ? { ...ag, basePath: ["#"], definitions: {}, name: e10 } : { ...ag, basePath: ["#"], definitions: {}, ...e10 };
    function ab(e10, t10, r10 = false) {
      let a2 = t10.seen.get(e10);
      if (t10.override) {
        let n3 = t10.override?.(e10, t10, a2, r10);
        if (n3 !== am)
          return n3;
      }
      if (a2 && !r10) {
        let e11 = av(a2, t10);
        if (void 0 !== e11)
          return "$ref" in e11 && t10.seenRefs.add(e11.$ref), e11;
      }
      let n2 = { def: e10, path: t10.currentPath, jsonSchema: void 0 };
      t10.seen.set(e10, n2);
      let i2 = aw(e10, e10.typeName, t10, r10);
      return i2 && aE(e10, t10, i2), n2.jsonSchema = i2, i2;
    }
    let av = (e10, t10) => {
      switch (t10.$refStrategy) {
        case "root":
          return { $ref: e10.path.join("/") };
        case "extract-to-root":
          let r10 = e10.path.slice(t10.basePath.length + 1).join("_");
          return r10 !== t10.name && "duplicate-ref" === t10.nameStrategy && (t10.definitions[r10] = e10.def), { $ref: [...t10.basePath, t10.definitionPath, r10].join("/") };
        case "relative":
          return { $ref: a_(t10.currentPath, e10.path) };
        case "none":
        case "seen":
          if (e10.path.length < t10.currentPath.length && e10.path.every((e11, r11) => t10.currentPath[r11] === e11))
            return console.warn(`Recursive reference detected at ${t10.currentPath.join("/")}! Defaulting to any`), {};
          return "seen" === t10.$refStrategy ? {} : void 0;
      }
    }, a_ = (e10, t10) => {
      let r10 = 0;
      for (; r10 < e10.length && r10 < t10.length && e10[r10] === t10[r10]; r10++)
        ;
      return [(e10.length - r10).toString(), ...t10.slice(r10)].join("/");
    }, aw = (e10, t10, r10, a2) => {
      switch (t10) {
        case r6.pA.ZodString:
          return an(e10, r10);
        case r6.pA.ZodNumber:
          return function(e11, t11) {
            let r11 = { type: "number" };
            if (!e11.checks)
              return r11;
            for (let a3 of e11.checks)
              switch (a3.kind) {
                case "int":
                  r11.type = "integer", r8(r11, "type", a3.message, t11);
                  break;
                case "min":
                  "jsonSchema7" === t11.target ? a3.inclusive ? r7(r11, "minimum", a3.value, a3.message, t11) : r7(r11, "exclusiveMinimum", a3.value, a3.message, t11) : (a3.inclusive || (r11.exclusiveMinimum = true), r7(r11, "minimum", a3.value, a3.message, t11));
                  break;
                case "max":
                  "jsonSchema7" === t11.target ? a3.inclusive ? r7(r11, "maximum", a3.value, a3.message, t11) : r7(r11, "exclusiveMaximum", a3.value, a3.message, t11) : (a3.inclusive || (r11.exclusiveMaximum = true), r7(r11, "maximum", a3.value, a3.message, t11));
                  break;
                case "multipleOf":
                  r7(r11, "multipleOf", a3.value, a3.message, t11);
              }
            return r11;
          }(e10, r10);
        case r6.pA.ZodObject:
          return function(e11, t11) {
            let r11 = { type: "object", ...Object.entries(e11.shape()).reduce((e12, [r12, a3]) => {
              if (void 0 === a3 || void 0 === a3._def)
                return e12;
              let n2 = ab(a3._def, { ...t11, currentPath: [...t11.currentPath, "properties", r12], propertyPath: [...t11.currentPath, "properties", r12] });
              return void 0 === n2 ? e12 : { properties: { ...e12.properties, [r12]: n2 }, required: a3.isOptional() && !t11.openaiStrictMode ? e12.required : [...e12.required, r12] };
            }, { properties: {}, required: [] }), additionalProperties: "strict" === t11.removeAdditionalStrategy ? "ZodNever" === e11.catchall._def.typeName ? "strict" !== e11.unknownKeys : ab(e11.catchall._def, { ...t11, currentPath: [...t11.currentPath, "additionalProperties"] }) ?? true : "ZodNever" === e11.catchall._def.typeName ? "passthrough" === e11.unknownKeys : ab(e11.catchall._def, { ...t11, currentPath: [...t11.currentPath, "additionalProperties"] }) ?? true };
            return r11.required.length || delete r11.required, r11;
          }(e10, r10);
        case r6.pA.ZodBigInt:
          return function(e11, t11) {
            let r11 = { type: "integer", format: "int64" };
            if (!e11.checks)
              return r11;
            for (let a3 of e11.checks)
              switch (a3.kind) {
                case "min":
                  "jsonSchema7" === t11.target ? a3.inclusive ? r7(r11, "minimum", a3.value, a3.message, t11) : r7(r11, "exclusiveMinimum", a3.value, a3.message, t11) : (a3.inclusive || (r11.exclusiveMinimum = true), r7(r11, "minimum", a3.value, a3.message, t11));
                  break;
                case "max":
                  "jsonSchema7" === t11.target ? a3.inclusive ? r7(r11, "maximum", a3.value, a3.message, t11) : r7(r11, "exclusiveMaximum", a3.value, a3.message, t11) : (a3.inclusive || (r11.exclusiveMaximum = true), r7(r11, "maximum", a3.value, a3.message, t11));
                  break;
                case "multipleOf":
                  r7(r11, "multipleOf", a3.value, a3.message, t11);
              }
            return r11;
          }(e10, r10);
        case r6.pA.ZodBoolean:
          return { type: "boolean" };
        case r6.pA.ZodDate:
          return function e11(t11, r11, a3) {
            let n2 = a3 ?? r11.dateStrategy;
            if (Array.isArray(n2))
              return { anyOf: n2.map((a4, n3) => e11(t11, r11, a4)) };
            switch (n2) {
              case "string":
              case "format:date-time":
                return { type: "string", format: "date-time" };
              case "format:date":
                return { type: "string", format: "date" };
              case "integer":
                return at(t11, r11);
            }
          }(e10, r10);
        case r6.pA.ZodUndefined:
          return { not: {} };
        case r6.pA.ZodNull:
          return "openApi3" === r10.target ? { enum: ["null"], nullable: true } : { type: "null" };
        case r6.pA.ZodArray:
          return function(e11, t11) {
            let r11 = { type: "array" };
            return e11.type?._def?.typeName !== r6.pA.ZodAny && (r11.items = ab(e11.type._def, { ...t11, currentPath: [...t11.currentPath, "items"] })), e11.minLength && r7(r11, "minItems", e11.minLength.value, e11.minLength.message, t11), e11.maxLength && r7(r11, "maxItems", e11.maxLength.value, e11.maxLength.message, t11), e11.exactLength && (r7(r11, "minItems", e11.exactLength.value, e11.exactLength.message, t11), r7(r11, "maxItems", e11.exactLength.value, e11.exactLength.message, t11)), r11;
          }(e10, r10);
        case r6.pA.ZodUnion:
        case r6.pA.ZodDiscriminatedUnion:
          return function(e11, t11) {
            if ("openApi3" === t11.target)
              return ad(e11, t11);
            let r11 = e11.options instanceof Map ? Array.from(e11.options.values()) : e11.options;
            if (r11.every((e12) => e12._def.typeName in ac && (!e12._def.checks || !e12._def.checks.length))) {
              let e12 = r11.reduce((e13, t12) => {
                let r12 = ac[t12._def.typeName];
                return r12 && !e13.includes(r12) ? [...e13, r12] : e13;
              }, []);
              return { type: e12.length > 1 ? e12 : e12[0] };
            }
            if (r11.every((e12) => "ZodLiteral" === e12._def.typeName && !e12.description)) {
              let e12 = r11.reduce((e13, t12) => {
                let r12 = typeof t12._def.value;
                switch (r12) {
                  case "string":
                  case "number":
                  case "boolean":
                    return [...e13, r12];
                  case "bigint":
                    return [...e13, "integer"];
                  case "object":
                    if (null === t12._def.value)
                      return [...e13, "null"];
                  default:
                    return e13;
                }
              }, []);
              if (e12.length === r11.length) {
                let t12 = e12.filter((e13, t13, r12) => r12.indexOf(e13) === t13);
                return { type: t12.length > 1 ? t12 : t12[0], enum: r11.reduce((e13, t13) => e13.includes(t13._def.value) ? e13 : [...e13, t13._def.value], []) };
              }
            } else if (r11.every((e12) => "ZodEnum" === e12._def.typeName))
              return { type: "string", enum: r11.reduce((e12, t12) => [...e12, ...t12._def.values.filter((t13) => !e12.includes(t13))], []) };
            return ad(e11, t11);
          }(e10, r10);
        case r6.pA.ZodIntersection:
          return function(e11, t11) {
            let r11 = [ab(e11.left._def, { ...t11, currentPath: [...t11.currentPath, "allOf", "0"] }), ab(e11.right._def, { ...t11, currentPath: [...t11.currentPath, "allOf", "1"] })].filter((e12) => !!e12), a3 = "jsonSchema2019-09" === t11.target ? { unevaluatedProperties: false } : void 0, n2 = [];
            return r11.forEach((e12) => {
              if (ar(e12))
                n2.push(...e12.allOf), void 0 === e12.unevaluatedProperties && (a3 = void 0);
              else {
                let t12 = e12;
                if ("additionalProperties" in e12 && false === e12.additionalProperties) {
                  let { additionalProperties: r12, ...a4 } = e12;
                  t12 = a4;
                } else
                  a3 = void 0;
                n2.push(t12);
              }
            }), n2.length ? { allOf: n2, ...a3 } : void 0;
          }(e10, r10);
        case r6.pA.ZodTuple:
          return function(e11, t11) {
            return e11.rest ? { type: "array", minItems: e11.items.length, items: e11.items.map((e12, r11) => ab(e12._def, { ...t11, currentPath: [...t11.currentPath, "items", `${r11}`] })).reduce((e12, t12) => void 0 === t12 ? e12 : [...e12, t12], []), additionalItems: ab(e11.rest._def, { ...t11, currentPath: [...t11.currentPath, "additionalItems"] }) } : { type: "array", minItems: e11.items.length, maxItems: e11.items.length, items: e11.items.map((e12, r11) => ab(e12._def, { ...t11, currentPath: [...t11.currentPath, "items", `${r11}`] })).reduce((e12, t12) => void 0 === t12 ? e12 : [...e12, t12], []) };
          }(e10, r10);
        case r6.pA.ZodRecord:
          return au(e10, r10);
        case r6.pA.ZodLiteral:
          return function(e11, t11) {
            let r11 = typeof e11.value;
            return "bigint" !== r11 && "number" !== r11 && "boolean" !== r11 && "string" !== r11 ? { type: Array.isArray(e11.value) ? "array" : "object" } : "openApi3" === t11.target ? { type: "bigint" === r11 ? "integer" : r11, enum: [e11.value] } : { type: "bigint" === r11 ? "integer" : r11, const: e11.value };
          }(e10, r10);
        case r6.pA.ZodEnum:
          return { type: "string", enum: [...e10.values] };
        case r6.pA.ZodNativeEnum:
          return function(e11) {
            let t11 = e11.values, r11 = Object.keys(e11.values).filter((e12) => "number" != typeof t11[t11[e12]]).map((e12) => t11[e12]), a3 = Array.from(new Set(r11.map((e12) => typeof e12)));
            return { type: 1 === a3.length ? "string" === a3[0] ? "string" : "number" : ["string", "number"], enum: r11 };
          }(e10);
        case r6.pA.ZodNullable:
          return function(e11, t11) {
            if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e11.innerType._def.typeName) && (!e11.innerType._def.checks || !e11.innerType._def.checks.length))
              return "openApi3" === t11.target || "property" === t11.nullableStrategy ? { type: ac[e11.innerType._def.typeName], nullable: true } : { type: [ac[e11.innerType._def.typeName], "null"] };
            if ("openApi3" === t11.target) {
              let r12 = ab(e11.innerType._def, { ...t11, currentPath: [...t11.currentPath] });
              return r12 && "$ref" in r12 ? { allOf: [r12], nullable: true } : r12 && { ...r12, nullable: true };
            }
            let r11 = ab(e11.innerType._def, { ...t11, currentPath: [...t11.currentPath, "anyOf", "0"] });
            return r11 && { anyOf: [r11, { type: "null" }] };
          }(e10, r10);
        case r6.pA.ZodOptional:
          return ah(e10, r10);
        case r6.pA.ZodMap:
          return function(e11, t11) {
            return "record" === t11.mapStrategy ? au(e11, t11) : { type: "array", maxItems: 125, items: { type: "array", items: [ab(e11.keyType._def, { ...t11, currentPath: [...t11.currentPath, "items", "items", "0"] }) || {}, ab(e11.valueType._def, { ...t11, currentPath: [...t11.currentPath, "items", "items", "1"] }) || {}], minItems: 2, maxItems: 2 } };
          }(e10, r10);
        case r6.pA.ZodSet:
          return function(e11, t11) {
            let r11 = { type: "array", uniqueItems: true, items: ab(e11.valueType._def, { ...t11, currentPath: [...t11.currentPath, "items"] }) };
            return e11.minSize && r7(r11, "minItems", e11.minSize.value, e11.minSize.message, t11), e11.maxSize && r7(r11, "maxItems", e11.maxSize.value, e11.maxSize.message, t11), r11;
          }(e10, r10);
        case r6.pA.ZodLazy:
          return ab(e10.getter()._def, r10);
        case r6.pA.ZodPromise:
          return ab(e10.type._def, r10);
        case r6.pA.ZodNaN:
        case r6.pA.ZodNever:
          return { not: {} };
        case r6.pA.ZodEffects:
          return function(e11, t11, r11) {
            return "input" === t11.effectStrategy ? ab(e11.schema._def, t11, r11) : {};
          }(e10, r10, a2);
        case r6.pA.ZodAny:
        case r6.pA.ZodUnknown:
          return {};
        case r6.pA.ZodDefault:
          return function(e11, t11) {
            return { ...ab(e11.innerType._def, t11), default: e11.defaultValue() };
          }(e10, r10);
        case r6.pA.ZodBranded:
          return ab(e10.type._def, r10);
        case r6.pA.ZodReadonly:
          return af(e10, r10);
        case r6.pA.ZodCatch:
          return ae(e10, r10);
        case r6.pA.ZodPipeline:
          return ap(e10, r10);
        case r6.pA.ZodFunction:
        case r6.pA.ZodVoid:
        case r6.pA.ZodSymbol:
        default:
          return;
      }
    }, aE = (e10, t10, r10) => (e10.description && (r10.description = e10.description, t10.markdownDescription && (r10.markdownDescription = e10.description)), r10), ax = (e10) => "_def" in e10 ? e10._def : e10, aO = (e10) => {
      let t10 = ay(e10), r10 = void 0 !== t10.name ? [...t10.basePath, t10.definitionPath, t10.name] : t10.basePath;
      return { ...t10, currentPath: r10, propertyPath: void 0, seenRefs: /* @__PURE__ */ new Set(), seen: new Map(Object.entries(t10.definitions).map(([e11, r11]) => [ax(r11), { def: ax(r11), path: [...t10.basePath, t10.definitionPath, e11], jsonSchema: void 0 }])) };
    }, aS = (e10, t10) => {
      let r10 = aO(t10), a2 = "string" == typeof t10 ? t10 : t10?.nameStrategy === "title" ? void 0 : t10?.name, n2 = ab(e10._def, void 0 === a2 ? r10 : { ...r10, currentPath: [...r10.basePath, r10.definitionPath, a2] }, false) ?? {}, i2 = "object" == typeof t10 && void 0 !== t10.name && "title" === t10.nameStrategy ? t10.name : void 0;
      void 0 !== i2 && (n2.title = i2);
      let s2 = (() => {
        if (function(e12) {
          if (!e12)
            return true;
          for (let t12 in e12)
            return false;
          return true;
        }(r10.definitions))
          return;
        let e11 = {}, t11 = /* @__PURE__ */ new Set();
        for (let a3 = 0; a3 < 500; a3++) {
          let a4 = Object.entries(r10.definitions).filter(([e12]) => !t11.has(e12));
          if (0 === a4.length)
            break;
          for (let [n3, i3] of a4)
            e11[n3] = ab(ax(i3), { ...r10, currentPath: [...r10.basePath, r10.definitionPath, n3] }, true) ?? {}, t11.add(n3);
        }
        return e11;
      })(), o2 = void 0 === a2 ? s2 ? { ...n2, [r10.definitionPath]: s2 } : n2 : "duplicate-ref" === r10.nameStrategy ? { ...n2, ...s2 || r10.seenRefs.size ? { [r10.definitionPath]: { ...s2, ...r10.seenRefs.size ? { [a2]: n2 } : void 0 } } : void 0 } : { $ref: [..."relative" === r10.$refStrategy ? [] : r10.basePath, r10.definitionPath, a2].join("/"), [r10.definitionPath]: { ...s2, [a2]: n2 } };
      return "jsonSchema7" === r10.target ? o2.$schema = "http://json-schema.org/draft-07/schema#" : "jsonSchema2019-09" === r10.target && (o2.$schema = "https://json-schema.org/draft/2019-09/schema#"), o2;
    };
    function aA(e10, t10) {
      return aS(e10, { openaiStrictMode: true, name: t10.name, nameStrategy: "duplicate-ref", $refStrategy: "extract-to-root", nullableStrategy: "property" });
    }
    function ak(e10) {
      let { azureOpenAIApiDeploymentName: t10, azureOpenAIApiInstanceName: r10, azureOpenAIApiKey: a2, azureOpenAIBasePath: n2, baseURL: i2, azureADTokenProvider: s2, azureOpenAIEndpoint: o2 } = e10;
      if ((a2 || s2) && n2 && t10)
        return `${n2}/${t10}`;
      if ((a2 || s2) && o2 && t10)
        return `${o2}/openai/deployments/${t10}`;
      if (a2 || s2) {
        if (!r10)
          throw Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
        if (!t10)
          throw Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
        return `https://${r10}.openai.azure.com/openai/deployments/${t10}`;
      }
      return i2;
    }
    var aT = r(3406);
    function aP(e10, t10) {
      return e10.lc_error_code = t10, e10.message = `${e10.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${t10}/
`, e10;
    }
    function aC(e10) {
      let t10;
      return e10.constructor.name === $.name ? (t10 = Error(e10.message)).name = "TimeoutError" : e10.constructor.name === R.name ? (t10 = Error(e10.message)).name = "AbortError" : t10 = 400 === e10.status && e10.message.includes("tool_calls") ? aP(e10, "INVALID_TOOL_RESULTS") : 401 === e10.status ? aP(e10, "MODEL_AUTHENTICATION") : 429 === e10.status ? aP(e10, "MODEL_RATE_LIMIT") : 404 === e10.status ? aP(e10, "MODEL_NOT_FOUND") : e10, t10;
    }
    function aI(e10, t10) {
      let r10 = [];
      for (let [a2, n2] of Object.entries(e10.properties ?? {}))
        n2.description && t10 < 2 && r10.push(`// ${n2.description}`), e10.required?.includes(a2) ? r10.push(`${a2}: ${aR(n2, t10)},`) : r10.push(`${a2}?: ${aR(n2, t10)},`);
      return r10.map((e11) => " ".repeat(t10) + e11).join("\n");
    }
    function aR(e10, t10) {
      if (void 0 !== e10.anyOf && Array.isArray(e10.anyOf))
        return e10.anyOf.map((e11) => aR(e11, t10)).join(" | ");
      switch (e10.type) {
        case "string":
          if (e10.enum)
            return e10.enum.map((e11) => `"${e11}"`).join(" | ");
          return "string";
        case "number":
          if (e10.enum)
            return e10.enum.map((e11) => `${e11}`).join(" | ");
          return "number";
        case "integer":
          if (e10.enum)
            return e10.enum.map((e11) => `${e11}`).join(" | ");
          return "number";
        case "boolean":
          return "boolean";
        case "null":
          return "null";
        case "object":
          return ["{", aI(e10, t10 + 2), "}"].join("\n");
        case "array":
          if (e10.items)
            return `${aR(e10.items, t10)}[]`;
          return "any[]";
        default:
          return "";
      }
    }
    function aN(e10) {
      let t10 = e10._getType();
      switch (t10) {
        case "system":
          return "system";
        case "ai":
          return "assistant";
        case "human":
          return "user";
        case "function":
          return "function";
        case "tool":
          return "tool";
        case "generic":
          if (!rZ.J.isInstance(e10))
            throw Error("Invalid generic chat message");
          return "system" !== e10.role && "assistant" !== e10.role && "user" !== e10.role && "function" !== e10.role && "tool" !== e10.role && console.warn(`Unknown message role: ${e10.role}`), e10.role;
        default:
          throw Error(`Unknown message type: ${t10}`);
      }
    }
    function a$(e10) {
      return e10.flatMap((e11) => {
        let t10 = { role: aN(e11), content: e11.content };
        return (null != e11.name && (t10.name = e11.name), null != e11.additional_kwargs.function_call && (t10.function_call = e11.additional_kwargs.function_call, t10.content = null), (0, rZ.Z0)(e11) && e11.tool_calls?.length ? (t10.tool_calls = e11.tool_calls.map(r4), t10.content = null) : (null != e11.additional_kwargs.tool_calls && (t10.tool_calls = e11.additional_kwargs.tool_calls), null != e11.tool_call_id && (t10.tool_call_id = e11.tool_call_id)), e11.additional_kwargs.audio && "object" == typeof e11.additional_kwargs.audio && "id" in e11.additional_kwargs.audio) ? [t10, { role: "assistant", audio: { id: e11.additional_kwargs.audio.id } }] : t10;
      });
    }
    function aj(e10, t10) {
      return (0, rJ.er)(e10) ? t10?.strict !== void 0 ? { ...e10, function: { ...e10.function, strict: t10.strict } } : e10 : function(e11, t11) {
        let r10;
        if ((0, aT.iW)(e11)) {
          var a2;
          let n2 = function(e12, { parser: t12, callback: r11 }) {
            let a3 = { ...e12 };
            return Object.defineProperties(a3, { $brand: { value: "auto-parseable-tool", enumerable: false }, $parseRaw: { value: t12, enumerable: false }, $callback: { value: r11, enumerable: false } }), a3;
          }({ type: "function", function: { name: (a2 = { name: e11.name, parameters: e11.schema, description: e11.description }).name, parameters: aA(a2.parameters, { name: a2.name }), strict: true, ...a2.description ? { description: a2.description } : void 0 } }, { callback: a2.function, parser: (e12) => a2.parameters.parse(JSON.parse(e12)) });
          r10 = n2.function.parameters ? { type: n2.type, function: { name: n2.function.name, description: n2.function.description, parameters: n2.function.parameters, ...t11?.strict !== void 0 ? { strict: t11.strict } : {} } } : { type: "function", function: (0, aT.sU)(e11, t11) };
        } else
          r10 = e11;
        return t11?.strict !== void 0 && (r10.function.strict = t11.strict), r10;
      }(e10, t10);
    }
    class aL extends rW.BaseChatModel {
      static lc_name() {
        return "ChatOpenAI";
      }
      get callKeys() {
        return [...super.callKeys, "options", "function_call", "functions", "tools", "tool_choice", "promptIndex", "response_format", "seed"];
      }
      get lc_secrets() {
        return { openAIApiKey: "OPENAI_API_KEY", apiKey: "OPENAI_API_KEY", azureOpenAIApiKey: "AZURE_OPENAI_API_KEY", organization: "OPENAI_ORGANIZATION" };
      }
      get lc_aliases() {
        return { modelName: "model", openAIApiKey: "openai_api_key", apiKey: "openai_api_key", azureOpenAIApiVersion: "azure_openai_api_version", azureOpenAIApiKey: "azure_openai_api_key", azureOpenAIApiInstanceName: "azure_openai_api_instance_name", azureOpenAIApiDeploymentName: "azure_openai_api_deployment_name" };
      }
      constructor(e10, t10) {
        if (super(e10 ?? {}), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "temperature", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "topP", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "frequencyPenalty", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "presencePenalty", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "n", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "logitBias", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "modelName", { enumerable: true, configurable: true, writable: true, value: "gpt-3.5-turbo" }), Object.defineProperty(this, "model", { enumerable: true, configurable: true, writable: true, value: "gpt-3.5-turbo" }), Object.defineProperty(this, "modelKwargs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "stop", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "stopSequences", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "user", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "timeout", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "streaming", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "streamUsage", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "maxTokens", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "logprobs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "topLogprobs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "openAIApiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "apiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiVersion", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureADTokenProvider", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiInstanceName", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiDeploymentName", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIBasePath", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIEndpoint", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "organization", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "__includeRawResponse", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientConfig", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "supportsStrictToolCalling", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "audio", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "modalities", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.openAIApiKey = e10?.apiKey ?? e10?.openAIApiKey ?? e10?.configuration?.apiKey ?? (0, rV.getEnvironmentVariable)("OPENAI_API_KEY"), this.apiKey = this.openAIApiKey, this.azureOpenAIApiKey = e10?.azureOpenAIApiKey ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_KEY"), this.azureADTokenProvider = e10?.azureADTokenProvider ?? void 0, !this.azureOpenAIApiKey && !this.apiKey && !this.azureADTokenProvider)
          throw Error("OpenAI or Azure OpenAI API key or Token Provider not found");
        if (this.azureOpenAIApiInstanceName = e10?.azureOpenAIApiInstanceName ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_INSTANCE_NAME"), this.azureOpenAIApiDeploymentName = e10?.azureOpenAIApiDeploymentName ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_DEPLOYMENT_NAME"), this.azureOpenAIApiVersion = e10?.azureOpenAIApiVersion ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_VERSION"), this.azureOpenAIBasePath = e10?.azureOpenAIBasePath ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_BASE_PATH"), this.organization = e10?.configuration?.organization ?? (0, rV.getEnvironmentVariable)("OPENAI_ORGANIZATION"), this.azureOpenAIEndpoint = e10?.azureOpenAIEndpoint ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_ENDPOINT"), this.modelName = e10?.model ?? e10?.modelName ?? this.model, this.model = this.modelName, this.modelKwargs = e10?.modelKwargs ?? {}, this.timeout = e10?.timeout, this.temperature = e10?.temperature ?? this.temperature, this.topP = e10?.topP ?? this.topP, this.frequencyPenalty = e10?.frequencyPenalty ?? this.frequencyPenalty, this.presencePenalty = e10?.presencePenalty ?? this.presencePenalty, this.maxTokens = e10?.maxTokens, this.logprobs = e10?.logprobs, this.topLogprobs = e10?.topLogprobs, this.n = e10?.n ?? this.n, this.logitBias = e10?.logitBias, this.stop = e10?.stopSequences ?? e10?.stop, this.stopSequences = this?.stop, this.user = e10?.user, this.__includeRawResponse = e10?.__includeRawResponse, this.audio = e10?.audio, this.modalities = e10?.modalities, this.azureOpenAIApiKey || this.azureADTokenProvider) {
          if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath && !this.azureOpenAIEndpoint)
            throw Error("Azure OpenAI API instance name not found");
          if (!this.azureOpenAIApiDeploymentName && this.azureOpenAIBasePath) {
            let e11 = this.azureOpenAIBasePath.split("/openai/deployments/");
            if (2 === e11.length) {
              let [, t11] = e11;
              this.azureOpenAIApiDeploymentName = t11;
            }
          }
          if (!this.azureOpenAIApiDeploymentName)
            throw Error("Azure OpenAI API deployment name not found");
          if (!this.azureOpenAIApiVersion)
            throw Error("Azure OpenAI API version not found");
          this.apiKey = this.apiKey ?? "", this.streamUsage = false;
        }
        this.streaming = e10?.streaming ?? false, this.streamUsage = e10?.streamUsage ?? this.streamUsage, this.clientConfig = { apiKey: this.apiKey, organization: this.organization, baseURL: t10?.basePath ?? e10?.configuration?.basePath, dangerouslyAllowBrowser: true, defaultHeaders: t10?.baseOptions?.headers ?? e10?.configuration?.baseOptions?.headers, defaultQuery: t10?.baseOptions?.params ?? e10?.configuration?.baseOptions?.params, ...t10, ...e10?.configuration }, e10?.supportsStrictToolCalling !== void 0 && (this.supportsStrictToolCalling = e10.supportsStrictToolCalling);
      }
      getLsParams(e10) {
        let t10 = this.invocationParams(e10);
        return { ls_provider: "openai", ls_model_name: this.model, ls_model_type: "chat", ls_temperature: t10.temperature ?? void 0, ls_max_tokens: t10.max_tokens ?? void 0, ls_stop: e10.stop };
      }
      bindTools(e10, t10) {
        let r10;
        return t10?.strict !== void 0 ? r10 = t10.strict : void 0 !== this.supportsStrictToolCalling && (r10 = this.supportsStrictToolCalling), this.bind({ tools: e10.map((e11) => aj(e11, { strict: r10 })), ...t10 });
      }
      createResponseFormat(e10) {
        if (e10 && "json_schema" === e10.type && e10.json_schema.schema && aM(e10.json_schema.schema)) {
          var t10, r10;
          return t10 = e10.json_schema.schema, r10 = e10.json_schema.name, function(e11, t11) {
            let r11 = { ...e11 };
            return Object.defineProperties(r11, { $brand: { value: "auto-parseable-response-format", enumerable: false }, $parseRaw: { value: t11, enumerable: false } }), r11;
          }({ type: "json_schema", json_schema: { description: e10.json_schema.description, name: r10, strict: true, schema: aA(t10, { name: r10 }) } }, (e11) => t10.parse(JSON.parse(e11)));
        }
        return e10;
      }
      invocationParams(e10, t10) {
        let r10;
        e10?.strict !== void 0 ? r10 = e10.strict : void 0 !== this.supportsStrictToolCalling && (r10 = this.supportsStrictToolCalling);
        let a2 = {};
        e10?.stream_options !== void 0 ? a2 = { stream_options: e10.stream_options } : this.streamUsage && (this.streaming || t10?.streaming) && (a2 = { stream_options: { include_usage: true } });
        let n2 = { model: this.model, temperature: this.temperature, top_p: this.topP, frequency_penalty: this.frequencyPenalty, presence_penalty: this.presencePenalty, max_tokens: -1 === this.maxTokens ? void 0 : this.maxTokens, logprobs: this.logprobs, top_logprobs: this.topLogprobs, n: this.n, logit_bias: this.logitBias, stop: e10?.stop ?? this.stopSequences, user: this.user, stream: this.streaming, functions: e10?.functions, function_call: e10?.function_call, tools: e10?.tools?.length ? e10.tools.map((e11) => aj(e11, { strict: r10 })) : void 0, tool_choice: function(e11) {
          if (e11)
            return "any" === e11 || "required" === e11 ? "required" : "auto" === e11 ? "auto" : "none" === e11 ? "none" : "string" == typeof e11 ? { type: "function", function: { name: e11 } } : e11;
        }(e10?.tool_choice), response_format: this.createResponseFormat(e10?.response_format), seed: e10?.seed, ...a2, parallel_tool_calls: e10?.parallel_tool_calls, ...this.audio || e10?.audio ? { audio: this.audio || e10?.audio } : {}, ...this.modalities || e10?.modalities ? { modalities: this.modalities || e10?.modalities } : {}, ...this.modelKwargs };
        return e10?.prediction !== void 0 && (n2.prediction = e10.prediction), n2;
      }
      _identifyingParams() {
        return { model_name: this.model, ...this.invocationParams(), ...this.clientConfig };
      }
      async *_streamResponseChunks(e10, t10, r10) {
        let a2, n2;
        let i2 = a$(e10), s2 = { ...this.invocationParams(t10, { streaming: true }), messages: i2, stream: true };
        for await (let e11 of await this.completionWithRetry(s2, t10)) {
          let i3 = e11?.choices?.[0];
          if (e11.usage && (n2 = e11.usage), !i3)
            continue;
          let { delta: s3 } = i3;
          if (!s3)
            continue;
          let o2 = function(e12, t11, r11, a3) {
            let n3;
            let i4 = e12.role ?? r11, s4 = e12.content ?? "";
            n3 = e12.function_call ? { function_call: e12.function_call } : e12.tool_calls ? { tool_calls: e12.tool_calls } : {}, a3 && (n3.__raw_response = t11), e12.audio && (n3.audio = { ...e12.audio, index: t11.choices[0].index });
            let o3 = { usage: { ...t11.usage } };
            if ("user" === i4)
              return new rZ.ro({ content: s4, response_metadata: o3 });
            if ("assistant" === i4) {
              let r12 = [];
              if (Array.isArray(e12.tool_calls))
                for (let t12 of e12.tool_calls)
                  r12.push({ name: t12.function?.name, args: t12.function?.arguments, id: t12.id, index: t12.index, type: "tool_call_chunk" });
              return new rZ.GC({ content: s4, tool_call_chunks: r12, additional_kwargs: n3, id: t11.id, response_metadata: o3 });
            }
            return "system" === i4 ? new rZ.xq({ content: s4, response_metadata: o3 }) : "function" === i4 ? new rZ.Cr({ content: s4, additional_kwargs: n3, name: e12.name, response_metadata: o3 }) : "tool" === i4 ? new rZ.Xz({ content: s4, additional_kwargs: n3, tool_call_id: e12.tool_call_id, response_metadata: o3 }) : new rZ.HD({ content: s4, role: i4, response_metadata: o3 });
          }(s3, e11, a2, this.__includeRawResponse);
          a2 = s3.role ?? a2;
          let l2 = { prompt: t10.promptIndex ?? 0, completion: i3.index ?? 0 };
          if ("string" != typeof o2.content) {
            console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
            continue;
          }
          let u2 = { ...l2 };
          null != i3.finish_reason && (u2.finish_reason = i3.finish_reason, u2.system_fingerprint = e11.system_fingerprint), this.logprobs && (u2.logprobs = i3.logprobs);
          let c2 = new rG.Ls({ message: o2, text: o2.content, generationInfo: u2 });
          yield c2, await r10?.handleLLMNewToken(c2.text ?? "", l2, void 0, void 0, void 0, { chunk: c2 });
        }
        if (n2) {
          let e11 = { ...n2.prompt_tokens_details?.audio_tokens !== null && { audio: n2.prompt_tokens_details?.audio_tokens }, ...n2.prompt_tokens_details?.cached_tokens !== null && { cache_read: n2.prompt_tokens_details?.cached_tokens } }, t11 = { ...n2.completion_tokens_details?.audio_tokens !== null && { audio: n2.completion_tokens_details?.audio_tokens }, ...n2.completion_tokens_details?.reasoning_tokens !== null && { reasoning: n2.completion_tokens_details?.reasoning_tokens } }, r11 = new rG.Ls({ message: new rZ.GC({ content: "", response_metadata: { usage: { ...n2 } }, usage_metadata: { input_tokens: n2.prompt_tokens, output_tokens: n2.completion_tokens, total_tokens: n2.total_tokens, ...Object.keys(e11).length > 0 && { input_token_details: e11 }, ...Object.keys(t11).length > 0 && { output_token_details: t11 } } }), text: "" });
          yield r11;
        }
        if (t10.signal?.aborted)
          throw Error("AbortError");
      }
      identifyingParams() {
        return this._identifyingParams();
      }
      async _generate(e10, t10, r10) {
        let a2 = {}, n2 = this.invocationParams(t10), i2 = a$(e10);
        if (n2.stream) {
          let n3 = this._streamResponseChunks(e10, t10, r10), i3 = {};
          for await (let e11 of n3) {
            e11.message.response_metadata = { ...e11.generationInfo, ...e11.message.response_metadata };
            let t11 = e11.generationInfo?.completion ?? 0;
            void 0 === i3[t11] ? i3[t11] = e11 : i3[t11] = i3[t11].concat(e11);
          }
          let s2 = Object.entries(i3).sort(([e11], [t11]) => parseInt(e11, 10) - parseInt(t11, 10)).map(([e11, t11]) => t11), { functions: o2, function_call: l2 } = this.invocationParams(t10), u2 = await this.getEstimatedTokenCountFromPrompt(e10, o2, l2), c2 = await this.getNumTokensFromGenerations(s2);
          return a2.input_tokens = u2, a2.output_tokens = c2, a2.total_tokens = u2 + c2, { generations: s2, llmOutput: { estimatedTokenUsage: { promptTokens: a2.input_tokens, completionTokens: a2.output_tokens, totalTokens: a2.total_tokens } } };
        }
        {
          let e11;
          e11 = t10.response_format && "json_schema" === t10.response_format.type ? await this.betaParsedCompletionWithRetry({ ...n2, stream: false, messages: i2 }, { signal: t10?.signal, ...t10?.options }) : await this.completionWithRetry({ ...n2, stream: false, messages: i2 }, { signal: t10?.signal, ...t10?.options });
          let { completion_tokens: r11, prompt_tokens: s2, total_tokens: o2, prompt_tokens_details: l2, completion_tokens_details: u2 } = e11?.usage ?? {};
          r11 && (a2.output_tokens = (a2.output_tokens ?? 0) + r11), s2 && (a2.input_tokens = (a2.input_tokens ?? 0) + s2), o2 && (a2.total_tokens = (a2.total_tokens ?? 0) + o2), (l2?.audio_tokens !== null || l2?.cached_tokens !== null) && (a2.input_token_details = { ...l2?.audio_tokens !== null && { audio: l2?.audio_tokens }, ...l2?.cached_tokens !== null && { cache_read: l2?.cached_tokens } }), (u2?.audio_tokens !== null || u2?.reasoning_tokens !== null) && (a2.output_token_details = { ...u2?.audio_tokens !== null && { audio: u2?.audio_tokens }, ...u2?.reasoning_tokens !== null && { reasoning: u2?.reasoning_tokens } });
          let c2 = [];
          for (let t11 of e11?.choices ?? []) {
            let r12 = { text: t11.message?.content ?? "", message: function(e12, t12, r13) {
              let a3 = e12.tool_calls;
              if ("assistant" === e12.role) {
                let i3;
                let s3 = [], o3 = [];
                for (let e13 of a3 ?? [])
                  try {
                    s3.push(r2(e13, { returnId: true }));
                  } catch (t13) {
                    var n3;
                    o3.push((n3 = t13.message, { name: e13.function?.name, args: e13.function?.arguments, id: e13.id, error: n3, type: "invalid_tool_call" }));
                  }
                let l3 = { function_call: e12.function_call, tool_calls: a3 };
                return void 0 !== r13 && (l3.__raw_response = t12), t12.system_fingerprint && (i3 = { usage: { ...t12.usage }, system_fingerprint: t12.system_fingerprint }), e12.audio && (l3.audio = e12.audio), new rZ.gY({ content: e12.content || "", tool_calls: s3, invalid_tool_calls: o3, additional_kwargs: l3, response_metadata: i3, id: t12.id });
              }
              return new rZ.J(e12.content || "", e12.role ?? "unknown");
            }(t11.message ?? { role: "assistant" }, e11, this.__includeRawResponse) };
            r12.generationInfo = { ...t11.finish_reason ? { finish_reason: t11.finish_reason } : {}, ...t11.logprobs ? { logprobs: t11.logprobs } : {} }, (0, rZ.Z0)(r12.message) && (r12.message.usage_metadata = a2), r12.message = new rZ.gY({ ...r12.message }), c2.push(r12);
          }
          return { generations: c2, llmOutput: { tokenUsage: { promptTokens: a2.input_tokens, completionTokens: a2.output_tokens, totalTokens: a2.total_tokens } } };
        }
      }
      async getEstimatedTokenCountFromPrompt(e10, t10, r10) {
        let a2 = (await this.getNumTokensFromMessages(e10)).totalCount;
        if (t10 && "auto" !== r10) {
          let e11 = function(e12) {
            let t11 = ["namespace functions {", ""];
            for (let r11 of e12)
              r11.description && t11.push(`// ${r11.description}`), Object.keys(r11.parameters.properties ?? {}).length > 0 ? (t11.push(`type ${r11.name} = (_: {`), t11.push(aI(r11.parameters, 0)), t11.push("}) => any;")) : t11.push(`type ${r11.name} = () => any;`), t11.push("");
            return t11.push("} // namespace functions"), t11.join("\n");
          }(t10);
          a2 += await this.getNumTokens(e11) + 9;
        }
        return t10 && e10.find((e11) => "system" === e11._getType()) && (a2 -= 4), "none" === r10 ? a2 += 1 : "object" == typeof r10 && (a2 += await this.getNumTokens(r10.name) + 4), a2;
      }
      async getNumTokensFromGenerations(e10) {
        return (await Promise.all(e10.map(async (e11) => e11.message.additional_kwargs?.function_call ? (await this.getNumTokensFromMessages([e11.message])).countPerMessage[0] : await this.getNumTokens(e11.message.content)))).reduce((e11, t10) => e11 + t10, 0);
      }
      async getNumTokensFromMessages(e10) {
        let t10 = 0, r10 = 0, a2 = 0;
        "gpt-3.5-turbo-0301" === this.model ? (r10 = 4, a2 = -1) : (r10 = 3, a2 = 1);
        let n2 = await Promise.all(e10.map(async (e11) => {
          let n3 = await this.getNumTokens(e11.content), i2 = await this.getNumTokens(aN(e11)), s2 = void 0 !== e11.name ? a2 + await this.getNumTokens(e11.name) : 0, o2 = n3 + r10 + i2 + s2;
          if ("function" === e11._getType() && (o2 -= 2), e11.additional_kwargs?.function_call && (o2 += 3), e11?.additional_kwargs.function_call?.name && (o2 += await this.getNumTokens(e11.additional_kwargs.function_call?.name)), e11.additional_kwargs.function_call?.arguments)
            try {
              o2 += await this.getNumTokens(JSON.stringify(JSON.parse(e11.additional_kwargs.function_call?.arguments)));
            } catch (t11) {
              console.error("Error parsing function arguments", t11, JSON.stringify(e11.additional_kwargs.function_call)), o2 += await this.getNumTokens(e11.additional_kwargs.function_call?.arguments);
            }
          return t10 += o2, o2;
        }));
        return { totalCount: t10 += 3, countPerMessage: n2 };
      }
      async completionWithRetry(e10, t10) {
        let r10 = this._getClientOptions(t10);
        return this.caller.call(async () => {
          try {
            return await this.client.chat.completions.create(e10, r10);
          } catch (e11) {
            throw aC(e11);
          }
        });
      }
      async betaParsedCompletionWithRetry(e10, t10) {
        let r10 = this._getClientOptions(t10);
        return this.caller.call(async () => {
          try {
            return await this.client.beta.chat.completions.parse(e10, r10);
          } catch (e11) {
            throw aC(e11);
          }
        });
      }
      _getClientOptions(e10) {
        if (!this.client) {
          let e11 = ak({ azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName, azureOpenAIApiKey: this.azureOpenAIApiKey, azureOpenAIBasePath: this.azureOpenAIBasePath, baseURL: this.clientConfig.baseURL, azureOpenAIEndpoint: this.azureOpenAIEndpoint }), t11 = { ...this.clientConfig, baseURL: e11, timeout: this.timeout, maxRetries: 0 };
          t11.baseURL || delete t11.baseURL, this.client = new rH(t11);
        }
        let t10 = { ...this.clientConfig, ...e10 };
        return this.azureOpenAIApiKey && (t10.headers = { "api-key": this.azureOpenAIApiKey, ...t10.headers }, t10.query = { "api-version": this.azureOpenAIApiVersion, ...t10.query }), t10;
      }
      _llmType() {
        return "openai";
      }
      _combineLLMOutput(...e10) {
        return e10.reduce((e11, t10) => (t10 && t10.tokenUsage && (e11.tokenUsage.completionTokens += t10.tokenUsage.completionTokens ?? 0, e11.tokenUsage.promptTokens += t10.tokenUsage.promptTokens ?? 0, e11.tokenUsage.totalTokens += t10.tokenUsage.totalTokens ?? 0), e11), { tokenUsage: { completionTokens: 0, promptTokens: 0, totalTokens: 0 } });
      }
      withStructuredOutput(e10, t10) {
        let r10, a2, n2, i2, s2, o2;
        if (void 0 !== e10 && "object" == typeof e10.schema ? (r10 = e10.schema, a2 = e10.name, n2 = e10.method, i2 = e10.includeRaw) : (r10 = e10, a2 = t10?.name, n2 = t10?.method, i2 = t10?.includeRaw), t10?.strict !== void 0 && "jsonMode" === n2)
          throw Error("Argument `strict` is only supported for `method` = 'function_calling'");
        if ("jsonMode" === n2)
          s2 = this.bind({ response_format: { type: "json_object" } }), o2 = aM(r10) ? rX.K.fromZodSchema(r10) : new rX.Qh();
        else if ("jsonSchema" === n2)
          s2 = this.bind({ response_format: { type: "json_schema", json_schema: { name: a2 ?? "extract", description: r10.description, schema: r10, strict: t10?.strict } } }), o2 = aM(r10) ? rX.K.fromZodSchema(r10) : new rX.Qh();
        else {
          let e11 = a2 ?? "extract";
          if (aM(r10)) {
            let a3 = (0, r5.Y_)(r10);
            s2 = this.bind({ tools: [{ type: "function", function: { name: e11, description: a3.description, parameters: a3 } }], tool_choice: { type: "function", function: { name: e11 } }, ...t10?.strict !== void 0 ? { strict: t10.strict } : {} }), o2 = new r3({ returnSingle: true, keyName: e11, zodSchema: r10 });
          } else {
            let a3;
            "string" == typeof r10.name && "object" == typeof r10.parameters && null != r10.parameters ? (a3 = r10, e11 = r10.name) : a3 = { name: e11 = r10.title ?? e11, description: r10.description ?? "", parameters: r10 }, s2 = this.bind({ tools: [{ type: "function", function: a3 }], tool_choice: { type: "function", function: { name: e11 } }, ...t10?.strict !== void 0 ? { strict: t10.strict } : {} }), o2 = new r3({ returnSingle: true, keyName: e11 });
          }
        }
        if (!i2)
          return s2.pipe(o2);
        let l2 = rK.sk.assign({ parsed: (e11, t11) => o2.invoke(e11.raw, t11) }), u2 = rK.sk.assign({ parsed: () => null }), c2 = l2.withFallbacks({ fallbacks: [u2] });
        return rK.lW.from([{ raw: s2 }, c2]);
      }
    }
    function aM(e10) {
      return "function" == typeof e10?.parse;
    }
    r(7418);
    var aD = r(6890), aU = r(7714);
    class aF extends aU.Embeddings {
      constructor(e10, t10) {
        let r10 = { maxConcurrency: 2, ...e10 };
        super(r10), Object.defineProperty(this, "modelName", { enumerable: true, configurable: true, writable: true, value: "text-embedding-ada-002" }), Object.defineProperty(this, "model", { enumerable: true, configurable: true, writable: true, value: "text-embedding-ada-002" }), Object.defineProperty(this, "batchSize", { enumerable: true, configurable: true, writable: true, value: 512 }), Object.defineProperty(this, "stripNewLines", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "dimensions", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "timeout", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiVersion", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureADTokenProvider", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiInstanceName", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIApiDeploymentName", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "azureOpenAIBasePath", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "organization", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientConfig", { enumerable: true, configurable: true, writable: true, value: void 0 });
        let a2 = r10?.apiKey ?? r10?.openAIApiKey ?? (0, rV.getEnvironmentVariable)("OPENAI_API_KEY"), n2 = r10?.azureOpenAIApiKey ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_KEY");
        if (this.azureADTokenProvider = e10?.azureADTokenProvider ?? void 0, !n2 && !a2 && !this.azureADTokenProvider)
          throw Error("OpenAI or Azure OpenAI API key or Token Provider not found");
        let i2 = r10?.azureOpenAIApiInstanceName ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_INSTANCE_NAME"), s2 = (r10?.azureOpenAIApiEmbeddingsDeploymentName || r10?.azureOpenAIApiDeploymentName) ?? ((0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_EMBEDDINGS_DEPLOYMENT_NAME") || (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_DEPLOYMENT_NAME")), o2 = r10?.azureOpenAIApiVersion ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_API_VERSION");
        if (this.azureOpenAIBasePath = r10?.azureOpenAIBasePath ?? (0, rV.getEnvironmentVariable)("AZURE_OPENAI_BASE_PATH"), this.organization = r10?.configuration?.organization ?? (0, rV.getEnvironmentVariable)("OPENAI_ORGANIZATION"), this.modelName = r10?.model ?? r10?.modelName ?? this.model, this.model = this.modelName, this.batchSize = r10?.batchSize ?? (n2 ? 1 : this.batchSize), this.stripNewLines = r10?.stripNewLines ?? this.stripNewLines, this.timeout = r10?.timeout, this.dimensions = r10?.dimensions, this.azureOpenAIApiVersion = o2, this.azureOpenAIApiKey = n2, this.azureOpenAIApiInstanceName = i2, this.azureOpenAIApiDeploymentName = s2, this.azureOpenAIApiKey || this.azureADTokenProvider) {
          if (!this.azureOpenAIApiInstanceName && !this.azureOpenAIBasePath)
            throw Error("Azure OpenAI API instance name not found");
          if (!this.azureOpenAIApiDeploymentName)
            throw Error("Azure OpenAI API deployment name not found");
          if (!this.azureOpenAIApiVersion)
            throw Error("Azure OpenAI API version not found");
          a2 = a2 ?? "";
        }
        this.clientConfig = { apiKey: a2, organization: this.organization, baseURL: t10?.basePath, dangerouslyAllowBrowser: true, defaultHeaders: t10?.baseOptions?.headers, defaultQuery: t10?.baseOptions?.params, ...t10, ...e10?.configuration };
      }
      async embedDocuments(e10) {
        let t10 = (0, aD.chunkArray)(this.stripNewLines ? e10.map((e11) => e11.replace(/\n/g, " ")) : e10, this.batchSize), r10 = t10.map((e11) => {
          let t11 = { model: this.model, input: e11 };
          return this.dimensions && (t11.dimensions = this.dimensions), this.embeddingWithRetry(t11);
        }), a2 = await Promise.all(r10), n2 = [];
        for (let e11 = 0; e11 < a2.length; e11 += 1) {
          let r11 = t10[e11], { data: i2 } = a2[e11];
          for (let e12 = 0; e12 < r11.length; e12 += 1)
            n2.push(i2[e12].embedding);
        }
        return n2;
      }
      async embedQuery(e10) {
        let t10 = { model: this.model, input: this.stripNewLines ? e10.replace(/\n/g, " ") : e10 };
        this.dimensions && (t10.dimensions = this.dimensions);
        let { data: r10 } = await this.embeddingWithRetry(t10);
        return r10[0].embedding;
      }
      async embeddingWithRetry(e10) {
        if (!this.client) {
          let e11 = ak({ azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName, azureOpenAIApiKey: this.azureOpenAIApiKey, azureOpenAIBasePath: this.azureOpenAIBasePath, baseURL: this.clientConfig.baseURL }), t11 = { ...this.clientConfig, baseURL: e11, timeout: this.timeout, maxRetries: 0 };
          t11.baseURL || delete t11.baseURL, this.client = new rH(t11);
        }
        let t10 = {};
        return this.azureOpenAIApiKey && (t10.headers = { "api-key": this.azureOpenAIApiKey, ...t10.headers }, t10.query = { "api-version": this.azureOpenAIApiVersion, ...t10.query }), this.caller.call(async () => {
          try {
            return await this.client.embeddings.create(e10, t10);
          } catch (e11) {
            throw aC(e11);
          }
        });
      }
    }
    var az = r(3417);
    class aB extends az.UA {
      static lc_name() {
        return "DallEAPIWrapper";
      }
      constructor(e10) {
        e10?.responseFormat !== void 0 && ["url", "b64_json"].includes(e10.responseFormat) && (e10.dallEResponseFormat = e10.responseFormat, e10.responseFormat = "content"), super(e10), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "dalle_api_wrapper" }), Object.defineProperty(this, "description", { enumerable: true, configurable: true, writable: true, value: "A wrapper around OpenAI DALL-E API. Useful for when you need to generate images from a text description. Input should be an image description." }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "model", { enumerable: true, configurable: true, writable: true, value: "dall-e-3" }), Object.defineProperty(this, "style", { enumerable: true, configurable: true, writable: true, value: "vivid" }), Object.defineProperty(this, "quality", { enumerable: true, configurable: true, writable: true, value: "standard" }), Object.defineProperty(this, "n", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "size", { enumerable: true, configurable: true, writable: true, value: "1024x1024" }), Object.defineProperty(this, "dallEResponseFormat", { enumerable: true, configurable: true, writable: true, value: "url" }), Object.defineProperty(this, "user", { enumerable: true, configurable: true, writable: true, value: void 0 });
        let t10 = { apiKey: e10?.apiKey ?? e10?.openAIApiKey ?? (0, rV.getEnvironmentVariable)("OPENAI_API_KEY"), organization: e10?.organization ?? (0, rV.getEnvironmentVariable)("OPENAI_ORGANIZATION"), dangerouslyAllowBrowser: true, baseUrl: e10?.baseUrl };
        this.client = new rH(t10), this.model = e10?.model ?? e10?.modelName ?? this.model, this.style = e10?.style ?? this.style, this.quality = e10?.quality ?? this.quality, this.n = e10?.n ?? this.n, this.size = e10?.size ?? this.size, this.dallEResponseFormat = e10?.dallEResponseFormat ?? this.dallEResponseFormat, this.user = e10?.user;
      }
      processMultipleGeneratedUrls(e10) {
        return "url" === this.dallEResponseFormat ? e10.flatMap((e11) => e11.data.flatMap((e12) => e12.url ? { type: "image_url", image_url: e12.url } : []).filter((e12) => void 0 !== e12 && "image_url" === e12.type && "string" == typeof e12.image_url && void 0 !== e12.image_url)) : e10.flatMap((e11) => e11.data.flatMap((e12) => e12.b64_json ? { type: "image_url", image_url: { url: e12.b64_json } } : []).filter((e12) => void 0 !== e12 && "image_url" === e12.type && "object" == typeof e12.image_url && "url" in e12.image_url && "string" == typeof e12.image_url.url && void 0 !== e12.image_url.url));
      }
      async _call(e10) {
        let t10 = { model: this.model, prompt: e10, n: 1, size: this.size, response_format: this.dallEResponseFormat, style: this.style, quality: this.quality, user: this.user };
        if (this.n > 1) {
          let e11 = await Promise.all(Array.from({ length: this.n }).map(() => this.client.images.generate(t10)));
          return this.processMultipleGeneratedUrls(e11);
        }
        let r10 = await this.client.images.generate(t10), a2 = "";
        return "url" === this.dallEResponseFormat ? [a2] = r10.data.map((e11) => e11.url).filter((e11) => "undefined" !== e11) : [a2] = r10.data.map((e11) => e11.b64_json).filter((e11) => "undefined" !== e11), a2;
      }
    }
    Object.defineProperty(aB, "toolName", { enumerable: true, configurable: true, writable: true, value: "dalle_api_wrapper" });
  };
  __namedExportsObject["__chunk_3406"] = (e, t, r) => {
    "use strict";
    r.d(t, { iW: () => a.isLangChainTool, sU: () => a.convertToOpenAIFunction });
    var a = r(4194);
  };
  __namedExportsObject["__chunk_3417"] = (e, t, r) => {
    "use strict";
    r.d(t, { UA: () => a.Tool, XQ: () => a.DynamicStructuredTool });
    var a = r(5434);
  };
  __namedExportsObject["__chunk_3050"] = (e, t, r) => {
    "use strict";
    r.d(t, { LE: () => a.ensureConfig, Le: () => a.getCallbackManagerForConfig, Y8: () => a.RunnableLambda, eq: () => a.Runnable, k9: () => a._coerceToRunnable, lW: () => a.RunnableSequence, pX: () => a.RunnableBinding, q: () => a.patchConfig, sk: () => a.RunnablePassthrough, t8: () => a.mergeConfigs });
    var a = r(3874);
  };
  __namedExportsObject["__chunk_3285"] = (e, t, r) => {
    "use strict";
    r.d(t, { Ls: () => a.ChatGenerationChunk, WH: () => a.RUN_KEY, b6: () => a.GenerationChunk });
    var a = r(3926);
  };
  __namedExportsObject["__chunk_4336"] = (e, t, r) => {
    "use strict";
    r.d(t, { AN: () => a.StringOutputParser, Bi: () => a.BytesOutputParser, GV: () => a.BaseTransformOutputParser, K: () => a.StructuredOutputParser, Qh: () => a.JsonOutputParser, bI: () => a.BaseOutputParser, dS: () => a.OutputParserException, gP: () => a.parsePartialJson, gq: () => a.BaseCumulativeTransformOutputParser, tw: () => a.BaseLLMOutputParser });
    var a = r(1272);
  };
  __namedExportsObject["__chunk_9279"] = (e, t, r) => {
    "use strict";
    r.d(t, { Cq: () => a.ToolMessage, Cr: () => a.FunctionMessageChunk, E1: () => a.coerceMessageLikeToMessage, GC: () => a.AIMessageChunk, HD: () => a.ChatMessageChunk, J: () => a.ChatMessage, QW: () => a.isBaseMessage, Xz: () => a.ToolMessageChunk, Z0: () => a.isAIMessage, gY: () => a.AIMessage, jN: () => a.SystemMessage, ro: () => a.HumanMessageChunk, xk: () => a.HumanMessage, xq: () => a.SystemMessageChunk });
    var a = r(9730);
  };
  __namedExportsObject["__chunk_9904"] = (e, t, r) => {
    "use strict";
    r.d(t, { BD: () => a.BaseLangChain, F1: () => a.calculateMaxTokens, er: () => a.isOpenAITool, qV: () => a.BaseLanguageModel });
    var a = r(8718);
  };
  __namedExportsObject["__chunk_1742"] = (e, t, r) => {
    "use strict";
    function a(e2) {
      return "function" == typeof e2?.parse;
    }
    r.d(t, { F: () => a });
  };
  __namedExportsObject["__chunk_1930"] = (e, t, r) => {
    "use strict";
    let a, n, i, s;
    r.r(t), r.d(t, { encodingForModel: () => f, getEncoding: () => p });
    var o = r(8566), l = Object.defineProperty, u = class {
      specialTokens;
      inverseSpecialTokens;
      patStr;
      textEncoder = new TextEncoder();
      textDecoder = new TextDecoder("utf-8");
      rankMap = /* @__PURE__ */ new Map();
      textMap = /* @__PURE__ */ new Map();
      constructor(e2, t2) {
        for (let [t3, r2] of (this.patStr = e2.pat_str, Object.entries(e2.bpe_ranks.split("\n").filter(Boolean).reduce((e3, t4) => {
          let [r3, a2, ...n2] = t4.split(" "), i2 = Number.parseInt(a2, 10);
          return n2.forEach((t5, r4) => e3[t5] = i2 + r4), e3;
        }, {})))) {
          let e3 = o.toByteArray(t3);
          this.rankMap.set(e3.join(","), r2), this.textMap.set(r2, e3);
        }
        this.specialTokens = { ...e2.special_tokens, ...t2 }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((e3, [t3, r2]) => (e3[r2] = this.textEncoder.encode(t3), e3), {});
      }
      encode(e2, t2 = [], r2 = "all") {
        let a2 = RegExp(this.patStr, "ug"), n2 = u.specialTokenRegex(Object.keys(this.specialTokens)), i2 = [], s2 = new Set("all" === t2 ? Object.keys(this.specialTokens) : t2), o2 = new Set("all" === r2 ? Object.keys(this.specialTokens).filter((e3) => !s2.has(e3)) : r2);
        if (o2.size > 0) {
          let t3 = u.specialTokenRegex([...o2]), r3 = e2.match(t3);
          if (null != r3)
            throw Error(`The text contains a special token that is not allowed: ${r3[0]}`);
        }
        let l2 = 0;
        for (; ; ) {
          let t3 = null, r3 = l2;
          for (; n2.lastIndex = r3, !(null == (t3 = n2.exec(e2)) || s2.has(t3[0])); )
            r3 = t3.index + 1;
          let o3 = t3?.index ?? e2.length;
          for (let t4 of e2.substring(l2, o3).matchAll(a2)) {
            let e3 = this.textEncoder.encode(t4[0]), r4 = this.rankMap.get(e3.join(","));
            if (null != r4) {
              i2.push(r4);
              continue;
            }
            i2.push(...function(e4, t5) {
              return 1 === e4.length ? [t5.get(e4.join(","))] : function(e5, t6) {
                let r5 = Array.from({ length: e5.length }, (e6, t7) => ({ start: t7, end: t7 + 1 }));
                for (; r5.length > 1; ) {
                  let a3 = null;
                  for (let n3 = 0; n3 < r5.length - 1; n3++) {
                    let i3 = e5.slice(r5[n3].start, r5[n3 + 1].end), s3 = t6.get(i3.join(","));
                    null != s3 && (null == a3 || s3 < a3[0]) && (a3 = [s3, n3]);
                  }
                  if (null != a3) {
                    let e6 = a3[1];
                    r5[e6] = { start: r5[e6].start, end: r5[e6 + 1].end }, r5.splice(e6 + 1, 1);
                  } else
                    break;
                }
                return r5;
              }(e4, t5).map((r5) => t5.get(e4.slice(r5.start, r5.end).join(","))).filter((e5) => null != e5);
            }(e3, this.rankMap));
          }
          if (null == t3)
            break;
          let u2 = this.specialTokens[t3[0]];
          i2.push(u2), l2 = t3.index + t3[0].length;
        }
        return i2;
      }
      decode(e2) {
        let t2 = [], r2 = 0;
        for (let a3 = 0; a3 < e2.length; ++a3) {
          let n3 = e2[a3], i2 = this.textMap.get(n3) ?? this.inverseSpecialTokens[n3];
          null != i2 && (t2.push(i2), r2 += i2.length);
        }
        let a2 = new Uint8Array(r2), n2 = 0;
        for (let e3 of t2)
          a2.set(e3, n2), n2 += e3.length;
        return this.textDecoder.decode(a2);
      }
    };
    n = u, i = "symbol" != typeof (a = "specialTokenRegex") ? a + "" : a, s = (e2) => RegExp(e2.map((e3) => e3.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")).join("|"), "g"), i in n ? l(n, i, { enumerable: true, configurable: true, writable: true, value: s }) : n[i] = s;
    var c = r(1550);
    let d = {}, h = new c.AsyncCaller({});
    async function p(e2) {
      return e2 in d || (d[e2] = h.fetch(`https://tiktoken.pages.dev/js/${e2}.json`).then((e3) => e3.json()).then((e3) => new u(e3)).catch((t2) => {
        throw delete d[e2], t2;
      })), await d[e2];
    }
    async function f(e2) {
      return p(function(e3) {
        switch (e3) {
          case "gpt2":
            return "gpt2";
          case "code-cushman-001":
          case "code-cushman-002":
          case "code-davinci-001":
          case "code-davinci-002":
          case "cushman-codex":
          case "davinci-codex":
          case "davinci-002":
          case "text-davinci-002":
          case "text-davinci-003":
            return "p50k_base";
          case "code-davinci-edit-001":
          case "text-davinci-edit-001":
            return "p50k_edit";
          case "ada":
          case "babbage":
          case "babbage-002":
          case "code-search-ada-code-001":
          case "code-search-babbage-code-001":
          case "curie":
          case "davinci":
          case "text-ada-001":
          case "text-babbage-001":
          case "text-curie-001":
          case "text-davinci-001":
          case "text-search-ada-doc-001":
          case "text-search-babbage-doc-001":
          case "text-search-curie-doc-001":
          case "text-search-davinci-doc-001":
          case "text-similarity-ada-001":
          case "text-similarity-babbage-001":
          case "text-similarity-curie-001":
          case "text-similarity-davinci-001":
            return "r50k_base";
          case "gpt-3.5-turbo-instruct-0914":
          case "gpt-3.5-turbo-instruct":
          case "gpt-3.5-turbo-16k-0613":
          case "gpt-3.5-turbo-16k":
          case "gpt-3.5-turbo-0613":
          case "gpt-3.5-turbo-0301":
          case "gpt-3.5-turbo":
          case "gpt-4-32k-0613":
          case "gpt-4-32k-0314":
          case "gpt-4-32k":
          case "gpt-4-0613":
          case "gpt-4-0314":
          case "gpt-4":
          case "gpt-3.5-turbo-1106":
          case "gpt-35-turbo":
          case "gpt-4-1106-preview":
          case "gpt-4-vision-preview":
          case "gpt-3.5-turbo-0125":
          case "gpt-4-turbo":
          case "gpt-4-turbo-2024-04-09":
          case "gpt-4-turbo-preview":
          case "gpt-4-0125-preview":
          case "text-embedding-ada-002":
          case "text-embedding-3-small":
          case "text-embedding-3-large":
            return "cl100k_base";
          case "gpt-4o":
          case "gpt-4o-2024-05-13":
          case "gpt-4o-2024-08-06":
          case "gpt-4o-mini-2024-07-18":
          case "gpt-4o-mini":
          case "o1-mini":
          case "o1-preview":
          case "o1-preview-2024-09-12":
          case "o1-mini-2024-09-12":
          case "chatgpt-4o-latest":
          case "gpt-4o-realtime":
          case "gpt-4o-realtime-preview-2024-10-01":
            return "o200k_base";
          default:
            throw Error("Unknown model");
        }
      }(e2));
    }
  };
  __namedExportsObject["__chunk_541"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { AsyncGeneratorWithSetup: () => l, IterableReadableStream: () => s, atee: () => o, concat: () => function e2(t2, r2) {
      if (Array.isArray(t2) && Array.isArray(r2))
        return t2.concat(r2);
      if ("string" == typeof t2 && "string" == typeof r2 || "number" == typeof t2 && "number" == typeof r2)
        return t2 + r2;
      if ("concat" in t2 && "function" == typeof t2.concat)
        return t2.concat(r2);
      if ("object" == typeof t2 && "object" == typeof r2) {
        let a2 = { ...t2 };
        for (let [t3, n2] of Object.entries(r2))
          t3 in a2 && !Array.isArray(a2[t3]) ? a2[t3] = e2(a2[t3], n2) : a2[t3] = n2;
        return a2;
      }
      throw Error(`Cannot concat ${typeof t2} and ${typeof r2}`);
    }, pipeGeneratorWithSetup: () => u });
    var a = r(3735), n = r(647), i = r(2047);
    class s extends ReadableStream {
      constructor() {
        super(...arguments), Object.defineProperty(this, "reader", { enumerable: true, configurable: true, writable: true, value: void 0 });
      }
      ensureReader() {
        this.reader || (this.reader = this.getReader());
      }
      async next() {
        this.ensureReader();
        try {
          let e2 = await this.reader.read();
          if (e2.done)
            return this.reader.releaseLock(), { done: true, value: void 0 };
          return { done: false, value: e2.value };
        } catch (e2) {
          throw this.reader.releaseLock(), e2;
        }
      }
      async return() {
        if (this.ensureReader(), this.locked) {
          let e2 = this.reader.cancel();
          this.reader.releaseLock(), await e2;
        }
        return { done: true, value: void 0 };
      }
      async throw(e2) {
        if (this.ensureReader(), this.locked) {
          let e3 = this.reader.cancel();
          this.reader.releaseLock(), await e3;
        }
        throw e2;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async [Symbol.asyncDispose]() {
        await this.return();
      }
      static fromReadableStream(e2) {
        let t2 = e2.getReader();
        return new s({ start: (e3) => function r2() {
          return t2.read().then(({ done: t3, value: a2 }) => {
            if (t3) {
              e3.close();
              return;
            }
            return e3.enqueue(a2), r2();
          });
        }(), cancel() {
          t2.releaseLock();
        } });
      }
      static fromAsyncGenerator(e2) {
        return new s({ async pull(t2) {
          let { value: r2, done: a2 } = await e2.next();
          a2 && t2.close(), t2.enqueue(r2);
        }, async cancel(t2) {
          await e2.return(t2);
        } });
      }
    }
    function o(e2, t2 = 2) {
      let r2 = Array.from({ length: t2 }, () => []);
      return r2.map(async function* (t3) {
        for (; ; )
          if (0 === t3.length) {
            let t4 = await e2.next();
            for (let e3 of r2)
              e3.push(t4);
          } else {
            if (t3[0].done)
              return;
            yield t3.shift().value;
          }
      });
    }
    class l {
      constructor(e2) {
        Object.defineProperty(this, "generator", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "setup", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "config", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "signal", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "firstResult", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "firstResultUsed", { enumerable: true, configurable: true, writable: true, value: false }), this.generator = e2.generator, this.config = e2.config, this.signal = e2.signal ?? this.config?.signal, this.setup = new Promise((t2, r2) => {
          n.AO.runWithConfig((0, a.yG)(e2.config), async () => {
            this.firstResult = e2.generator.next(), e2.startSetup ? this.firstResult.then(e2.startSetup).then(t2, r2) : this.firstResult.then((e3) => t2(void 0), r2);
          }, true);
        });
      }
      async next(...e2) {
        return (this.signal?.throwIfAborted(), this.firstResultUsed) ? n.AO.runWithConfig((0, a.yG)(this.config), this.signal ? async () => (0, i.E)(this.generator.next(...e2), this.signal) : async () => this.generator.next(...e2), true) : (this.firstResultUsed = true, this.firstResult);
      }
      async return(e2) {
        return this.generator.return(e2);
      }
      async throw(e2) {
        return this.generator.throw(e2);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async [Symbol.asyncDispose]() {
        await this.return();
      }
    }
    async function u(e2, t2, r2, a2, ...n2) {
      let i2 = new l({ generator: t2, startSetup: r2, signal: a2 }), s2 = await i2.setup;
      return { output: e2(i2, s2, ...n2), setup: s2 };
    }
  };
  __namedExportsObject["__chunk_2047"] = (e, t, r) => {
    "use strict";
    async function a(e2, t2) {
      let r2;
      return void 0 === t2 ? e2 : Promise.race([e2.catch((e3) => {
        if (!t2?.aborted)
          throw e3;
      }), new Promise((e3, a2) => {
        r2 = () => {
          a2(Error("Aborted"));
        }, t2.addEventListener("abort", r2), t2.aborted && a2(Error("Aborted"));
      })]).finally(() => t2.removeEventListener("abort", r2));
    }
    r.d(t, { E: () => a });
  };
  __namedExportsObject["__chunk_349"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { applyPatch: () => a.af, compare: () => a.qu });
    var a = r(9363);
  };
  __namedExportsObject["__chunk_5466"] = (e, t, r) => {
    "use strict";
    function a(e2, t2 = n) {
      e2 = e2.trim();
      let r2 = /```(json)?(.*)```/s.exec(e2);
      return t2(r2 ? r2[2] : e2);
    }
    function n(e2) {
      if (void 0 === e2)
        return null;
      try {
        return JSON.parse(e2);
      } catch (e3) {
      }
      let t2 = "", r2 = [], a2 = false, n2 = false;
      for (let i of e2) {
        if (a2)
          '"' !== i || n2 ? "\n" !== i || n2 ? n2 = "\\" === i && !n2 : i = "\\n" : a2 = false;
        else if ('"' === i)
          a2 = true, n2 = false;
        else if ("{" === i)
          r2.push("}");
        else if ("[" === i)
          r2.push("]");
        else if ("}" === i || "]" === i) {
          if (!r2 || r2[r2.length - 1] !== i)
            return null;
          r2.pop();
        }
        t2 += i;
      }
      a2 && (t2 += '"');
      for (let e3 = r2.length - 1; e3 >= 0; e3 -= 1)
        t2 += r2[e3];
      try {
        return JSON.parse(t2);
      } catch (e3) {
        return null;
      }
    }
    r.d(t, { M: () => a, g: () => n });
  };
  __namedExportsObject["__chunk_2110"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { insecureHash: () => u });
    var a = "object" == typeof window ? window : {}, n = "0123456789abcdef".split(""), i = [-2147483648, 8388608, 32768, 128], s = [24, 16, 8, 0], o = [];
    function l(e2) {
      e2 ? (o[0] = o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0, this.blocks = o) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.h0 = 1732584193, this.h1 = 4023233417, this.h2 = 2562383102, this.h3 = 271733878, this.h4 = 3285377520, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false, this.first = true;
    }
    l.prototype.update = function(e2) {
      if (!this.finalized) {
        var t2 = "string" != typeof e2;
        t2 && e2.constructor === a.ArrayBuffer && (e2 = new Uint8Array(e2));
        for (var r2, n2, i2 = 0, o2 = e2.length || 0, l2 = this.blocks; i2 < o2; ) {
          if (this.hashed && (this.hashed = false, l2[0] = this.block, l2[16] = l2[1] = l2[2] = l2[3] = l2[4] = l2[5] = l2[6] = l2[7] = l2[8] = l2[9] = l2[10] = l2[11] = l2[12] = l2[13] = l2[14] = l2[15] = 0), t2)
            for (n2 = this.start; i2 < o2 && n2 < 64; ++i2)
              l2[n2 >> 2] |= e2[i2] << s[3 & n2++];
          else
            for (n2 = this.start; i2 < o2 && n2 < 64; ++i2)
              (r2 = e2.charCodeAt(i2)) < 128 ? l2[n2 >> 2] |= r2 << s[3 & n2++] : (r2 < 2048 ? l2[n2 >> 2] |= (192 | r2 >> 6) << s[3 & n2++] : (r2 < 55296 || r2 >= 57344 ? l2[n2 >> 2] |= (224 | r2 >> 12) << s[3 & n2++] : (r2 = 65536 + ((1023 & r2) << 10 | 1023 & e2.charCodeAt(++i2)), l2[n2 >> 2] |= (240 | r2 >> 18) << s[3 & n2++], l2[n2 >> 2] |= (128 | r2 >> 12 & 63) << s[3 & n2++]), l2[n2 >> 2] |= (128 | r2 >> 6 & 63) << s[3 & n2++]), l2[n2 >> 2] |= (128 | 63 & r2) << s[3 & n2++]);
          this.lastByteIndex = n2, this.bytes += n2 - this.start, n2 >= 64 ? (this.block = l2[16], this.start = n2 - 64, this.hash(), this.hashed = true) : this.start = n2;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, l.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var e2 = this.blocks, t2 = this.lastByteIndex;
        e2[16] = this.block, e2[t2 >> 2] |= i[3 & t2], this.block = e2[16], t2 >= 56 && (this.hashed || this.hash(), e2[0] = this.block, e2[16] = e2[1] = e2[2] = e2[3] = e2[4] = e2[5] = e2[6] = e2[7] = e2[8] = e2[9] = e2[10] = e2[11] = e2[12] = e2[13] = e2[14] = e2[15] = 0), e2[14] = this.hBytes << 3 | this.bytes >>> 29, e2[15] = this.bytes << 3, this.hash();
      }
    }, l.prototype.hash = function() {
      var e2, t2, r2, a2 = this.h0, n2 = this.h1, i2 = this.h2, s2 = this.h3, o2 = this.h4, l2 = this.blocks;
      for (t2 = 16; t2 < 80; ++t2)
        r2 = l2[t2 - 3] ^ l2[t2 - 8] ^ l2[t2 - 14] ^ l2[t2 - 16], l2[t2] = r2 << 1 | r2 >>> 31;
      for (t2 = 0; t2 < 20; t2 += 5)
        e2 = n2 & i2 | ~n2 & s2, o2 = (r2 = a2 << 5 | a2 >>> 27) + e2 + o2 + 1518500249 + l2[t2] << 0, e2 = a2 & (n2 = n2 << 30 | n2 >>> 2) | ~a2 & i2, s2 = (r2 = o2 << 5 | o2 >>> 27) + e2 + s2 + 1518500249 + l2[t2 + 1] << 0, e2 = o2 & (a2 = a2 << 30 | a2 >>> 2) | ~o2 & n2, i2 = (r2 = s2 << 5 | s2 >>> 27) + e2 + i2 + 1518500249 + l2[t2 + 2] << 0, e2 = s2 & (o2 = o2 << 30 | o2 >>> 2) | ~s2 & a2, n2 = (r2 = i2 << 5 | i2 >>> 27) + e2 + n2 + 1518500249 + l2[t2 + 3] << 0, e2 = i2 & (s2 = s2 << 30 | s2 >>> 2) | ~i2 & o2, a2 = (r2 = n2 << 5 | n2 >>> 27) + e2 + a2 + 1518500249 + l2[t2 + 4] << 0, i2 = i2 << 30 | i2 >>> 2;
      for (; t2 < 40; t2 += 5)
        e2 = n2 ^ i2 ^ s2, o2 = (r2 = a2 << 5 | a2 >>> 27) + e2 + o2 + 1859775393 + l2[t2] << 0, e2 = a2 ^ (n2 = n2 << 30 | n2 >>> 2) ^ i2, s2 = (r2 = o2 << 5 | o2 >>> 27) + e2 + s2 + 1859775393 + l2[t2 + 1] << 0, e2 = o2 ^ (a2 = a2 << 30 | a2 >>> 2) ^ n2, i2 = (r2 = s2 << 5 | s2 >>> 27) + e2 + i2 + 1859775393 + l2[t2 + 2] << 0, e2 = s2 ^ (o2 = o2 << 30 | o2 >>> 2) ^ a2, n2 = (r2 = i2 << 5 | i2 >>> 27) + e2 + n2 + 1859775393 + l2[t2 + 3] << 0, e2 = i2 ^ (s2 = s2 << 30 | s2 >>> 2) ^ o2, a2 = (r2 = n2 << 5 | n2 >>> 27) + e2 + a2 + 1859775393 + l2[t2 + 4] << 0, i2 = i2 << 30 | i2 >>> 2;
      for (; t2 < 60; t2 += 5)
        e2 = n2 & i2 | n2 & s2 | i2 & s2, o2 = (r2 = a2 << 5 | a2 >>> 27) + e2 + o2 - 1894007588 + l2[t2] << 0, e2 = a2 & (n2 = n2 << 30 | n2 >>> 2) | a2 & i2 | n2 & i2, s2 = (r2 = o2 << 5 | o2 >>> 27) + e2 + s2 - 1894007588 + l2[t2 + 1] << 0, e2 = o2 & (a2 = a2 << 30 | a2 >>> 2) | o2 & n2 | a2 & n2, i2 = (r2 = s2 << 5 | s2 >>> 27) + e2 + i2 - 1894007588 + l2[t2 + 2] << 0, e2 = s2 & (o2 = o2 << 30 | o2 >>> 2) | s2 & a2 | o2 & a2, n2 = (r2 = i2 << 5 | i2 >>> 27) + e2 + n2 - 1894007588 + l2[t2 + 3] << 0, e2 = i2 & (s2 = s2 << 30 | s2 >>> 2) | i2 & o2 | s2 & o2, a2 = (r2 = n2 << 5 | n2 >>> 27) + e2 + a2 - 1894007588 + l2[t2 + 4] << 0, i2 = i2 << 30 | i2 >>> 2;
      for (; t2 < 80; t2 += 5)
        e2 = n2 ^ i2 ^ s2, o2 = (r2 = a2 << 5 | a2 >>> 27) + e2 + o2 - 899497514 + l2[t2] << 0, e2 = a2 ^ (n2 = n2 << 30 | n2 >>> 2) ^ i2, s2 = (r2 = o2 << 5 | o2 >>> 27) + e2 + s2 - 899497514 + l2[t2 + 1] << 0, e2 = o2 ^ (a2 = a2 << 30 | a2 >>> 2) ^ n2, i2 = (r2 = s2 << 5 | s2 >>> 27) + e2 + i2 - 899497514 + l2[t2 + 2] << 0, e2 = s2 ^ (o2 = o2 << 30 | o2 >>> 2) ^ a2, n2 = (r2 = i2 << 5 | i2 >>> 27) + e2 + n2 - 899497514 + l2[t2 + 3] << 0, e2 = i2 ^ (s2 = s2 << 30 | s2 >>> 2) ^ o2, a2 = (r2 = n2 << 5 | n2 >>> 27) + e2 + a2 - 899497514 + l2[t2 + 4] << 0, i2 = i2 << 30 | i2 >>> 2;
      this.h0 = this.h0 + a2 << 0, this.h1 = this.h1 + n2 << 0, this.h2 = this.h2 + i2 << 0, this.h3 = this.h3 + s2 << 0, this.h4 = this.h4 + o2 << 0;
    }, l.prototype.hex = function() {
      this.finalize();
      var e2 = this.h0, t2 = this.h1, r2 = this.h2, a2 = this.h3, i2 = this.h4;
      return n[e2 >> 28 & 15] + n[e2 >> 24 & 15] + n[e2 >> 20 & 15] + n[e2 >> 16 & 15] + n[e2 >> 12 & 15] + n[e2 >> 8 & 15] + n[e2 >> 4 & 15] + n[15 & e2] + n[t2 >> 28 & 15] + n[t2 >> 24 & 15] + n[t2 >> 20 & 15] + n[t2 >> 16 & 15] + n[t2 >> 12 & 15] + n[t2 >> 8 & 15] + n[t2 >> 4 & 15] + n[15 & t2] + n[r2 >> 28 & 15] + n[r2 >> 24 & 15] + n[r2 >> 20 & 15] + n[r2 >> 16 & 15] + n[r2 >> 12 & 15] + n[r2 >> 8 & 15] + n[r2 >> 4 & 15] + n[15 & r2] + n[a2 >> 28 & 15] + n[a2 >> 24 & 15] + n[a2 >> 20 & 15] + n[a2 >> 16 & 15] + n[a2 >> 12 & 15] + n[a2 >> 8 & 15] + n[a2 >> 4 & 15] + n[15 & a2] + n[i2 >> 28 & 15] + n[i2 >> 24 & 15] + n[i2 >> 20 & 15] + n[i2 >> 16 & 15] + n[i2 >> 12 & 15] + n[i2 >> 8 & 15] + n[i2 >> 4 & 15] + n[15 & i2];
    }, l.prototype.toString = l.prototype.hex, l.prototype.digest = function() {
      this.finalize();
      var e2 = this.h0, t2 = this.h1, r2 = this.h2, a2 = this.h3, n2 = this.h4;
      return [e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2, t2 >> 24 & 255, t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2, r2 >> 24 & 255, r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, a2 >> 24 & 255, a2 >> 16 & 255, a2 >> 8 & 255, 255 & a2, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2];
    }, l.prototype.array = l.prototype.digest, l.prototype.arrayBuffer = function() {
      this.finalize();
      var e2 = new ArrayBuffer(20), t2 = new DataView(e2);
      return t2.setUint32(0, this.h0), t2.setUint32(4, this.h1), t2.setUint32(8, this.h2), t2.setUint32(12, this.h3), t2.setUint32(16, this.h4), e2;
    };
    let u = (e2) => new l(true).update(e2).hex();
  };
  __namedExportsObject["__chunk_4194"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { convertToOpenAIFunction: () => s, convertToOpenAITool: () => o, isLangChainTool: () => d, isRunnableToolLike: () => u, isStructuredTool: () => l, isStructuredToolParams: () => c });
    var a = r(7026), n = r(1184), i = r(1742);
    function s(e2, t2) {
      let r2 = "number" == typeof t2 ? void 0 : t2;
      return { name: e2.name, description: e2.description, parameters: (0, a.Y_)(e2.schema), ...r2?.strict !== void 0 ? { strict: r2.strict } : {} };
    }
    function o(e2, t2) {
      let r2;
      let a2 = "number" == typeof t2 ? void 0 : t2;
      return r2 = d(e2) ? { type: "function", function: s(e2) } : e2, a2?.strict !== void 0 && (r2.function.strict = a2.strict), r2;
    }
    function l(e2) {
      return void 0 !== e2 && Array.isArray(e2.lc_namespace);
    }
    function u(e2) {
      return void 0 !== e2 && n.eq.isRunnable(e2) && "lc_name" in e2.constructor && "function" == typeof e2.constructor.lc_name && "RunnableToolLike" === e2.constructor.lc_name();
    }
    function c(e2) {
      return !!e2 && "object" == typeof e2 && "name" in e2 && "schema" in e2 && (0, i.F)(e2.schema);
    }
    function d(e2) {
      return c(e2) || u(e2) || l(e2);
    }
  };
  __namedExportsObject["__chunk_9363"] = (e, t, r) => {
    "use strict";
    r.d(t, { af: () => b, qu: () => x });
    var a = {};
    r.r(a), r.d(a, { JsonPatchError: () => h, _areEquals: () => E, applyOperation: () => y, applyPatch: () => b, applyReducer: () => v, deepClone: () => p, getValueByPointer: () => g, validate: () => w, validator: () => _ });
    let n = Object.prototype.hasOwnProperty;
    function i(e2, t2) {
      return n.call(e2, t2);
    }
    function s(e2) {
      if (Array.isArray(e2)) {
        let t3 = Array(e2.length);
        for (let e3 = 0; e3 < t3.length; e3++)
          t3[e3] = "" + e3;
        return t3;
      }
      if (Object.keys)
        return Object.keys(e2);
      let t2 = [];
      for (let r2 in e2)
        i(e2, r2) && t2.push(r2);
      return t2;
    }
    function o(e2) {
      switch (typeof e2) {
        case "object":
          return JSON.parse(JSON.stringify(e2));
        case "undefined":
          return null;
        default:
          return e2;
      }
    }
    function l(e2) {
      let t2, r2 = 0, a2 = e2.length;
      for (; r2 < a2; ) {
        if ((t2 = e2.charCodeAt(r2)) >= 48 && t2 <= 57) {
          r2++;
          continue;
        }
        return false;
      }
      return true;
    }
    function u(e2) {
      return -1 === e2.indexOf("/") && -1 === e2.indexOf("~") ? e2 : e2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function c(e2, t2) {
      let r2 = [e2];
      for (let e3 in t2) {
        let a2 = "object" == typeof t2[e3] ? JSON.stringify(t2[e3], null, 2) : t2[e3];
        void 0 !== a2 && r2.push(`${e3}: ${a2}`);
      }
      return r2.join("\n");
    }
    class d extends Error {
      constructor(e2, t2, r2, a2, n2) {
        super(c(e2, { name: t2, index: r2, operation: a2, tree: n2 })), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "index", { enumerable: true, configurable: true, writable: true, value: r2 }), Object.defineProperty(this, "operation", { enumerable: true, configurable: true, writable: true, value: a2 }), Object.defineProperty(this, "tree", { enumerable: true, configurable: true, writable: true, value: n2 }), Object.setPrototypeOf(this, new.target.prototype), this.message = c(e2, { name: t2, index: r2, operation: a2, tree: n2 });
      }
    }
    let h = d, p = o, f = { add: function(e2, t2, r2) {
      return e2[t2] = this.value, { newDocument: r2 };
    }, remove: function(e2, t2, r2) {
      var a2 = e2[t2];
      return delete e2[t2], { newDocument: r2, removed: a2 };
    }, replace: function(e2, t2, r2) {
      var a2 = e2[t2];
      return e2[t2] = this.value, { newDocument: r2, removed: a2 };
    }, move: function(e2, t2, r2) {
      let a2 = g(r2, this.path);
      a2 && (a2 = o(a2));
      let n2 = y(r2, { op: "remove", path: this.from }).removed;
      return y(r2, { op: "add", path: this.path, value: n2 }), { newDocument: r2, removed: a2 };
    }, copy: function(e2, t2, r2) {
      let a2 = g(r2, this.from);
      return y(r2, { op: "add", path: this.path, value: o(a2) }), { newDocument: r2 };
    }, test: function(e2, t2, r2) {
      return { newDocument: r2, test: E(e2[t2], this.value) };
    }, _get: function(e2, t2, r2) {
      return this.value = e2[t2], { newDocument: r2 };
    } };
    var m = { add: function(e2, t2, r2) {
      return l(t2) ? e2.splice(t2, 0, this.value) : e2[t2] = this.value, { newDocument: r2, index: t2 };
    }, remove: function(e2, t2, r2) {
      return { newDocument: r2, removed: e2.splice(t2, 1)[0] };
    }, replace: function(e2, t2, r2) {
      var a2 = e2[t2];
      return e2[t2] = this.value, { newDocument: r2, removed: a2 };
    }, move: f.move, copy: f.copy, test: f.test, _get: f._get };
    function g(e2, t2) {
      if ("" == t2)
        return e2;
      var r2 = { op: "_get", path: t2 };
      return y(e2, r2), r2.value;
    }
    function y(e2, t2, r2 = false, a2 = true, n2 = true, i2 = 0) {
      if (r2 && ("function" == typeof r2 ? r2(t2, 0, e2, t2.path) : _(t2, 0)), "" === t2.path) {
        let a3 = { newDocument: e2 };
        if ("add" === t2.op)
          return a3.newDocument = t2.value, a3;
        if ("replace" === t2.op)
          return a3.newDocument = t2.value, a3.removed = e2, a3;
        if ("move" === t2.op || "copy" === t2.op)
          return a3.newDocument = g(e2, t2.from), "move" === t2.op && (a3.removed = e2), a3;
        if ("test" === t2.op) {
          if (a3.test = E(e2, t2.value), false === a3.test)
            throw new h("Test operation failed", "TEST_OPERATION_FAILED", i2, t2, e2);
          return a3.newDocument = e2, a3;
        } else {
          if ("remove" === t2.op)
            return a3.removed = e2, a3.newDocument = null, a3;
          if ("_get" === t2.op)
            return t2.value = e2, a3;
          if (!r2)
            return a3;
          throw new h("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", i2, t2, e2);
        }
      }
      {
        let s2, u2, c2;
        a2 || (e2 = o(e2));
        let d2 = (t2.path || "").split("/"), p2 = e2, g2 = 1, y2 = d2.length;
        for (u2 = "function" == typeof r2 ? r2 : _; ; ) {
          if ((s2 = d2[g2]) && -1 != s2.indexOf("~") && (s2 = s2.replace(/~1/g, "/").replace(/~0/g, "~")), n2 && ("__proto__" == s2 || "prototype" == s2 && g2 > 0 && "constructor" == d2[g2 - 1]))
            throw TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
          if (r2 && void 0 === c2 && (void 0 === p2[s2] ? c2 = d2.slice(0, g2).join("/") : g2 == y2 - 1 && (c2 = t2.path), void 0 !== c2 && u2(t2, 0, e2, c2)), g2++, Array.isArray(p2)) {
            if ("-" === s2)
              s2 = p2.length;
            else {
              if (r2 && !l(s2))
                throw new h("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", i2, t2, e2);
              l(s2) && (s2 = ~~s2);
            }
            if (g2 >= y2) {
              if (r2 && "add" === t2.op && s2 > p2.length)
                throw new h("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", i2, t2, e2);
              let a3 = m[t2.op].call(t2, p2, s2, e2);
              if (false === a3.test)
                throw new h("Test operation failed", "TEST_OPERATION_FAILED", i2, t2, e2);
              return a3;
            }
          } else if (g2 >= y2) {
            let r3 = f[t2.op].call(t2, p2, s2, e2);
            if (false === r3.test)
              throw new h("Test operation failed", "TEST_OPERATION_FAILED", i2, t2, e2);
            return r3;
          }
          if (p2 = p2[s2], r2 && g2 < y2 && (!p2 || "object" != typeof p2))
            throw new h("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", i2, t2, e2);
        }
      }
    }
    function b(e2, t2, r2, a2 = true, n2 = true) {
      if (r2 && !Array.isArray(t2))
        throw new h("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      a2 || (e2 = o(e2));
      let i2 = Array(t2.length);
      for (let a3 = 0, s2 = t2.length; a3 < s2; a3++)
        i2[a3] = y(e2, t2[a3], r2, true, n2, a3), e2 = i2[a3].newDocument;
      return i2.newDocument = e2, i2;
    }
    function v(e2, t2, r2) {
      let a2 = y(e2, t2);
      if (false === a2.test)
        throw new h("Test operation failed", "TEST_OPERATION_FAILED", r2, t2, e2);
      return a2.newDocument;
    }
    function _(e2, t2, r2, a2) {
      if ("object" != typeof e2 || null === e2 || Array.isArray(e2))
        throw new h("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t2, e2, r2);
      if (f[e2.op]) {
        if ("string" != typeof e2.path)
          throw new h("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t2, e2, r2);
        if (0 !== e2.path.indexOf("/") && e2.path.length > 0)
          throw new h('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t2, e2, r2);
        if (("move" === e2.op || "copy" === e2.op) && "string" != typeof e2.from)
          throw new h("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t2, e2, r2);
        else if (("add" === e2.op || "replace" === e2.op || "test" === e2.op) && void 0 === e2.value)
          throw new h("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t2, e2, r2);
        else if (("add" === e2.op || "replace" === e2.op || "test" === e2.op) && function e3(t3) {
          if (void 0 === t3)
            return true;
          if (t3) {
            if (Array.isArray(t3)) {
              for (let r4 = 0, a3 = t3.length; r4 < a3; r4++)
                if (e3(t3[r4]))
                  return true;
            } else if ("object" == typeof t3) {
              let a3 = s(t3), n3 = a3.length;
              for (var r3 = 0; r3 < n3; r3++)
                if (e3(t3[a3[r3]]))
                  return true;
            }
          }
          return false;
        }(e2.value))
          throw new h("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t2, e2, r2);
        else if (r2) {
          if ("add" == e2.op) {
            var n2 = e2.path.split("/").length, i2 = a2.split("/").length;
            if (n2 !== i2 + 1 && n2 !== i2)
              throw new h("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t2, e2, r2);
          } else if ("replace" === e2.op || "remove" === e2.op || "_get" === e2.op) {
            if (e2.path !== a2)
              throw new h("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t2, e2, r2);
          } else if ("move" === e2.op || "copy" === e2.op) {
            var o2 = w([{ op: "_get", path: e2.from, value: void 0 }], r2);
            if (o2 && "OPERATION_PATH_UNRESOLVABLE" === o2.name)
              throw new h("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t2, e2, r2);
          }
        }
      } else
        throw new h("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t2, e2, r2);
    }
    function w(e2, t2, r2) {
      try {
        if (!Array.isArray(e2))
          throw new h("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
        if (t2)
          b(o(t2), o(e2), r2 || true);
        else {
          r2 = r2 || _;
          for (var a2 = 0; a2 < e2.length; a2++)
            r2(e2[a2], a2, t2, void 0);
        }
      } catch (e3) {
        if (e3 instanceof h)
          return e3;
        throw e3;
      }
    }
    function E(e2, t2) {
      if (e2 === t2)
        return true;
      if (e2 && t2 && "object" == typeof e2 && "object" == typeof t2) {
        var r2, a2, n2, i2 = Array.isArray(e2), s2 = Array.isArray(t2);
        if (i2 && s2) {
          if ((a2 = e2.length) != t2.length)
            return false;
          for (r2 = a2; 0 != r2--; )
            if (!E(e2[r2], t2[r2]))
              return false;
          return true;
        }
        if (i2 != s2)
          return false;
        var o2 = Object.keys(e2);
        if ((a2 = o2.length) !== Object.keys(t2).length)
          return false;
        for (r2 = a2; 0 != r2--; )
          if (!t2.hasOwnProperty(o2[r2]))
            return false;
        for (r2 = a2; 0 != r2--; )
          if (!E(e2[n2 = o2[r2]], t2[n2]))
            return false;
        return true;
      }
      return e2 != e2 && t2 != t2;
    }
    /* @__PURE__ */ new WeakMap();
    function x(e2, t2, r2 = false) {
      var a2 = [];
      return function e3(t3, r3, a3, n2, l2) {
        if (r3 !== t3) {
          "function" == typeof r3.toJSON && (r3 = r3.toJSON());
          for (var c2 = s(r3), d2 = s(t3), h2 = false, p2 = d2.length - 1; p2 >= 0; p2--) {
            var f2 = d2[p2], m2 = t3[f2];
            if (i(r3, f2) && !(void 0 === r3[f2] && void 0 !== m2 && false === Array.isArray(r3))) {
              var g2 = r3[f2];
              "object" == typeof m2 && null != m2 && "object" == typeof g2 && null != g2 && Array.isArray(m2) === Array.isArray(g2) ? e3(m2, g2, a3, n2 + "/" + u(f2), l2) : m2 !== g2 && (l2 && a3.push({ op: "test", path: n2 + "/" + u(f2), value: o(m2) }), a3.push({ op: "replace", path: n2 + "/" + u(f2), value: o(g2) }));
            } else
              Array.isArray(t3) === Array.isArray(r3) ? (l2 && a3.push({ op: "test", path: n2 + "/" + u(f2), value: o(m2) }), a3.push({ op: "remove", path: n2 + "/" + u(f2) }), h2 = true) : (l2 && a3.push({ op: "test", path: n2, value: t3 }), a3.push({ op: "replace", path: n2, value: r3 }));
          }
          if (h2 || c2.length != d2.length)
            for (var p2 = 0; p2 < c2.length; p2++) {
              var f2 = c2[p2];
              i(t3, f2) || void 0 === r3[f2] || a3.push({ op: "add", path: n2 + "/" + u(f2), value: o(r3[f2]) });
            }
        }
      }(e2, t2, a2, "", r2), a2;
    }
    ({ ...a });
  };
  __namedExportsObject["__chunk_5266"] = (e, t, r) => {
    "use strict";
    let a;
    r.r(t), r.d(t, { getEnv: () => u, getEnvironmentVariable: () => d, getRuntimeEnvironment: () => c, isBrowser: () => n, isDeno: () => o, isJsDom: () => s, isNode: () => l, isWebWorker: () => i });
    let n = () => "undefined" != typeof window && void 0 !== window.document, i = () => "object" == typeof globalThis && globalThis.constructor && "DedicatedWorkerGlobalScope" === globalThis.constructor.name, s = () => "undefined" != typeof window && "nodejs" === window.name || "undefined" != typeof navigator && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), o = () => "undefined" != typeof Deno, l = () => "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node && !o(), u = () => n() ? "browser" : l() ? "node" : i() ? "webworker" : s() ? "jsdom" : o() ? "deno" : "other";
    async function c() {
      return void 0 === a && (a = { library: "langchain-js", runtime: u() }), a;
    }
    function d(e2) {
      try {
        if ("undefined" != typeof process)
          return process.env?.[e2];
        if (o())
          return Deno?.env.get(e2);
        return;
      } catch (e3) {
        return;
      }
    }
  };
  __namedExportsObject["__chunk_6890"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { chunkArray: () => a });
    let a = (e2, t2) => e2.reduce((e3, r2, a2) => {
      let n = Math.floor(a2 / t2), i = e3[n] || [];
      return e3[n] = i.concat([r2]), e3;
    }, []);
  };
  __namedExportsObject["__chunk_1550"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { AsyncCaller: () => o });
    var a = r(4779), n = r(7439);
    let i = [400, 401, 402, 403, 404, 405, 406, 407, 409], s = (e2) => {
      if (e2.message.startsWith("Cancel") || e2.message.startsWith("AbortError") || "AbortError" === e2.name || e2?.code === "ECONNABORTED")
        throw e2;
      let t2 = e2?.response?.status ?? e2?.status;
      if (t2 && i.includes(+t2))
        throw e2;
      if (e2?.error?.code === "insufficient_quota") {
        let t3 = Error(e2?.message);
        throw t3.name = "InsufficientQuotaError", t3;
      }
    };
    class o {
      constructor(e2) {
        Object.defineProperty(this, "maxConcurrency", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "maxRetries", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "onFailedAttempt", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "queue", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.maxConcurrency = e2.maxConcurrency ?? 1 / 0, this.maxRetries = e2.maxRetries ?? 6, this.onFailedAttempt = e2.onFailedAttempt ?? s;
        let t2 = n.default;
        this.queue = new t2({ concurrency: this.maxConcurrency });
      }
      call(e2, ...t2) {
        return this.queue.add(() => a(() => e2(...t2).catch((e3) => {
          if (e3 instanceof Error)
            throw e3;
          throw Error(e3);
        }), { onFailedAttempt: this.onFailedAttempt, retries: this.maxRetries, randomize: true }), { throwOnTimeout: true });
      }
      callWithOptions(e2, t2, ...r2) {
        return e2.signal ? Promise.race([this.call(t2, ...r2), new Promise((t3, r3) => {
          e2.signal?.addEventListener("abort", () => {
            r3(Error("AbortError"));
          });
        })]) : this.call(t2, ...r2);
      }
      fetch(...e2) {
        return this.call(() => fetch(...e2).then((e3) => e3.ok ? e3 : Promise.reject(e3)));
      }
    }
  };
  __namedExportsObject["__chunk_2003"] = (e, t, r) => {
    "use strict";
    function a(e2, t2) {
      let r2 = typeof e2;
      if (r2 !== typeof t2)
        return false;
      if (Array.isArray(e2)) {
        if (!Array.isArray(t2))
          return false;
        let r3 = e2.length;
        if (r3 !== t2.length)
          return false;
        for (let n2 = 0; n2 < r3; n2++)
          if (!a(e2[n2], t2[n2]))
            return false;
        return true;
      }
      if ("object" === r2) {
        if (!e2 || !t2)
          return e2 === t2;
        let r3 = Object.keys(e2), n2 = Object.keys(t2);
        if (r3.length !== n2.length)
          return false;
        for (let n3 of r3)
          if (!a(e2[n3], t2[n3]))
            return false;
        return true;
      }
      return e2 === t2;
    }
    function n(e2) {
      return encodeURI(e2.replace(/~/g, "~0").replace(/\//g, "~1"));
    }
    r.d(t, { cX: () => w, hh: () => a });
    let i = { prefixItems: true, items: true, allOf: true, anyOf: true, oneOf: true }, s = { $defs: true, definitions: true, properties: true, patternProperties: true, dependentSchemas: true }, o = { id: true, $id: true, $ref: true, $schema: true, $anchor: true, $vocabulary: true, $comment: true, default: true, enum: true, const: true, required: true, type: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true }, l = "undefined" != typeof self && self.location && "null" !== self.location.origin ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
    function u(e2, t2 = /* @__PURE__ */ Object.create(null), r2 = l, a2 = "") {
      if (e2 && "object" == typeof e2 && !Array.isArray(e2)) {
        let n2 = e2.$id || e2.id;
        if (n2) {
          let i2 = new URL(n2, r2.href);
          i2.hash.length > 1 ? t2[i2.href] = e2 : (i2.hash = "", "" === a2 ? r2 = i2 : u(e2, t2, r2));
        }
      } else if (true !== e2 && false !== e2)
        return t2;
      let c2 = r2.href + (a2 ? "#" + a2 : "");
      if (void 0 !== t2[c2])
        throw Error(`Duplicate schema URI "${c2}".`);
      if (t2[c2] = e2, true === e2 || false === e2)
        return t2;
      if (void 0 === e2.__absolute_uri__ && Object.defineProperty(e2, "__absolute_uri__", { enumerable: false, value: c2 }), e2.$ref && void 0 === e2.__absolute_ref__) {
        let t3 = new URL(e2.$ref, r2.href);
        t3.hash = t3.hash, Object.defineProperty(e2, "__absolute_ref__", { enumerable: false, value: t3.href });
      }
      if (e2.$recursiveRef && void 0 === e2.__absolute_recursive_ref__) {
        let t3 = new URL(e2.$recursiveRef, r2.href);
        t3.hash = t3.hash, Object.defineProperty(e2, "__absolute_recursive_ref__", { enumerable: false, value: t3.href });
      }
      for (let l2 in e2.$anchor && (t2[new URL("#" + e2.$anchor, r2.href).href] = e2), e2) {
        if (o[l2])
          continue;
        let c3 = `${a2}/${n(l2)}`, d2 = e2[l2];
        if (Array.isArray(d2)) {
          if (i[l2]) {
            let e3 = d2.length;
            for (let a3 = 0; a3 < e3; a3++)
              u(d2[a3], t2, r2, `${c3}/${a3}`);
          }
        } else if (s[l2])
          for (let e3 in d2)
            u(d2[e3], t2, r2, `${c3}/${n(e3)}`);
        else
          u(d2, t2, r2, c3);
      }
      return t2;
    }
    let c = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, d = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], h = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function p(e2) {
      return e2.test.bind(e2);
    }
    let f = { date: m, time: g.bind(void 0, false), "date-time": function(e2) {
      let t2 = e2.split(y);
      return 2 == t2.length && m(t2[0]) && g(true, t2[1]);
    }, duration: (e2) => e2.length > 1 && e2.length < 80 && (/^P\d+([.,]\d+)?W$/.test(e2) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(e2) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(e2)), uri: function(e2) {
      return b.test(e2) && v.test(e2);
    }, "uri-reference": p(/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i), "uri-template": p(/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i), url: p(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu), email: (e2) => {
      if ('"' === e2[0])
        return false;
      let [t2, r2, ...a2] = e2.split("@");
      return !(!t2 || !r2 || 0 !== a2.length || t2.length > 64 || r2.length > 253 || "." === t2[0] || t2.endsWith(".") || t2.includes("..")) && !!/^[a-z0-9.-]+$/i.test(r2) && !!/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(t2) && r2.split(".").every((e3) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(e3));
    }, hostname: p(/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i), ipv4: p(/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/), ipv6: p(/^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i), regex: function(e2) {
      if (_.test(e2))
        return false;
      try {
        return new RegExp(e2), true;
      } catch (e3) {
        return false;
      }
    }, uuid: p(/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i), "json-pointer": p(/^(?:\/(?:[^~/]|~0|~1)*)*$/), "json-pointer-uri-fragment": p(/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i), "relative-json-pointer": p(/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/), date: p(/^\d\d\d\d-[0-1]\d-[0-3]\d$/), time: p(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i), "date-time": p(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i), "uri-reference": p(/^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i) };
    function m(e2) {
      var t2;
      let r2 = e2.match(c);
      if (!r2)
        return false;
      let a2 = +r2[1], n2 = +r2[2], i2 = +r2[3];
      return n2 >= 1 && n2 <= 12 && i2 >= 1 && i2 <= (2 == n2 && (t2 = a2) % 4 == 0 && (t2 % 100 != 0 || t2 % 400 == 0) ? 29 : d[n2]);
    }
    function g(e2, t2) {
      let r2 = t2.match(h);
      if (!r2)
        return false;
      let a2 = +r2[1], n2 = +r2[2], i2 = +r2[3], s2 = !!r2[5];
      return (a2 <= 23 && n2 <= 59 && i2 <= 59 || 23 == a2 && 59 == n2 && 60 == i2) && (!e2 || s2);
    }
    let y = /t|\s/i, b = /\/|:/, v = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, _ = /[^\\]\\Z/;
    class w {
      constructor(e2, t2 = "2019-09", r2 = true) {
        Object.defineProperty(this, "schema", { enumerable: true, configurable: true, writable: true, value: e2 }), Object.defineProperty(this, "draft", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "shortCircuit", { enumerable: true, configurable: true, writable: true, value: r2 }), Object.defineProperty(this, "lookup", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.lookup = u(e2);
      }
      validate(e2) {
        return function e3(t2, r2, i2 = "2019-09", s2 = u(r2), o2 = true, l2 = null, c2 = "#", d2 = "#", h2 = /* @__PURE__ */ Object.create(null)) {
          let p2;
          if (true === r2)
            return { valid: true, errors: [] };
          if (false === r2)
            return { valid: false, errors: [{ instanceLocation: c2, keyword: "false", keywordLocation: c2, error: "False boolean schema." }] };
          let m2 = typeof t2;
          switch (m2) {
            case "boolean":
            case "number":
            case "string":
              p2 = m2;
              break;
            case "object":
              p2 = null === t2 ? "null" : Array.isArray(t2) ? "array" : "object";
              break;
            default:
              throw Error(`Instances of "${m2}" type are not supported.`);
          }
          let { $ref: g2, $recursiveRef: y2, $recursiveAnchor: b2, type: v2, const: _2, enum: w2, required: E, not: x, anyOf: O, allOf: S, oneOf: A, if: k, then: T, else: P, format: C, properties: I, patternProperties: R, additionalProperties: N, unevaluatedProperties: $, minProperties: j, maxProperties: L, propertyNames: M, dependentRequired: D, dependentSchemas: U, dependencies: F, prefixItems: z, items: B, additionalItems: q, unevaluatedItems: H, contains: Z, minContains: G, maxContains: V, minItems: W, maxItems: J, uniqueItems: K, minimum: X, maximum: Y, exclusiveMinimum: Q, exclusiveMaximum: ee, multipleOf: et, minLength: er, maxLength: ea, pattern: en, __absolute_ref__: ei, __absolute_recursive_ref__: es } = r2, eo = [];
          if (true === b2 && null === l2 && (l2 = r2), "#" === y2) {
            let a2 = null === l2 ? s2[es] : l2, n2 = `${d2}/$recursiveRef`, u2 = e3(t2, null === l2 ? r2 : l2, i2, s2, o2, a2, c2, n2, h2);
            u2.valid || eo.push({ instanceLocation: c2, keyword: "$recursiveRef", keywordLocation: n2, error: "A subschema had errors." }, ...u2.errors);
          }
          if (void 0 !== g2) {
            let r3 = s2[ei || g2];
            if (void 0 === r3) {
              let e4 = `Unresolved $ref "${g2}".`;
              throw ei && ei !== g2 && (e4 += `  Absolute URI "${ei}".`), Error(e4 += `
Known schemas:
- ${Object.keys(s2).join("\n- ")}`);
            }
            let a2 = `${d2}/$ref`, n2 = e3(t2, r3, i2, s2, o2, l2, c2, a2, h2);
            if (n2.valid || eo.push({ instanceLocation: c2, keyword: "$ref", keywordLocation: a2, error: "A subschema had errors." }, ...n2.errors), "4" === i2 || "7" === i2)
              return { valid: 0 === eo.length, errors: eo };
          }
          if (Array.isArray(v2)) {
            let e4 = v2.length, r3 = false;
            for (let a2 = 0; a2 < e4; a2++)
              if (p2 === v2[a2] || "integer" === v2[a2] && "number" === p2 && t2 % 1 == 0 && t2 == t2) {
                r3 = true;
                break;
              }
            r3 || eo.push({ instanceLocation: c2, keyword: "type", keywordLocation: `${d2}/type`, error: `Instance type "${p2}" is invalid. Expected "${v2.join('", "')}".` });
          } else
            "integer" === v2 ? ("number" !== p2 || t2 % 1 || t2 != t2) && eo.push({ instanceLocation: c2, keyword: "type", keywordLocation: `${d2}/type`, error: `Instance type "${p2}" is invalid. Expected "${v2}".` }) : void 0 !== v2 && p2 !== v2 && eo.push({ instanceLocation: c2, keyword: "type", keywordLocation: `${d2}/type`, error: `Instance type "${p2}" is invalid. Expected "${v2}".` });
          if (void 0 === _2 || ("object" === p2 || "array" === p2 ? a(t2, _2) || eo.push({ instanceLocation: c2, keyword: "const", keywordLocation: `${d2}/const`, error: `Instance does not match ${JSON.stringify(_2)}.` }) : t2 !== _2 && eo.push({ instanceLocation: c2, keyword: "const", keywordLocation: `${d2}/const`, error: `Instance does not match ${JSON.stringify(_2)}.` })), void 0 === w2 || ("object" === p2 || "array" === p2 ? w2.some((e4) => a(t2, e4)) || eo.push({ instanceLocation: c2, keyword: "enum", keywordLocation: `${d2}/enum`, error: `Instance does not match any of ${JSON.stringify(w2)}.` }) : w2.some((e4) => t2 === e4) || eo.push({ instanceLocation: c2, keyword: "enum", keywordLocation: `${d2}/enum`, error: `Instance does not match any of ${JSON.stringify(w2)}.` })), void 0 !== x) {
            let r3 = `${d2}/not`;
            e3(t2, x, i2, s2, o2, l2, c2, r3).valid && eo.push({ instanceLocation: c2, keyword: "not", keywordLocation: r3, error: 'Instance matched "not" schema.' });
          }
          let el = [];
          if (void 0 !== O) {
            let r3 = `${d2}/anyOf`, a2 = eo.length, n2 = false;
            for (let a3 = 0; a3 < O.length; a3++) {
              let u2 = O[a3], d3 = Object.create(h2), p3 = e3(t2, u2, i2, s2, o2, true === b2 ? l2 : null, c2, `${r3}/${a3}`, d3);
              eo.push(...p3.errors), n2 = n2 || p3.valid, p3.valid && el.push(d3);
            }
            n2 ? eo.length = a2 : eo.splice(a2, 0, { instanceLocation: c2, keyword: "anyOf", keywordLocation: r3, error: "Instance does not match any subschemas." });
          }
          if (void 0 !== S) {
            let r3 = `${d2}/allOf`, a2 = eo.length, n2 = true;
            for (let a3 = 0; a3 < S.length; a3++) {
              let u2 = S[a3], d3 = Object.create(h2), p3 = e3(t2, u2, i2, s2, o2, true === b2 ? l2 : null, c2, `${r3}/${a3}`, d3);
              eo.push(...p3.errors), n2 = n2 && p3.valid, p3.valid && el.push(d3);
            }
            n2 ? eo.length = a2 : eo.splice(a2, 0, { instanceLocation: c2, keyword: "allOf", keywordLocation: r3, error: "Instance does not match every subschema." });
          }
          if (void 0 !== A) {
            let r3 = `${d2}/oneOf`, a2 = eo.length, n2 = A.filter((a3, n3) => {
              let u2 = Object.create(h2), d3 = e3(t2, a3, i2, s2, o2, true === b2 ? l2 : null, c2, `${r3}/${n3}`, u2);
              return eo.push(...d3.errors), d3.valid && el.push(u2), d3.valid;
            }).length;
            1 === n2 ? eo.length = a2 : eo.splice(a2, 0, { instanceLocation: c2, keyword: "oneOf", keywordLocation: r3, error: `Instance does not match exactly one subschema (${n2} matches).` });
          }
          if (("object" === p2 || "array" === p2) && Object.assign(h2, ...el), void 0 !== k) {
            let r3 = `${d2}/if`;
            if (e3(t2, k, i2, s2, o2, l2, c2, r3, h2).valid) {
              if (void 0 !== T) {
                let a2 = e3(t2, T, i2, s2, o2, l2, c2, `${d2}/then`, h2);
                a2.valid || eo.push({ instanceLocation: c2, keyword: "if", keywordLocation: r3, error: 'Instance does not match "then" schema.' }, ...a2.errors);
              }
            } else if (void 0 !== P) {
              let a2 = e3(t2, P, i2, s2, o2, l2, c2, `${d2}/else`, h2);
              a2.valid || eo.push({ instanceLocation: c2, keyword: "if", keywordLocation: r3, error: 'Instance does not match "else" schema.' }, ...a2.errors);
            }
          }
          if ("object" === p2) {
            if (void 0 !== E)
              for (let e4 of E)
                e4 in t2 || eo.push({ instanceLocation: c2, keyword: "required", keywordLocation: `${d2}/required`, error: `Instance does not have required property "${e4}".` });
            let r3 = Object.keys(t2);
            if (void 0 !== j && r3.length < j && eo.push({ instanceLocation: c2, keyword: "minProperties", keywordLocation: `${d2}/minProperties`, error: `Instance does not have at least ${j} properties.` }), void 0 !== L && r3.length > L && eo.push({ instanceLocation: c2, keyword: "maxProperties", keywordLocation: `${d2}/maxProperties`, error: `Instance does not have at least ${L} properties.` }), void 0 !== M) {
              let r4 = `${d2}/propertyNames`;
              for (let a3 in t2) {
                let t3 = `${c2}/${n(a3)}`, u3 = e3(a3, M, i2, s2, o2, l2, t3, r4);
                u3.valid || eo.push({ instanceLocation: c2, keyword: "propertyNames", keywordLocation: r4, error: `Property name "${a3}" does not match schema.` }, ...u3.errors);
              }
            }
            if (void 0 !== D) {
              let e4 = `${d2}/dependantRequired`;
              for (let r4 in D)
                if (r4 in t2)
                  for (let a3 of D[r4])
                    a3 in t2 || eo.push({ instanceLocation: c2, keyword: "dependentRequired", keywordLocation: e4, error: `Instance has "${r4}" but does not have "${a3}".` });
            }
            if (void 0 !== U)
              for (let r4 in U) {
                let a3 = `${d2}/dependentSchemas`;
                if (r4 in t2) {
                  let u3 = e3(t2, U[r4], i2, s2, o2, l2, c2, `${a3}/${n(r4)}`, h2);
                  u3.valid || eo.push({ instanceLocation: c2, keyword: "dependentSchemas", keywordLocation: a3, error: `Instance has "${r4}" but does not match dependant schema.` }, ...u3.errors);
                }
              }
            if (void 0 !== F) {
              let r4 = `${d2}/dependencies`;
              for (let a3 in F)
                if (a3 in t2) {
                  let u3 = F[a3];
                  if (Array.isArray(u3))
                    for (let e4 of u3)
                      e4 in t2 || eo.push({ instanceLocation: c2, keyword: "dependencies", keywordLocation: r4, error: `Instance has "${a3}" but does not have "${e4}".` });
                  else {
                    let d3 = e3(t2, u3, i2, s2, o2, l2, c2, `${r4}/${n(a3)}`);
                    d3.valid || eo.push({ instanceLocation: c2, keyword: "dependencies", keywordLocation: r4, error: `Instance has "${a3}" but does not match dependant schema.` }, ...d3.errors);
                  }
                }
            }
            let a2 = /* @__PURE__ */ Object.create(null), u2 = false;
            if (void 0 !== I) {
              let r4 = `${d2}/properties`;
              for (let d3 in I) {
                if (!(d3 in t2))
                  continue;
                let p3 = `${c2}/${n(d3)}`, f2 = e3(t2[d3], I[d3], i2, s2, o2, l2, p3, `${r4}/${n(d3)}`);
                if (f2.valid)
                  h2[d3] = a2[d3] = true;
                else if (u2 = o2, eo.push({ instanceLocation: c2, keyword: "properties", keywordLocation: r4, error: `Property "${d3}" does not match schema.` }, ...f2.errors), u2)
                  break;
              }
            }
            if (!u2 && void 0 !== R) {
              let r4 = `${d2}/patternProperties`;
              for (let d3 in R) {
                let p3 = new RegExp(d3), f2 = R[d3];
                for (let m3 in t2) {
                  if (!p3.test(m3))
                    continue;
                  let g3 = `${c2}/${n(m3)}`, y3 = e3(t2[m3], f2, i2, s2, o2, l2, g3, `${r4}/${n(d3)}`);
                  y3.valid ? h2[m3] = a2[m3] = true : (u2 = o2, eo.push({ instanceLocation: c2, keyword: "patternProperties", keywordLocation: r4, error: `Property "${m3}" matches pattern "${d3}" but does not match associated schema.` }, ...y3.errors));
                }
              }
            }
            if (u2 || void 0 === N) {
              if (!u2 && void 0 !== $) {
                let r4 = `${d2}/unevaluatedProperties`;
                for (let a3 in t2)
                  if (!h2[a3]) {
                    let u3 = `${c2}/${n(a3)}`, d3 = e3(t2[a3], $, i2, s2, o2, l2, u3, r4);
                    d3.valid ? h2[a3] = true : eo.push({ instanceLocation: c2, keyword: "unevaluatedProperties", keywordLocation: r4, error: `Property "${a3}" does not match unevaluated properties schema.` }, ...d3.errors);
                  }
              }
            } else {
              let r4 = `${d2}/additionalProperties`;
              for (let d3 in t2) {
                if (a2[d3])
                  continue;
                let p3 = `${c2}/${n(d3)}`, f2 = e3(t2[d3], N, i2, s2, o2, l2, p3, r4);
                f2.valid ? h2[d3] = true : (u2 = o2, eo.push({ instanceLocation: c2, keyword: "additionalProperties", keywordLocation: r4, error: `Property "${d3}" does not match additional properties schema.` }, ...f2.errors));
              }
            }
          } else if ("array" === p2) {
            void 0 !== J && t2.length > J && eo.push({ instanceLocation: c2, keyword: "maxItems", keywordLocation: `${d2}/maxItems`, error: `Array has too many items (${t2.length} > ${J}).` }), void 0 !== W && t2.length < W && eo.push({ instanceLocation: c2, keyword: "minItems", keywordLocation: `${d2}/minItems`, error: `Array has too few items (${t2.length} < ${W}).` });
            let r3 = t2.length, n2 = 0, u2 = false;
            if (void 0 !== z) {
              let a2 = `${d2}/prefixItems`, p3 = Math.min(z.length, r3);
              for (; n2 < p3; n2++) {
                let r4 = e3(t2[n2], z[n2], i2, s2, o2, l2, `${c2}/${n2}`, `${a2}/${n2}`);
                if (h2[n2] = true, !r4.valid && (u2 = o2, eo.push({ instanceLocation: c2, keyword: "prefixItems", keywordLocation: a2, error: "Items did not match schema." }, ...r4.errors), u2))
                  break;
              }
            }
            if (void 0 !== B) {
              let a2 = `${d2}/items`;
              if (Array.isArray(B)) {
                let d3 = Math.min(B.length, r3);
                for (; n2 < d3; n2++) {
                  let r4 = e3(t2[n2], B[n2], i2, s2, o2, l2, `${c2}/${n2}`, `${a2}/${n2}`);
                  if (h2[n2] = true, !r4.valid && (u2 = o2, eo.push({ instanceLocation: c2, keyword: "items", keywordLocation: a2, error: "Items did not match schema." }, ...r4.errors), u2))
                    break;
                }
              } else
                for (; n2 < r3; n2++) {
                  let r4 = e3(t2[n2], B, i2, s2, o2, l2, `${c2}/${n2}`, a2);
                  if (h2[n2] = true, !r4.valid && (u2 = o2, eo.push({ instanceLocation: c2, keyword: "items", keywordLocation: a2, error: "Items did not match schema." }, ...r4.errors), u2))
                    break;
                }
              if (!u2 && void 0 !== q) {
                let a3 = `${d2}/additionalItems`;
                for (; n2 < r3; n2++) {
                  let r4 = e3(t2[n2], q, i2, s2, o2, l2, `${c2}/${n2}`, a3);
                  h2[n2] = true, r4.valid || (u2 = o2, eo.push({ instanceLocation: c2, keyword: "additionalItems", keywordLocation: a3, error: "Items did not match additional items schema." }, ...r4.errors));
                }
              }
            }
            if (void 0 !== Z) {
              if (0 === r3 && void 0 === G)
                eo.push({ instanceLocation: c2, keyword: "contains", keywordLocation: `${d2}/contains`, error: "Array is empty. It must contain at least one item matching the schema." });
              else if (void 0 !== G && r3 < G)
                eo.push({ instanceLocation: c2, keyword: "minContains", keywordLocation: `${d2}/minContains`, error: `Array has less items (${r3}) than minContains (${G}).` });
              else {
                let a2 = `${d2}/contains`, n3 = eo.length, u3 = 0;
                for (let n4 = 0; n4 < r3; n4++) {
                  let r4 = e3(t2[n4], Z, i2, s2, o2, l2, `${c2}/${n4}`, a2);
                  r4.valid ? (h2[n4] = true, u3++) : eo.push(...r4.errors);
                }
                u3 >= (G || 0) && (eo.length = n3), void 0 === G && void 0 === V && 0 === u3 ? eo.splice(n3, 0, { instanceLocation: c2, keyword: "contains", keywordLocation: a2, error: "Array does not contain item matching schema." }) : void 0 !== G && u3 < G ? eo.push({ instanceLocation: c2, keyword: "minContains", keywordLocation: `${d2}/minContains`, error: `Array must contain at least ${G} items matching schema. Only ${u3} items were found.` }) : void 0 !== V && u3 > V && eo.push({ instanceLocation: c2, keyword: "maxContains", keywordLocation: `${d2}/maxContains`, error: `Array may contain at most ${V} items matching schema. ${u3} items were found.` });
              }
            }
            if (!u2 && void 0 !== H) {
              let a2 = `${d2}/unevaluatedItems`;
              for (; n2 < r3; n2++) {
                if (h2[n2])
                  continue;
                let r4 = e3(t2[n2], H, i2, s2, o2, l2, `${c2}/${n2}`, a2);
                h2[n2] = true, r4.valid || eo.push({ instanceLocation: c2, keyword: "unevaluatedItems", keywordLocation: a2, error: "Items did not match unevaluated items schema." }, ...r4.errors);
              }
            }
            if (K)
              for (let e4 = 0; e4 < r3; e4++) {
                let n3 = t2[e4], i3 = "object" == typeof n3 && null !== n3;
                for (let s3 = 0; s3 < r3; s3++) {
                  if (e4 === s3)
                    continue;
                  let r4 = t2[s3], o3 = "object" == typeof r4 && null !== r4;
                  (n3 === r4 || i3 && o3 && a(n3, r4)) && (eo.push({ instanceLocation: c2, keyword: "uniqueItems", keywordLocation: `${d2}/uniqueItems`, error: `Duplicate items at indexes ${e4} and ${s3}.` }), e4 = Number.MAX_SAFE_INTEGER, s3 = Number.MAX_SAFE_INTEGER);
                }
              }
          } else if ("number" === p2) {
            if ("4" === i2 ? (void 0 !== X && (true === Q && t2 <= X || t2 < X) && eo.push({ instanceLocation: c2, keyword: "minimum", keywordLocation: `${d2}/minimum`, error: `${t2} is less than ${Q ? "or equal to " : ""} ${X}.` }), void 0 !== Y && (true === ee && t2 >= Y || t2 > Y) && eo.push({ instanceLocation: c2, keyword: "maximum", keywordLocation: `${d2}/maximum`, error: `${t2} is greater than ${ee ? "or equal to " : ""} ${Y}.` })) : (void 0 !== X && t2 < X && eo.push({ instanceLocation: c2, keyword: "minimum", keywordLocation: `${d2}/minimum`, error: `${t2} is less than ${X}.` }), void 0 !== Y && t2 > Y && eo.push({ instanceLocation: c2, keyword: "maximum", keywordLocation: `${d2}/maximum`, error: `${t2} is greater than ${Y}.` }), void 0 !== Q && t2 <= Q && eo.push({ instanceLocation: c2, keyword: "exclusiveMinimum", keywordLocation: `${d2}/exclusiveMinimum`, error: `${t2} is less than ${Q}.` }), void 0 !== ee && t2 >= ee && eo.push({ instanceLocation: c2, keyword: "exclusiveMaximum", keywordLocation: `${d2}/exclusiveMaximum`, error: `${t2} is greater than or equal to ${ee}.` })), void 0 !== et) {
              let e4 = t2 % et;
              Math.abs(0 - e4) >= 11920929e-14 && Math.abs(et - e4) >= 11920929e-14 && eo.push({ instanceLocation: c2, keyword: "multipleOf", keywordLocation: `${d2}/multipleOf`, error: `${t2} is not a multiple of ${et}.` });
            }
          } else if ("string" === p2) {
            let e4 = void 0 === er && void 0 === ea ? 0 : function(e5) {
              let t3, r3 = 0, a2 = e5.length, n2 = 0;
              for (; n2 < a2; )
                r3++, (t3 = e5.charCodeAt(n2++)) >= 55296 && t3 <= 56319 && n2 < a2 && (64512 & (t3 = e5.charCodeAt(n2))) == 56320 && n2++;
              return r3;
            }(t2);
            void 0 !== er && e4 < er && eo.push({ instanceLocation: c2, keyword: "minLength", keywordLocation: `${d2}/minLength`, error: `String is too short (${e4} < ${er}).` }), void 0 !== ea && e4 > ea && eo.push({ instanceLocation: c2, keyword: "maxLength", keywordLocation: `${d2}/maxLength`, error: `String is too long (${e4} > ${ea}).` }), void 0 === en || new RegExp(en).test(t2) || eo.push({ instanceLocation: c2, keyword: "pattern", keywordLocation: `${d2}/pattern`, error: "String does not match pattern." }), void 0 !== C && f[C] && !f[C](t2) && eo.push({ instanceLocation: c2, keyword: "format", keywordLocation: `${d2}/format`, error: `String does not match format "${C}".` });
          }
          return { valid: 0 === eo.length, errors: eo };
        }(e2, this.schema, this.draft, this.lookup, this.shortCircuit);
      }
      addSchema(e2, t2) {
        t2 && (e2 = { ...e2, $id: t2 }), u(e2, this.lookup);
      }
    }
  };
  __namedExportsObject["__chunk_9205"] = (e, t, r) => {
    "use strict";
    let a;
    r.r(t), r.d(t, { LangChainTracer: () => c });
    var n = r(1042), i = r(7928), s = r(5266), o = r(9321), l = r(6953);
    let u = () => {
      if (void 0 === a) {
        let e2 = "false" === (0, s.getEnvironmentVariable)("LANGCHAIN_CALLBACKS_BACKGROUND") ? { blockOnRootRunFinalization: true } : {};
        a = new l.KU(e2);
      }
      return a;
    };
    class c extends o.BaseTracer {
      constructor(e2 = {}) {
        super(e2), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "langchain_tracer" }), Object.defineProperty(this, "projectName", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "exampleId", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 });
        let { exampleId: t2, projectName: r2, client: a2 } = e2;
        this.projectName = r2 ?? (0, s.getEnvironmentVariable)("LANGCHAIN_PROJECT") ?? (0, s.getEnvironmentVariable)("LANGCHAIN_SESSION"), this.exampleId = t2, this.client = a2 ?? u();
        let n2 = c.getTraceableRunTree();
        n2 && this.updateFromRunTree(n2);
      }
      async _convertToCreate(e2, t2) {
        return { ...e2, extra: { ...e2.extra, runtime: await (0, s.getRuntimeEnvironment)() }, child_runs: void 0, session_name: this.projectName, reference_example_id: e2.parent_run_id ? void 0 : t2 };
      }
      async persistRun(e2) {
      }
      async onRunCreate(e2) {
        let t2 = await this._convertToCreate(e2, this.exampleId);
        await this.client.createRun(t2);
      }
      async onRunUpdate(e2) {
        let t2 = { end_time: e2.end_time, error: e2.error, outputs: e2.outputs, events: e2.events, inputs: e2.inputs, trace_id: e2.trace_id, dotted_order: e2.dotted_order, parent_run_id: e2.parent_run_id };
        await this.client.updateRun(e2.id, t2);
      }
      getRun(e2) {
        return this.runMap.get(e2);
      }
      updateFromRunTree(e2) {
        let t2 = e2, r2 = /* @__PURE__ */ new Set();
        for (; t2.parent_run && !r2.has(t2.id) && (r2.add(t2.id), t2.parent_run); )
          t2 = t2.parent_run;
        r2.clear();
        let a2 = [t2];
        for (; a2.length > 0; ) {
          let e3 = a2.shift();
          !(!e3 || r2.has(e3.id)) && (r2.add(e3.id), this.runMap.set(e3.id, e3), e3.child_runs && a2.push(...e3.child_runs));
        }
        this.client = e2.client ?? this.client, this.projectName = e2.project_name ?? this.projectName, this.exampleId = e2.reference_example_id ?? this.exampleId;
      }
      convertToRunTree(e2) {
        let t2 = {}, r2 = [];
        for (let [e3, a2] of this.runMap) {
          let i2 = new n.IV({ ...a2, child_runs: [], parent_run: void 0, client: this.client, project_name: this.projectName, reference_example_id: this.exampleId, tracingEnabled: true });
          t2[e3] = i2, r2.push([e3, a2.dotted_order]);
        }
        for (let [e3] of (r2.sort((e4, t3) => e4[1] && t3[1] ? e4[1].localeCompare(t3[1]) : 0), r2)) {
          let r3 = this.runMap.get(e3), a2 = t2[e3];
          if (r3 && a2 && r3.parent_run_id) {
            let e4 = t2[r3.parent_run_id];
            e4 && (e4.child_runs.push(a2), a2.parent_run = e4);
          }
        }
        return t2[e2];
      }
      static getTraceableRunTree() {
        try {
          return (0, i.dy)();
        } catch {
          return;
        }
      }
    }
  };
  __namedExportsObject["__chunk_9593"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { LogStreamCallbackHandler: () => h, RunLog: () => l, RunLogPatch: () => o, isLogStreamHandler: () => u });
    var a = r(9363), n = r(9321), i = r(541), s = r(1582);
    class o {
      constructor(e2) {
        Object.defineProperty(this, "ops", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.ops = e2.ops ?? [];
      }
      concat(e2) {
        let t2 = this.ops.concat(e2.ops), r2 = (0, a.af)({}, t2);
        return new l({ ops: t2, state: r2[r2.length - 1].newDocument });
      }
    }
    class l extends o {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.state = e2.state;
      }
      concat(e2) {
        let t2 = this.ops.concat(e2.ops), r2 = (0, a.af)(this.state, e2.ops);
        return new l({ ops: t2, state: r2[r2.length - 1].newDocument });
      }
      static fromRunLogPatch(e2) {
        let t2 = (0, a.af)({}, e2.ops);
        return new l({ ops: e2.ops, state: t2[t2.length - 1].newDocument });
      }
    }
    let u = (e2) => "log_stream_tracer" === e2.name;
    async function c(e2, t2) {
      if ("original" === t2)
        throw Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
      let { inputs: r2 } = e2;
      return ["retriever", "llm", "prompt"].includes(e2.run_type) ? r2 : 1 !== Object.keys(r2).length || r2?.input !== "" ? r2.input : void 0;
    }
    async function d(e2, t2) {
      let { outputs: r2 } = e2;
      return "original" === t2 || ["retriever", "llm", "prompt"].includes(e2.run_type) ? r2 : void 0 !== r2 && 1 === Object.keys(r2).length && r2?.output !== void 0 ? r2.output : r2;
    }
    class h extends n.BaseTracer {
      constructor(e2) {
        super({ _awaitHandler: true, ...e2 }), Object.defineProperty(this, "autoClose", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "includeNames", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "includeTypes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "includeTags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeNames", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeTypes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeTags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_schemaFormat", { enumerable: true, configurable: true, writable: true, value: "original" }), Object.defineProperty(this, "rootId", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "keyMapByRunId", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "counterMapByRunName", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "transformStream", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "writer", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "receiveStream", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "log_stream_tracer" }), this.autoClose = e2?.autoClose ?? true, this.includeNames = e2?.includeNames, this.includeTypes = e2?.includeTypes, this.includeTags = e2?.includeTags, this.excludeNames = e2?.excludeNames, this.excludeTypes = e2?.excludeTypes, this.excludeTags = e2?.excludeTags, this._schemaFormat = e2?._schemaFormat ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = i.IterableReadableStream.fromReadableStream(this.transformStream.readable);
      }
      [Symbol.asyncIterator]() {
        return this.receiveStream;
      }
      async persistRun(e2) {
      }
      _includeRun(e2) {
        if (e2.id === this.rootId)
          return false;
        let t2 = e2.tags ?? [], r2 = void 0 === this.includeNames && void 0 === this.includeTags && void 0 === this.includeTypes;
        return void 0 !== this.includeNames && (r2 = r2 || this.includeNames.includes(e2.name)), void 0 !== this.includeTypes && (r2 = r2 || this.includeTypes.includes(e2.run_type)), void 0 !== this.includeTags && (r2 = r2 || void 0 !== t2.find((e3) => this.includeTags?.includes(e3))), void 0 !== this.excludeNames && (r2 = r2 && !this.excludeNames.includes(e2.name)), void 0 !== this.excludeTypes && (r2 = r2 && !this.excludeTypes.includes(e2.run_type)), void 0 !== this.excludeTags && (r2 = r2 && t2.every((e3) => !this.excludeTags?.includes(e3))), r2;
      }
      async *tapOutputIterable(e2, t2) {
        for await (let r2 of t2) {
          if (e2 !== this.rootId) {
            let t3 = this.keyMapByRunId[e2];
            t3 && await this.writer.write(new o({ ops: [{ op: "add", path: `/logs/${t3}/streamed_output/-`, value: r2 }] }));
          }
          yield r2;
        }
      }
      async onRunCreate(e2) {
        if (void 0 === this.rootId && (this.rootId = e2.id, await this.writer.write(new o({ ops: [{ op: "replace", path: "", value: { id: e2.id, name: e2.name, type: e2.run_type, streamed_output: [], final_output: void 0, logs: {} } }] }))), !this._includeRun(e2))
          return;
        void 0 === this.counterMapByRunName[e2.name] && (this.counterMapByRunName[e2.name] = 0), this.counterMapByRunName[e2.name] += 1;
        let t2 = this.counterMapByRunName[e2.name];
        this.keyMapByRunId[e2.id] = 1 === t2 ? e2.name : `${e2.name}:${t2}`;
        let r2 = { id: e2.id, name: e2.name, type: e2.run_type, tags: e2.tags ?? [], metadata: e2.extra?.metadata ?? {}, start_time: new Date(e2.start_time).toISOString(), streamed_output: [], streamed_output_str: [], final_output: void 0, end_time: void 0 };
        "streaming_events" === this._schemaFormat && (r2.inputs = await c(e2, this._schemaFormat)), await this.writer.write(new o({ ops: [{ op: "add", path: `/logs/${this.keyMapByRunId[e2.id]}`, value: r2 }] }));
      }
      async onRunUpdate(e2) {
        try {
          let t2 = this.keyMapByRunId[e2.id];
          if (void 0 === t2)
            return;
          let r2 = [];
          "streaming_events" === this._schemaFormat && r2.push({ op: "replace", path: `/logs/${t2}/inputs`, value: await c(e2, this._schemaFormat) }), r2.push({ op: "add", path: `/logs/${t2}/final_output`, value: await d(e2, this._schemaFormat) }), void 0 !== e2.end_time && r2.push({ op: "add", path: `/logs/${t2}/end_time`, value: new Date(e2.end_time).toISOString() });
          let a2 = new o({ ops: r2 });
          await this.writer.write(a2);
        } finally {
          if (e2.id === this.rootId) {
            let t2 = new o({ ops: [{ op: "replace", path: "/final_output", value: await d(e2, this._schemaFormat) }] });
            await this.writer.write(t2), this.autoClose && await this.writer.close();
          }
        }
      }
      async onLLMNewToken(e2, t2, r2) {
        let a2;
        let n2 = this.keyMapByRunId[e2.id];
        if (void 0 === n2)
          return;
        if (void 0 !== e2.inputs.messages) {
          var i2;
          a2 = void 0 !== (i2 = r2?.chunk) && void 0 !== i2.message ? r2?.chunk : new s.GC({ id: `run-${e2.id}`, content: t2 });
        } else
          a2 = t2;
        let l2 = new o({ ops: [{ op: "add", path: `/logs/${n2}/streamed_output_str/-`, value: t2 }, { op: "add", path: `/logs/${n2}/streamed_output/-`, value: a2 }] });
        await this.writer.write(l2);
      }
    }
  };
  __namedExportsObject["__chunk_1610"] = (e, t, r) => {
    "use strict";
    r.d(t, { C: () => l, d: () => u });
    var a = r(9321), n = r(541), i = r(1582), s = r(3926);
    function o({ name: e2, serialized: t2 }) {
      return void 0 !== e2 ? e2 : t2?.name !== void 0 ? t2.name : t2?.id !== void 0 && Array.isArray(t2?.id) ? t2.id[t2.id.length - 1] : "Unnamed";
    }
    let l = (e2) => "event_stream_tracer" === e2.name;
    class u extends a.BaseTracer {
      constructor(e2) {
        super({ _awaitHandler: true, ...e2 }), Object.defineProperty(this, "autoClose", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "includeNames", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "includeTypes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "includeTags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeNames", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeTypes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeTags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "runInfoMap", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() }), Object.defineProperty(this, "tappedPromises", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() }), Object.defineProperty(this, "transformStream", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "writer", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "receiveStream", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "event_stream_tracer" }), this.autoClose = e2?.autoClose ?? true, this.includeNames = e2?.includeNames, this.includeTypes = e2?.includeTypes, this.includeTags = e2?.includeTags, this.excludeNames = e2?.excludeNames, this.excludeTypes = e2?.excludeTypes, this.excludeTags = e2?.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = n.IterableReadableStream.fromReadableStream(this.transformStream.readable);
      }
      [Symbol.asyncIterator]() {
        return this.receiveStream;
      }
      async persistRun(e2) {
      }
      _includeRun(e2) {
        let t2 = e2.tags ?? [], r2 = void 0 === this.includeNames && void 0 === this.includeTags && void 0 === this.includeTypes;
        return void 0 !== this.includeNames && (r2 = r2 || this.includeNames.includes(e2.name)), void 0 !== this.includeTypes && (r2 = r2 || this.includeTypes.includes(e2.runType)), void 0 !== this.includeTags && (r2 = r2 || void 0 !== t2.find((e3) => this.includeTags?.includes(e3))), void 0 !== this.excludeNames && (r2 = r2 && !this.excludeNames.includes(e2.name)), void 0 !== this.excludeTypes && (r2 = r2 && !this.excludeTypes.includes(e2.runType)), void 0 !== this.excludeTags && (r2 = r2 && t2.every((e3) => !this.excludeTags?.includes(e3))), r2;
      }
      async *tapOutputIterable(e2, t2) {
        let r2 = await t2.next();
        if (r2.done)
          return;
        let a2 = this.runInfoMap.get(e2);
        if (void 0 === a2) {
          yield r2.value;
          return;
        }
        function n2(e3, t3) {
          return "llm" === e3 && "string" == typeof t3 ? new s.GenerationChunk({ text: t3 }) : t3;
        }
        let i2 = this.tappedPromises.get(e2);
        if (void 0 === i2) {
          let s2;
          i2 = new Promise((e3) => {
            s2 = e3;
          }), this.tappedPromises.set(e2, i2);
          try {
            let i3 = { event: `on_${a2.runType}_stream`, run_id: e2, name: a2.name, tags: a2.tags, metadata: a2.metadata, data: {} };
            for await (let e3 of (await this.send({ ...i3, data: { chunk: n2(a2.runType, r2.value) } }, a2), yield r2.value, t2))
              "tool" !== a2.runType && "retriever" !== a2.runType && await this.send({ ...i3, data: { chunk: n2(a2.runType, e3) } }, a2), yield e3;
          } finally {
            s2();
          }
        } else
          for await (let e3 of (yield r2.value, t2))
            yield e3;
      }
      async send(e2, t2) {
        this._includeRun(t2) && await this.writer.write(e2);
      }
      async sendEndEvent(e2, t2) {
        let r2 = this.tappedPromises.get(e2.run_id);
        void 0 !== r2 ? r2.then(() => {
          this.send(e2, t2);
        }) : await this.send(e2, t2);
      }
      async onLLMStart(e2) {
        let t2 = o(e2), r2 = void 0 !== e2.inputs.messages ? "chat_model" : "llm", a2 = { tags: e2.tags ?? [], metadata: e2.extra?.metadata ?? {}, name: t2, runType: r2, inputs: e2.inputs };
        this.runInfoMap.set(e2.id, a2);
        let n2 = `on_${r2}_start`;
        await this.send({ event: n2, data: { input: e2.inputs }, name: t2, tags: e2.tags ?? [], run_id: e2.id, metadata: e2.extra?.metadata ?? {} }, a2);
      }
      async onLLMNewToken(e2, t2, r2) {
        let a2, n2;
        let o2 = this.runInfoMap.get(e2.id);
        if (void 0 === o2)
          throw Error(`onLLMNewToken: Run ID ${e2.id} not found in run map.`);
        if (1 !== this.runInfoMap.size) {
          if ("chat_model" === o2.runType)
            n2 = "on_chat_model_stream", a2 = r2?.chunk === void 0 ? new i.GC({ content: t2, id: `run-${e2.id}` }) : r2.chunk.message;
          else if ("llm" === o2.runType)
            n2 = "on_llm_stream", a2 = r2?.chunk === void 0 ? new s.GenerationChunk({ text: t2 }) : r2.chunk;
          else
            throw Error(`Unexpected run type ${o2.runType}`);
          await this.send({ event: n2, data: { chunk: a2 }, run_id: e2.id, name: o2.name, tags: o2.tags, metadata: o2.metadata }, o2);
        }
      }
      async onLLMEnd(e2) {
        let t2, r2;
        let a2 = this.runInfoMap.get(e2.id);
        if (this.runInfoMap.delete(e2.id), void 0 === a2)
          throw Error(`onLLMEnd: Run ID ${e2.id} not found in run map.`);
        let n2 = e2.outputs?.generations;
        if ("chat_model" === a2.runType) {
          for (let e3 of n2 ?? []) {
            if (void 0 !== r2)
              break;
            r2 = e3[0]?.message;
          }
          t2 = "on_chat_model_end";
        } else if ("llm" === a2.runType)
          r2 = { generations: n2?.map((e3) => e3.map((e4) => ({ text: e4.text, generationInfo: e4.generationInfo }))), llmOutput: e2.outputs?.llmOutput ?? {} }, t2 = "on_llm_end";
        else
          throw Error(`onLLMEnd: Unexpected run type: ${a2.runType}`);
        await this.sendEndEvent({ event: t2, data: { output: r2, input: a2.inputs }, run_id: e2.id, name: a2.name, tags: a2.tags, metadata: a2.metadata }, a2);
      }
      async onChainStart(e2) {
        let t2 = o(e2), r2 = e2.run_type ?? "chain", a2 = { tags: e2.tags ?? [], metadata: e2.extra?.metadata ?? {}, name: t2, runType: e2.run_type }, n2 = {};
        "" === e2.inputs.input && 1 === Object.keys(e2.inputs).length ? (n2 = {}, a2.inputs = {}) : void 0 !== e2.inputs.input ? (n2.input = e2.inputs.input, a2.inputs = e2.inputs.input) : (n2.input = e2.inputs, a2.inputs = e2.inputs), this.runInfoMap.set(e2.id, a2), await this.send({ event: `on_${r2}_start`, data: n2, name: t2, tags: e2.tags ?? [], run_id: e2.id, metadata: e2.extra?.metadata ?? {} }, a2);
      }
      async onChainEnd(e2) {
        let t2 = this.runInfoMap.get(e2.id);
        if (this.runInfoMap.delete(e2.id), void 0 === t2)
          throw Error(`onChainEnd: Run ID ${e2.id} not found in run map.`);
        let r2 = `on_${e2.run_type}_end`, a2 = e2.inputs ?? t2.inputs ?? {}, n2 = { output: e2.outputs?.output ?? e2.outputs, input: a2 };
        a2.input && 1 === Object.keys(a2).length && (n2.input = a2.input, t2.inputs = a2.input), await this.sendEndEvent({ event: r2, data: n2, run_id: e2.id, name: t2.name, tags: t2.tags, metadata: t2.metadata ?? {} }, t2);
      }
      async onToolStart(e2) {
        let t2 = o(e2), r2 = { tags: e2.tags ?? [], metadata: e2.extra?.metadata ?? {}, name: t2, runType: "tool", inputs: e2.inputs ?? {} };
        this.runInfoMap.set(e2.id, r2), await this.send({ event: "on_tool_start", data: { input: e2.inputs ?? {} }, name: t2, run_id: e2.id, tags: e2.tags ?? [], metadata: e2.extra?.metadata ?? {} }, r2);
      }
      async onToolEnd(e2) {
        let t2 = this.runInfoMap.get(e2.id);
        if (this.runInfoMap.delete(e2.id), void 0 === t2)
          throw Error(`onToolEnd: Run ID ${e2.id} not found in run map.`);
        if (void 0 === t2.inputs)
          throw Error(`onToolEnd: Run ID ${e2.id} is a tool call, and is expected to have traced inputs.`);
        let r2 = e2.outputs?.output === void 0 ? e2.outputs : e2.outputs.output;
        await this.sendEndEvent({ event: "on_tool_end", data: { output: r2, input: t2.inputs }, run_id: e2.id, name: t2.name, tags: t2.tags, metadata: t2.metadata }, t2);
      }
      async onRetrieverStart(e2) {
        let t2 = o(e2), r2 = { tags: e2.tags ?? [], metadata: e2.extra?.metadata ?? {}, name: t2, runType: "retriever", inputs: { query: e2.inputs.query } };
        this.runInfoMap.set(e2.id, r2), await this.send({ event: "on_retriever_start", data: { input: { query: e2.inputs.query } }, name: t2, tags: e2.tags ?? [], run_id: e2.id, metadata: e2.extra?.metadata ?? {} }, r2);
      }
      async onRetrieverEnd(e2) {
        let t2 = this.runInfoMap.get(e2.id);
        if (this.runInfoMap.delete(e2.id), void 0 === t2)
          throw Error(`onRetrieverEnd: Run ID ${e2.id} not found in run map.`);
        await this.sendEndEvent({ event: "on_retriever_end", data: { output: e2.outputs?.documents ?? e2.outputs, input: t2.inputs }, run_id: e2.id, name: t2.name, tags: t2.tags, metadata: t2.metadata }, t2);
      }
      async handleCustomEvent(e2, t2, r2) {
        let a2 = this.runInfoMap.get(r2);
        if (void 0 === a2)
          throw Error(`handleCustomEvent: Run ID ${r2} not found in run map.`);
        await this.send({ event: "on_custom_event", run_id: r2, name: e2, tags: a2.tags, metadata: a2.metadata, data: t2 }, a2);
      }
      async finish() {
        Promise.all([...this.tappedPromises.values()]).finally(() => {
          this.writer.close();
        });
      }
    }
  };
  __namedExportsObject["__chunk_7997"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { ConsoleCallbackHandler: () => c });
    var a = r(6676), n = r(9321);
    function i(e2, t2) {
      return `${e2.open}${t2}${e2.close}`;
    }
    function s(e2, t2) {
      try {
        return JSON.stringify(e2, null, 2);
      } catch (e3) {
        return t2;
      }
    }
    function o(e2) {
      return "string" == typeof e2 ? e2.trim() : null == e2 ? e2 : s(e2, e2.toString());
    }
    function l(e2) {
      if (!e2.end_time)
        return "";
      let t2 = e2.end_time - e2.start_time;
      return t2 < 1e3 ? `${t2}ms` : `${(t2 / 1e3).toFixed(2)}s`;
    }
    let { color: u } = a;
    class c extends n.BaseTracer {
      constructor() {
        super(...arguments), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "console_callback_handler" });
      }
      persistRun(e2) {
        return Promise.resolve();
      }
      getParents(e2) {
        let t2 = [], r2 = e2;
        for (; r2.parent_run_id; ) {
          let e3 = this.runMap.get(r2.parent_run_id);
          if (e3)
            t2.push(e3), r2 = e3;
          else
            break;
        }
        return t2;
      }
      getBreadcrumbs(e2) {
        let t2 = [...this.getParents(e2).reverse(), e2].map((e3, t3, r2) => {
          let n2 = `${e3.execution_order}:${e3.run_type}:${e3.name}`;
          return t3 === r2.length - 1 ? i(a.bold, n2) : n2;
        }).join(" > ");
        return i(u.grey, t2);
      }
      onChainStart(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.green, "[chain/start]")} [${t2}] Entering Chain run with input: ${s(e2.inputs, "[inputs]")}`);
      }
      onChainEnd(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.cyan, "[chain/end]")} [${t2}] [${l(e2)}] Exiting Chain run with output: ${s(e2.outputs, "[outputs]")}`);
      }
      onChainError(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.red, "[chain/error]")} [${t2}] [${l(e2)}] Chain run errored with error: ${s(e2.error, "[error]")}`);
      }
      onLLMStart(e2) {
        let t2 = this.getBreadcrumbs(e2), r2 = "prompts" in e2.inputs ? { prompts: e2.inputs.prompts.map((e3) => e3.trim()) } : e2.inputs;
        console.log(`${i(u.green, "[llm/start]")} [${t2}] Entering LLM run with input: ${s(r2, "[inputs]")}`);
      }
      onLLMEnd(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.cyan, "[llm/end]")} [${t2}] [${l(e2)}] Exiting LLM run with output: ${s(e2.outputs, "[response]")}`);
      }
      onLLMError(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.red, "[llm/error]")} [${t2}] [${l(e2)}] LLM run errored with error: ${s(e2.error, "[error]")}`);
      }
      onToolStart(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.green, "[tool/start]")} [${t2}] Entering Tool run with input: "${o(e2.inputs.input)}"`);
      }
      onToolEnd(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.cyan, "[tool/end]")} [${t2}] [${l(e2)}] Exiting Tool run with output: "${o(e2.outputs?.output)}"`);
      }
      onToolError(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.red, "[tool/error]")} [${t2}] [${l(e2)}] Tool run errored with error: ${s(e2.error, "[error]")}`);
      }
      onRetrieverStart(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.green, "[retriever/start]")} [${t2}] Entering Retriever run with input: ${s(e2.inputs, "[inputs]")}`);
      }
      onRetrieverEnd(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.cyan, "[retriever/end]")} [${t2}] [${l(e2)}] Exiting Retriever run with output: ${s(e2.outputs, "[outputs]")}`);
      }
      onRetrieverError(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.red, "[retriever/error]")} [${t2}] [${l(e2)}] Retriever run errored with error: ${s(e2.error, "[error]")}`);
      }
      onAgentAction(e2) {
        let t2 = this.getBreadcrumbs(e2);
        console.log(`${i(u.blue, "[agent/action]")} [${t2}] Agent selected action: ${s(e2.actions[e2.actions.length - 1], "[action]")}`);
      }
    }
  };
  __namedExportsObject["__chunk_9321"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseTracer: () => s, isBaseTracer: () => i });
    var a = r(7250);
    function n(e2, t2) {
      return e2 && !Array.isArray(e2) && "object" == typeof e2 ? e2 : { [t2]: e2 };
    }
    function i(e2) {
      return "function" == typeof e2._addRunToRunMap;
    }
    class s extends a.BaseCallbackHandler {
      constructor(e2) {
        super(...arguments), Object.defineProperty(this, "runMap", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() });
      }
      copy() {
        return this;
      }
      stringifyError(e2) {
        return e2 instanceof Error ? e2.message + (e2?.stack ? `

${e2.stack}` : "") : "string" == typeof e2 ? e2 : `${e2}`;
      }
      _addChildRun(e2, t2) {
        e2.child_runs.push(t2);
      }
      _addRunToRunMap(e2) {
        let t2 = function(e3, t3, r3) {
          let a2 = r3.toFixed(0).slice(0, 3).padStart(3, "0");
          return `${new Date(e3).toISOString().slice(0, -1)}${a2}Z`.replace(/[-:.]/g, "") + t3;
        }(e2.start_time, e2.id, e2.execution_order), r2 = { ...e2 };
        if (void 0 !== r2.parent_run_id) {
          let e3 = this.runMap.get(r2.parent_run_id);
          e3 && (this._addChildRun(e3, r2), e3.child_execution_order = Math.max(e3.child_execution_order, r2.child_execution_order), r2.trace_id = e3.trace_id, void 0 !== e3.dotted_order && (r2.dotted_order = [e3.dotted_order, t2].join(".")));
        } else
          r2.trace_id = r2.id, r2.dotted_order = t2;
        return this.runMap.set(r2.id, r2), r2;
      }
      async _endTrace(e2) {
        let t2 = void 0 !== e2.parent_run_id && this.runMap.get(e2.parent_run_id);
        t2 ? t2.child_execution_order = Math.max(t2.child_execution_order, e2.child_execution_order) : await this.persistRun(e2), this.runMap.delete(e2.id), await this.onRunUpdate?.(e2);
      }
      _getExecutionOrder(e2) {
        let t2 = void 0 !== e2 && this.runMap.get(e2);
        return t2 ? t2.child_execution_order + 1 : 1;
      }
      _createRunForLLMStart(e2, t2, r2, a2, n2, i2, s2, o) {
        let l = this._getExecutionOrder(a2), u = Date.now(), c = s2 ? { ...n2, metadata: s2 } : n2, d = { id: r2, name: o ?? e2.id[e2.id.length - 1], parent_run_id: a2, start_time: u, serialized: e2, events: [{ name: "start", time: new Date(u).toISOString() }], inputs: { prompts: t2 }, execution_order: l, child_runs: [], child_execution_order: l, run_type: "llm", extra: c ?? {}, tags: i2 || [] };
        return this._addRunToRunMap(d);
      }
      async handleLLMStart(e2, t2, r2, a2, n2, i2, s2, o) {
        let l = this.runMap.get(r2) ?? this._createRunForLLMStart(e2, t2, r2, a2, n2, i2, s2, o);
        return await this.onRunCreate?.(l), await this.onLLMStart?.(l), l;
      }
      _createRunForChatModelStart(e2, t2, r2, a2, n2, i2, s2, o) {
        let l = this._getExecutionOrder(a2), u = Date.now(), c = s2 ? { ...n2, metadata: s2 } : n2, d = { id: r2, name: o ?? e2.id[e2.id.length - 1], parent_run_id: a2, start_time: u, serialized: e2, events: [{ name: "start", time: new Date(u).toISOString() }], inputs: { messages: t2 }, execution_order: l, child_runs: [], child_execution_order: l, run_type: "llm", extra: c ?? {}, tags: i2 || [] };
        return this._addRunToRunMap(d);
      }
      async handleChatModelStart(e2, t2, r2, a2, n2, i2, s2, o) {
        let l = this.runMap.get(r2) ?? this._createRunForChatModelStart(e2, t2, r2, a2, n2, i2, s2, o);
        return await this.onRunCreate?.(l), await this.onLLMStart?.(l), l;
      }
      async handleLLMEnd(e2, t2) {
        let r2 = this.runMap.get(t2);
        if (!r2 || r2?.run_type !== "llm")
          throw Error("No LLM run to end.");
        return r2.end_time = Date.now(), r2.outputs = e2, r2.events.push({ name: "end", time: new Date(r2.end_time).toISOString() }), await this.onLLMEnd?.(r2), await this._endTrace(r2), r2;
      }
      async handleLLMError(e2, t2) {
        let r2 = this.runMap.get(t2);
        if (!r2 || r2?.run_type !== "llm")
          throw Error("No LLM run to end.");
        return r2.end_time = Date.now(), r2.error = this.stringifyError(e2), r2.events.push({ name: "error", time: new Date(r2.end_time).toISOString() }), await this.onLLMError?.(r2), await this._endTrace(r2), r2;
      }
      _createRunForChainStart(e2, t2, r2, a2, n2, i2, s2, o) {
        let l = this._getExecutionOrder(a2), u = Date.now(), c = { id: r2, name: o ?? e2.id[e2.id.length - 1], parent_run_id: a2, start_time: u, serialized: e2, events: [{ name: "start", time: new Date(u).toISOString() }], inputs: t2, execution_order: l, child_execution_order: l, run_type: s2 ?? "chain", child_runs: [], extra: i2 ? { metadata: i2 } : {}, tags: n2 || [] };
        return this._addRunToRunMap(c);
      }
      async handleChainStart(e2, t2, r2, a2, n2, i2, s2, o) {
        let l = this.runMap.get(r2) ?? this._createRunForChainStart(e2, t2, r2, a2, n2, i2, s2, o);
        return await this.onRunCreate?.(l), await this.onChainStart?.(l), l;
      }
      async handleChainEnd(e2, t2, r2, a2, i2) {
        let s2 = this.runMap.get(t2);
        if (!s2)
          throw Error("No chain run to end.");
        return s2.end_time = Date.now(), s2.outputs = n(e2, "output"), s2.events.push({ name: "end", time: new Date(s2.end_time).toISOString() }), i2?.inputs !== void 0 && (s2.inputs = n(i2.inputs, "input")), await this.onChainEnd?.(s2), await this._endTrace(s2), s2;
      }
      async handleChainError(e2, t2, r2, a2, i2) {
        let s2 = this.runMap.get(t2);
        if (!s2)
          throw Error("No chain run to end.");
        return s2.end_time = Date.now(), s2.error = this.stringifyError(e2), s2.events.push({ name: "error", time: new Date(s2.end_time).toISOString() }), i2?.inputs !== void 0 && (s2.inputs = n(i2.inputs, "input")), await this.onChainError?.(s2), await this._endTrace(s2), s2;
      }
      _createRunForToolStart(e2, t2, r2, a2, n2, i2, s2) {
        let o = this._getExecutionOrder(a2), l = Date.now(), u = { id: r2, name: s2 ?? e2.id[e2.id.length - 1], parent_run_id: a2, start_time: l, serialized: e2, events: [{ name: "start", time: new Date(l).toISOString() }], inputs: { input: t2 }, execution_order: o, child_execution_order: o, run_type: "tool", child_runs: [], extra: i2 ? { metadata: i2 } : {}, tags: n2 || [] };
        return this._addRunToRunMap(u);
      }
      async handleToolStart(e2, t2, r2, a2, n2, i2, s2) {
        let o = this.runMap.get(r2) ?? this._createRunForToolStart(e2, t2, r2, a2, n2, i2, s2);
        return await this.onRunCreate?.(o), await this.onToolStart?.(o), o;
      }
      async handleToolEnd(e2, t2) {
        let r2 = this.runMap.get(t2);
        if (!r2 || r2?.run_type !== "tool")
          throw Error("No tool run to end");
        return r2.end_time = Date.now(), r2.outputs = { output: e2 }, r2.events.push({ name: "end", time: new Date(r2.end_time).toISOString() }), await this.onToolEnd?.(r2), await this._endTrace(r2), r2;
      }
      async handleToolError(e2, t2) {
        let r2 = this.runMap.get(t2);
        if (!r2 || r2?.run_type !== "tool")
          throw Error("No tool run to end");
        return r2.end_time = Date.now(), r2.error = this.stringifyError(e2), r2.events.push({ name: "error", time: new Date(r2.end_time).toISOString() }), await this.onToolError?.(r2), await this._endTrace(r2), r2;
      }
      async handleAgentAction(e2, t2) {
        let r2 = this.runMap.get(t2);
        r2 && r2?.run_type === "chain" && (r2.actions = r2.actions || [], r2.actions.push(e2), r2.events.push({ name: "agent_action", time: new Date().toISOString(), kwargs: { action: e2 } }), await this.onAgentAction?.(r2));
      }
      async handleAgentEnd(e2, t2) {
        let r2 = this.runMap.get(t2);
        r2 && r2?.run_type === "chain" && (r2.events.push({ name: "agent_end", time: new Date().toISOString(), kwargs: { action: e2 } }), await this.onAgentEnd?.(r2));
      }
      _createRunForRetrieverStart(e2, t2, r2, a2, n2, i2, s2) {
        let o = this._getExecutionOrder(a2), l = Date.now(), u = { id: r2, name: s2 ?? e2.id[e2.id.length - 1], parent_run_id: a2, start_time: l, serialized: e2, events: [{ name: "start", time: new Date(l).toISOString() }], inputs: { query: t2 }, execution_order: o, child_execution_order: o, run_type: "retriever", child_runs: [], extra: i2 ? { metadata: i2 } : {}, tags: n2 || [] };
        return this._addRunToRunMap(u);
      }
      async handleRetrieverStart(e2, t2, r2, a2, n2, i2, s2) {
        let o = this.runMap.get(r2) ?? this._createRunForRetrieverStart(e2, t2, r2, a2, n2, i2, s2);
        return await this.onRunCreate?.(o), await this.onRetrieverStart?.(o), o;
      }
      async handleRetrieverEnd(e2, t2) {
        let r2 = this.runMap.get(t2);
        if (!r2 || r2?.run_type !== "retriever")
          throw Error("No retriever run to end");
        return r2.end_time = Date.now(), r2.outputs = { documents: e2 }, r2.events.push({ name: "end", time: new Date(r2.end_time).toISOString() }), await this.onRetrieverEnd?.(r2), await this._endTrace(r2), r2;
      }
      async handleRetrieverError(e2, t2) {
        let r2 = this.runMap.get(t2);
        if (!r2 || r2?.run_type !== "retriever")
          throw Error("No retriever run to end");
        return r2.end_time = Date.now(), r2.error = this.stringifyError(e2), r2.events.push({ name: "error", time: new Date(r2.end_time).toISOString() }), await this.onRetrieverError?.(r2), await this._endTrace(r2), r2;
      }
      async handleText(e2, t2) {
        let r2 = this.runMap.get(t2);
        r2 && r2?.run_type === "chain" && (r2.events.push({ name: "text", time: new Date().toISOString(), kwargs: { text: e2 } }), await this.onText?.(r2));
      }
      async handleLLMNewToken(e2, t2, r2, a2, n2, i2) {
        let s2 = this.runMap.get(r2);
        if (!s2 || s2?.run_type !== "llm")
          throw Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
        return s2.events.push({ name: "new_token", time: new Date().toISOString(), kwargs: { token: e2, idx: t2, chunk: i2?.chunk } }), await this.onLLMNewToken?.(s2, e2, { chunk: i2?.chunk }), s2;
      }
    }
  };
  __namedExportsObject["__chunk_2493"] = (e, t, r) => {
    "use strict";
    function a(e2) {
      return !!(e2 && "object" == typeof e2 && "type" in e2 && "tool_call" === e2.type);
    }
    r.d(t, { Y: () => n, u: () => a });
    class n extends Error {
      constructor(e2, t2) {
        super(e2), Object.defineProperty(this, "output", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.output = t2;
      }
    }
  };
  __namedExportsObject["__chunk_5434"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseToolkit: () => m, DynamicStructuredTool: () => f, DynamicTool: () => p, StructuredTool: () => d, Tool: () => h, ToolInputParsingException: () => u.Y, tool: () => g });
    var a = r(5817), n = r(112), i = r(8718), s = r(3735), o = r(4806), l = r(647), u = r(2493), c = r(1742);
    class d extends i.BaseLangChain {
      get lc_namespace() {
        return ["langchain", "tools"];
      }
      constructor(e2) {
        super(e2 ?? {}), Object.defineProperty(this, "returnDirect", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "verboseParsingErrors", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "responseFormat", { enumerable: true, configurable: true, writable: true, value: "content" }), this.verboseParsingErrors = e2?.verboseParsingErrors ?? this.verboseParsingErrors, this.responseFormat = e2?.responseFormat ?? this.responseFormat;
      }
      async invoke(e2, t2) {
        let r2, a2;
        (0, u.u)(e2) ? (r2 = e2.id, a2 = e2.args) : a2 = e2;
        let n2 = (0, s.LE)(t2);
        return this.call(a2, { ...n2, configurable: { ...n2.configurable, tool_call_id: r2 } });
      }
      async call(e2, t2, r2) {
        let a2, i2, s2, l2, c2;
        try {
          a2 = await this.schema.parseAsync(e2);
        } catch (r3) {
          let t3 = "Received tool input did not match expected schema";
          throw this.verboseParsingErrors && (t3 = `${t3}
Details: ${r3.message}`), new u.Y(t3, JSON.stringify(e2));
        }
        let d2 = (0, n.parseCallbackConfigArg)(t2), h2 = await n.CallbackManager.configure(d2.callbacks, this.callbacks, d2.tags || r2, this.tags, d2.metadata, this.metadata, { verbose: this.verbose }), p2 = await h2?.handleToolStart(this.toJSON(), "string" == typeof a2 ? a2 : JSON.stringify(a2), d2.runId, void 0, void 0, void 0, d2.runName);
        delete d2.runId;
        try {
          i2 = await this._call(a2, p2, d2);
        } catch (e3) {
          throw await p2?.handleToolError(e3), e3;
        }
        if ("content_and_artifact" === this.responseFormat) {
          if (Array.isArray(i2) && 2 === i2.length)
            [s2, l2] = i2;
          else
            throw Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(i2)}`);
        } else
          s2 = i2;
        d2 && "configurable" in d2 && (c2 = d2.configurable.tool_call_id);
        let f2 = function(e3) {
          let { content: t3, artifact: r3, toolCallId: a3 } = e3;
          return a3 ? new o.Cq("string" == typeof t3 || Array.isArray(t3) && t3.every((e4) => "object" == typeof e4) ? { content: t3, artifact: r3, tool_call_id: a3, name: e3.name } : { content: function(e4) {
            try {
              return JSON.stringify(e4, null, 2);
            } catch (t4) {
              return `${e4}`;
            }
          }(t3), artifact: r3, tool_call_id: a3, name: e3.name }) : t3;
        }({ content: s2, artifact: l2, toolCallId: c2, name: this.name });
        return await p2?.handleToolEnd(f2), f2;
      }
    }
    class h extends d {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "schema", { enumerable: true, configurable: true, writable: true, value: a.z.object({ input: a.z.string().optional() }).transform((e3) => e3.input) });
      }
      call(e2, t2) {
        return super.call("string" != typeof e2 && e2 ? e2 : { input: e2 }, t2);
      }
    }
    class p extends h {
      static lc_name() {
        return "DynamicTool";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "description", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "func", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.name = e2.name, this.description = e2.description, this.func = e2.func, this.returnDirect = e2.returnDirect ?? this.returnDirect;
      }
      async call(e2, t2) {
        let r2 = (0, n.parseCallbackConfigArg)(t2);
        return void 0 === r2.runName && (r2.runName = this.name), super.call(e2, r2);
      }
      async _call(e2, t2, r2) {
        return this.func(e2, t2, r2);
      }
    }
    class f extends d {
      static lc_name() {
        return "DynamicStructuredTool";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "description", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "func", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "schema", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.name = e2.name, this.description = e2.description, this.func = e2.func, this.returnDirect = e2.returnDirect ?? this.returnDirect, this.schema = (0, c.F)(e2.schema) ? e2.schema : a.z.object({}).passthrough();
      }
      async call(e2, t2, r2) {
        let a2 = (0, n.parseCallbackConfigArg)(t2);
        return void 0 === a2.runName && (a2.runName = this.name), super.call(e2, a2, r2);
      }
      _call(e2, t2, r2) {
        return this.func(e2, t2, r2);
      }
    }
    class m {
      getTools() {
        return this.tools;
      }
    }
    function g(e2, t2) {
      if (!t2.schema || (0, c.F)(t2.schema) && (!("shape" in t2.schema) || !t2.schema.shape))
        return new p({ ...t2, description: t2.description ?? t2.schema?.description ?? `${t2.name} tool`, func: async (t3, r3, a2) => new Promise((n2, i2) => {
          let o2 = (0, s.q)(a2, { callbacks: r3?.getChild() });
          l.AO.runWithConfig((0, s.yG)(o2), async () => {
            try {
              n2(e2(t3, o2));
            } catch (e3) {
              i2(e3);
            }
          });
        }) });
      let r2 = t2.description ?? t2.schema.description ?? `${t2.name} tool`;
      return new f({ ...t2, description: r2, schema: t2.schema, func: async (t3, r3, a2) => new Promise((n2, i2) => {
        let o2 = (0, s.q)(a2, { callbacks: r3?.getChild() });
        l.AO.runWithConfig((0, s.yG)(o2), async () => {
          try {
            n2(e2(t3, o2));
          } catch (e3) {
            i2(e3);
          }
        });
      }) });
    }
  };
  __namedExportsObject["__chunk_647"] = (e, t, r) => {
    "use strict";
    r.d(t, { AO: () => d });
    var a = r(6953), n = r(5285), i = r(112);
    class s {
      getStore() {
      }
      run(e2, t2) {
        return t2();
      }
      enterWith(e2) {
      }
    }
    let o = new s(), l = Symbol.for("lc:child_config"), u = Symbol.for("lc:context_variables");
    class c {
      getInstance() {
        return (0, n.IU)() ?? o;
      }
      getRunnableConfig() {
        let e2 = this.getInstance();
        return e2.getStore()?.extra?.[l];
      }
      runWithConfig(e2, t2, r2) {
        let n2;
        let s2 = i.CallbackManager._configureSync(e2?.callbacks, void 0, e2?.tags, void 0, e2?.metadata), o2 = this.getInstance(), c2 = o2.getStore(), d2 = s2?.getParentRunId(), h = s2?.handlers?.find((e3) => e3?.name === "langchain_tracer");
        return h && d2 ? n2 = h.convertToRunTree(d2) : r2 || (n2 = new a.IV({ name: "<runnable_lambda>", tracingEnabled: false })), n2 && (n2.extra = { ...n2.extra, [l]: e2 }), void 0 !== c2 && void 0 !== c2[u] && (n2[u] = c2[u]), o2.run(n2, t2);
      }
      initializeGlobalInstance(e2) {
        void 0 === (0, n.IU)() && (0, n.eO)(e2);
      }
    }
    let d = new c();
  };
  __namedExportsObject["__chunk_5285"] = (e, t, r) => {
    "use strict";
    r.d(t, { IU: () => i, eO: () => n });
    let a = Symbol.for("ls:tracing_async_local_storage"), n = (e2) => {
      globalThis[a] = e2;
    }, i = () => globalThis[a];
  };
  __namedExportsObject["__chunk_4939"] = (e, t, r) => {
    "use strict";
    function a(e2) {
      return !!e2 && e2.lc_runnable;
    }
    r.d(t, { H: () => n, T: () => a });
    class n {
      constructor(e2) {
        Object.defineProperty(this, "includeNames", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "includeTypes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "includeTags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeNames", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeTypes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "excludeTags", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.includeNames = e2.includeNames, this.includeTypes = e2.includeTypes, this.includeTags = e2.includeTags, this.excludeNames = e2.excludeNames, this.excludeTypes = e2.excludeTypes, this.excludeTags = e2.excludeTags;
      }
      includeEvent(e2, t2) {
        let r2 = void 0 === this.includeNames && void 0 === this.includeTypes && void 0 === this.includeTags, a2 = e2.tags ?? [];
        return void 0 !== this.includeNames && (r2 = r2 || this.includeNames.includes(e2.name)), void 0 !== this.includeTypes && (r2 = r2 || this.includeTypes.includes(t2)), void 0 !== this.includeTags && (r2 = r2 || a2.some((e3) => this.includeTags?.includes(e3))), void 0 !== this.excludeNames && (r2 = r2 && !this.excludeNames.includes(e2.name)), void 0 !== this.excludeTypes && (r2 = r2 && !this.excludeTypes.includes(t2)), void 0 !== this.excludeTags && (r2 = r2 && a2.every((e3) => !this.excludeTags?.includes(e3))), r2;
      }
    }
  };
  __namedExportsObject["__chunk_5314"] = (e, t, r) => {
    "use strict";
    r.d(t, { s: () => s });
    var a = r(541), n = r(1184), i = r(3735);
    class s extends n.eq {
      static lc_name() {
        return "RunnablePassthrough";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "func", { enumerable: true, configurable: true, writable: true, value: void 0 }), e2 && (this.func = e2.func);
      }
      async invoke(e2, t2) {
        let r2 = (0, i.LE)(t2);
        return this.func && await this.func(e2, r2), this._callWithConfig((e3) => Promise.resolve(e3), e2, r2);
      }
      async *transform(e2, t2) {
        let r2;
        let n2 = (0, i.LE)(t2), s2 = true;
        for await (let t3 of this._transformStreamWithConfig(e2, (e3) => e3, n2))
          if (yield t3, s2) {
            if (void 0 === r2)
              r2 = t3;
            else
              try {
                r2 = (0, a.concat)(r2, t3);
              } catch {
                r2 = void 0, s2 = false;
              }
          }
        this.func && void 0 !== r2 && await this.func(r2, n2);
      }
      static assign(e2) {
        return new n.Vh(new n.dT({ steps: e2 }));
      }
    }
  };
  __namedExportsObject["__chunk_3874"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { RouterRunnable: () => s, Runnable: () => a.eq, RunnableAssign: () => a.Vh, RunnableBinding: () => a.pX, RunnableBranch: () => l, RunnableEach: () => a.ft, RunnableLambda: () => a.Y8, RunnableMap: () => a.dT, RunnableParallel: () => a.bq, RunnablePassthrough: () => i.s, RunnablePick: () => a.RJ, RunnableRetry: () => a.Dk, RunnableSequence: () => a.lW, RunnableToolLike: () => a.Th, RunnableWithFallbacks: () => a.cx, RunnableWithMessageHistory: () => c, _coerceToRunnable: () => a.k9, ensureConfig: () => n.LE, getCallbackManagerForConfig: () => n.Le, mergeConfigs: () => n.t8, patchConfig: () => n.q, pickRunnableConfigKeys: () => n.yG });
    var a = r(1184), n = r(3735), i = r(5314);
    class s extends a.eq {
      static lc_name() {
        return "RouterRunnable";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "runnables", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.runnables = e2.runnables;
      }
      async invoke(e2, t2) {
        let { key: r2, input: a2 } = e2, i2 = this.runnables[r2];
        if (void 0 === i2)
          throw Error(`No runnable associated with key "${r2}".`);
        return i2.invoke(a2, (0, n.LE)(t2));
      }
      async batch(e2, t2, r2) {
        let a2 = e2.map((e3) => e3.key), n2 = e2.map((e3) => e3.input);
        if (void 0 !== a2.find((e3) => void 0 === this.runnables[e3]))
          throw Error("One or more keys do not have a corresponding runnable.");
        let i2 = a2.map((e3) => this.runnables[e3]), s2 = this._getOptionsList(t2 ?? {}, e2.length), o2 = s2[0]?.maxConcurrency ?? r2?.maxConcurrency, l2 = o2 && o2 > 0 ? o2 : e2.length, u2 = [];
        for (let e3 = 0; e3 < n2.length; e3 += l2) {
          let t3 = n2.slice(e3, e3 + l2).map((e4, t4) => i2[t4].invoke(e4, s2[t4])), r3 = await Promise.all(t3);
          u2.push(r3);
        }
        return u2.flat();
      }
      async stream(e2, t2) {
        let { key: r2, input: a2 } = e2, n2 = this.runnables[r2];
        if (void 0 === n2)
          throw Error(`No runnable associated with key "${r2}".`);
        return n2.stream(a2, t2);
      }
    }
    var o = r(541);
    class l extends a.eq {
      static lc_name() {
        return "RunnableBranch";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "default", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "branches", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.branches = e2.branches, this.default = e2.default;
      }
      static from(e2) {
        if (e2.length < 1)
          throw Error("RunnableBranch requires at least one branch");
        return new this({ branches: e2.slice(0, -1).map(([e3, t2]) => [(0, a.k9)(e3), (0, a.k9)(t2)]), default: (0, a.k9)(e2[e2.length - 1]) });
      }
      async _invoke(e2, t2, r2) {
        let a2;
        for (let i2 = 0; i2 < this.branches.length; i2 += 1) {
          let [s2, o2] = this.branches[i2];
          if (await s2.invoke(e2, (0, n.q)(t2, { callbacks: r2?.getChild(`condition:${i2 + 1}`) }))) {
            a2 = await o2.invoke(e2, (0, n.q)(t2, { callbacks: r2?.getChild(`branch:${i2 + 1}`) }));
            break;
          }
        }
        return a2 || (a2 = await this.default.invoke(e2, (0, n.q)(t2, { callbacks: r2?.getChild("branch:default") }))), a2;
      }
      async invoke(e2, t2 = {}) {
        return this._callWithConfig(this._invoke, e2, t2);
      }
      async *_streamIterator(e2, t2) {
        let r2, i2;
        let s2 = await (0, n.Le)(t2), l2 = await s2?.handleChainStart(this.toJSON(), a.Uv(e2, "input"), t2?.runId, void 0, void 0, void 0, t2?.runName), u2 = true;
        try {
          for (let a2 = 0; a2 < this.branches.length; a2 += 1) {
            let [s3, c2] = this.branches[a2];
            if (await s3.invoke(e2, (0, n.q)(t2, { callbacks: l2?.getChild(`condition:${a2 + 1}`) }))) {
              for await (let s4 of i2 = await c2.stream(e2, (0, n.q)(t2, { callbacks: l2?.getChild(`branch:${a2 + 1}`) })))
                if (yield s4, u2) {
                  if (void 0 === r2)
                    r2 = s4;
                  else
                    try {
                      r2 = (0, o.concat)(r2, s4);
                    } catch (e3) {
                      r2 = void 0, u2 = false;
                    }
                }
              break;
            }
          }
          if (void 0 === i2) {
            for await (let a2 of i2 = await this.default.stream(e2, (0, n.q)(t2, { callbacks: l2?.getChild("branch:default") })))
              if (yield a2, u2) {
                if (void 0 === r2)
                  r2 = a2;
                else
                  try {
                    r2 = (0, o.concat)(r2, a2);
                  } catch (e3) {
                    r2 = void 0, u2 = false;
                  }
              }
          }
        } catch (e3) {
          throw await l2?.handleChainError(e3), e3;
        }
        await l2?.handleChainEnd(r2 ?? {});
      }
    }
    var u = r(9730);
    class c extends a.pX {
      constructor(e2) {
        let t2 = a.Y8.from((e3, t3) => this._enterHistory(e3, t3 ?? {})).withConfig({ runName: "loadHistory" }), r2 = e2.historyMessagesKey ?? e2.inputMessagesKey;
        r2 && (t2 = i.s.assign({ [r2]: t2 }).withConfig({ runName: "insertHistory" })), super({ ...e2, config: e2.config ?? {}, bound: t2.pipe(e2.runnable.withListeners({ onEnd: (e3, t3) => this._exitHistory(e3, t3 ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" }) }), Object.defineProperty(this, "runnable", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "inputMessagesKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "outputMessagesKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "historyMessagesKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "getMessageHistory", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.runnable = e2.runnable, this.getMessageHistory = e2.getMessageHistory, this.inputMessagesKey = e2.inputMessagesKey, this.outputMessagesKey = e2.outputMessagesKey, this.historyMessagesKey = e2.historyMessagesKey;
      }
      _getInputMessages(e2) {
        let t2;
        if ("object" != typeof e2 || Array.isArray(e2) || (0, u.isBaseMessage)(e2))
          t2 = e2;
        else {
          let r2;
          r2 = this.inputMessagesKey ? this.inputMessagesKey : 1 === Object.keys(e2).length ? Object.keys(e2)[0] : "input", t2 = Array.isArray(e2[r2]) && Array.isArray(e2[r2][0]) ? e2[r2][0] : e2[r2];
        }
        if ("string" == typeof t2)
          return [new u.HumanMessage(t2)];
        if (Array.isArray(t2))
          return t2;
        if ((0, u.isBaseMessage)(t2))
          return [t2];
        throw Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(t2, null, 2)}`);
      }
      _getOutputMessages(e2) {
        let t2;
        if (Array.isArray(e2) || (0, u.isBaseMessage)(e2) || "string" == typeof e2)
          t2 = e2;
        else {
          let r2;
          r2 = void 0 !== this.outputMessagesKey ? this.outputMessagesKey : 1 === Object.keys(e2).length ? Object.keys(e2)[0] : "output", t2 = void 0 !== e2.generations ? e2.generations[0][0].message : e2[r2];
        }
        if ("string" == typeof t2)
          return [new u.AIMessage(t2)];
        if (Array.isArray(t2))
          return t2;
        if ((0, u.isBaseMessage)(t2))
          return [t2];
        throw Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(t2, null, 2)}`);
      }
      async _enterHistory(e2, t2) {
        let r2 = t2?.configurable?.messageHistory, a2 = await r2.getMessages();
        return void 0 === this.historyMessagesKey ? a2.concat(this._getInputMessages(e2)) : a2;
      }
      async _exitHistory(e2, t2) {
        let r2;
        let a2 = t2.configurable?.messageHistory;
        r2 = Array.isArray(e2.inputs) && Array.isArray(e2.inputs[0]) ? e2.inputs[0] : e2.inputs;
        let n2 = this._getInputMessages(r2);
        if (void 0 === this.historyMessagesKey) {
          let e3 = await a2.getMessages();
          n2 = n2.slice(e3.length);
        }
        let i2 = e2.outputs;
        if (!i2)
          throw Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(e2, null, 2)}`);
        let s2 = this._getOutputMessages(i2);
        await a2.addMessages([...n2, ...s2]);
      }
      async _mergeConfig(...e2) {
        let t2 = await super._mergeConfig(...e2);
        if (!t2.configurable || !t2.configurable.sessionId) {
          let e3 = { [this.inputMessagesKey ?? "input"]: "foo" };
          throw Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(e3)}, ${JSON.stringify({ configurable: { sessionId: "123" } })})`);
        }
        let { sessionId: r2 } = t2.configurable;
        return t2.configurable.messageHistory = await this.getMessageHistory(r2), t2;
      }
    }
  };
  __namedExportsObject["__chunk_6378"] = (e, t, r) => {
    "use strict";
    r.d(t, { k: () => c });
    var a = r(7026), n = r(8212), i = r(2208), s = r(4939);
    function o(e2) {
      return e2.replace(/[^a-zA-Z-_0-9]/g, "_");
    }
    let l = ["*", "_", "`"];
    async function u(e2, t2) {
      let { backgroundColor: r2 = "white" } = t2 ?? {}, a2 = btoa(e2);
      void 0 === r2 || /^#(?:[0-9a-fA-F]{3}){1,2}$/.test(r2) || (r2 = `!${r2}`);
      let n2 = `https://mermaid.ink/img/${a2}?bgColor=${r2}`, i2 = await fetch(n2);
      if (!i2.ok)
        throw Error(`Failed to render the graph using the Mermaid.INK API.
Status code: ${i2.status}
Status text: ${i2.statusText}`);
      return await i2.blob();
    }
    class c {
      constructor(e2) {
        Object.defineProperty(this, "nodes", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "edges", { enumerable: true, configurable: true, writable: true, value: [] }), this.nodes = e2?.nodes ?? this.nodes, this.edges = e2?.edges ?? this.edges;
      }
      toJSON() {
        let e2 = {};
        return Object.values(this.nodes).forEach((t2, r2) => {
          e2[t2.id] = (0, n.Z)(t2.id) ? r2 : t2.id;
        }), { nodes: Object.values(this.nodes).map((t2) => ({ id: e2[t2.id], ...(0, s.T)(t2.data) ? { type: "runnable", data: { id: t2.data.lc_id, name: t2.data.getName() } } : { type: "schema", data: { ...(0, a.Y_)(t2.data.schema), title: t2.data.name } } })), edges: this.edges.map((t2) => {
          let r2 = { source: e2[t2.source], target: e2[t2.target] };
          return void 0 !== t2.data && (r2.data = t2.data), void 0 !== t2.conditional && (r2.conditional = t2.conditional), r2;
        }) };
      }
      addNode(e2, t2, r2) {
        if (void 0 !== t2 && void 0 !== this.nodes[t2])
          throw Error(`Node with id ${t2} already exists`);
        let a2 = t2 ?? (0, i.Z)(), o2 = { id: a2, data: e2, name: function(e3, t3) {
          if (void 0 !== e3 && !(0, n.Z)(e3))
            return e3;
          if (!(0, s.T)(t3))
            return t3.name ?? "UnknownSchema";
          try {
            let e4 = t3.getName();
            return e4 = e4.startsWith("Runnable") ? e4.slice(8) : e4;
          } catch (e4) {
            return t3.getName();
          }
        }(t2, e2), metadata: r2 };
        return this.nodes[a2] = o2, o2;
      }
      removeNode(e2) {
        delete this.nodes[e2.id], this.edges = this.edges.filter((t2) => t2.source !== e2.id && t2.target !== e2.id);
      }
      addEdge(e2, t2, r2, a2) {
        if (void 0 === this.nodes[e2.id])
          throw Error(`Source node ${e2.id} not in graph`);
        if (void 0 === this.nodes[t2.id])
          throw Error(`Target node ${t2.id} not in graph`);
        let n2 = { source: e2.id, target: t2.id, data: r2, conditional: a2 };
        return this.edges.push(n2), n2;
      }
      firstNode() {
        return d(this);
      }
      lastNode() {
        return h(this);
      }
      extend(e2, t2 = "") {
        let r2 = t2;
        Object.values(e2.nodes).map((e3) => e3.id).every(n.Z) && (r2 = "");
        let a2 = (e3) => r2 ? `${r2}:${e3}` : e3;
        Object.entries(e2.nodes).forEach(([e3, t3]) => {
          this.nodes[a2(e3)] = { ...t3, id: a2(e3) };
        });
        let i2 = e2.edges.map((e3) => ({ ...e3, source: a2(e3.source), target: a2(e3.target) }));
        this.edges = [...this.edges, ...i2];
        let s2 = e2.firstNode(), o2 = e2.lastNode();
        return [s2 ? { id: a2(s2.id), data: s2.data } : void 0, o2 ? { id: a2(o2.id), data: o2.data } : void 0];
      }
      trimFirstNode() {
        let e2 = this.firstNode();
        e2 && d(this, [e2.id]) && this.removeNode(e2);
      }
      trimLastNode() {
        let e2 = this.lastNode();
        e2 && h(this, [e2.id]) && this.removeNode(e2);
      }
      reid() {
        let e2 = Object.fromEntries(Object.values(this.nodes).map((e3) => [e3.id, e3.name])), t2 = /* @__PURE__ */ new Map();
        Object.values(e2).forEach((e3) => {
          t2.set(e3, (t2.get(e3) || 0) + 1);
        });
        let r2 = (r3) => {
          let a2 = e2[r3];
          return (0, n.Z)(r3) && 1 === t2.get(a2) ? a2 : r3;
        };
        return new c({ nodes: Object.fromEntries(Object.entries(this.nodes).map(([e3, t3]) => [r2(e3), { ...t3, id: r2(e3) }])), edges: this.edges.map((e3) => ({ ...e3, source: r2(e3.source), target: r2(e3.target) })) });
      }
      drawMermaid(e2) {
        let { withStyles: t2, curveStyle: r2, nodeColors: a2 = { default: "fill:#f2f0ff,line-height:1.2", first: "fill-opacity:0", last: "fill:#bfb6fc" }, wrapLabelNWords: n2 } = e2 ?? {}, i2 = this.reid(), s2 = i2.firstNode(), u2 = i2.lastNode();
        return function(e3, t3, r3) {
          let { firstNode: a3, lastNode: n3, nodeColors: i3, withStyles: s3 = true, curveStyle: u3 = "linear", wrapLabelNWords: c2 = 9 } = r3 ?? {}, d2 = s3 ? `%%{init: {'flowchart': {'curve': '${u3}'}}}%%
graph TD;
` : "graph TD;\n";
          if (s3) {
            let t4 = "default", r4 = { [t4]: "{0}({1})" };
            for (let [i4, s4] of (void 0 !== a3 && (r4[a3] = "{0}([{1}]):::first"), void 0 !== n3 && (r4[n3] = "{0}([{1}]):::last"), Object.entries(e3))) {
              let e4 = s4.name.split(":").pop() ?? "", a4 = l.some((t5) => e4.startsWith(t5) && e4.endsWith(t5)) ? `<p>${e4}</p>` : e4;
              Object.keys(s4.metadata ?? {}).length && (a4 += `<hr/><small><em>${Object.entries(s4.metadata ?? {}).map(([e5, t5]) => `${e5} = ${t5}`).join("\n")}</em></small>`);
              let n4 = (r4[i4] ?? r4[t4]).replace("{0}", o(i4)).replace("{1}", a4);
              d2 += `	${n4}
`;
            }
          }
          let h2 = {};
          for (let e4 of t3) {
            let t4 = e4.source.split(":"), r4 = e4.target.split(":"), a4 = t4.filter((e5, t5) => e5 === r4[t5]).join(":");
            h2[a4] || (h2[a4] = []), h2[a4].push(e4);
          }
          let p = /* @__PURE__ */ new Set();
          function f(e4, t4) {
            let r4 = 1 === e4.length && e4[0].source === e4[0].target;
            if (t4 && !r4) {
              let e5 = t4.split(":").pop();
              if (p.has(e5))
                throw Error(`Found duplicate subgraph '${e5}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
              p.add(e5), d2 += `	subgraph ${e5}
`;
            }
            for (let t5 of e4) {
              let { source: e5, target: r5, data: a4, conditional: n4 } = t5, i4 = "";
              if (void 0 !== a4) {
                let e6 = a4, t6 = e6.split(" ");
                t6.length > c2 && (e6 = Array.from({ length: Math.ceil(t6.length / c2) }, (e7, r6) => t6.slice(r6 * c2, (r6 + 1) * c2).join(" ")).join("&nbsp;<br>&nbsp;")), i4 = n4 ? ` -. &nbsp;${e6}&nbsp; .-> ` : ` -- &nbsp;${e6}&nbsp; --> `;
              } else
                i4 = n4 ? " -.-> " : " --> ";
              d2 += `	${o(e5)}${i4}${o(r5)};
`;
            }
            for (let e5 in h2)
              e5.startsWith(`${t4}:`) && e5 !== t4 && f(h2[e5], e5);
            t4 && !r4 && (d2 += "	end\n");
          }
          for (let e4 in f(h2[""] ?? [], ""), h2)
            e4.includes(":") || "" === e4 || f(h2[e4], e4);
          return s3 && (d2 += function(e4) {
            let t4 = "";
            for (let [r4, a4] of Object.entries(e4))
              t4 += `	classDef ${r4} ${a4};
`;
            return t4;
          }(i3 ?? {})), d2;
        }(i2.nodes, i2.edges, { firstNode: s2?.id, lastNode: u2?.id, withStyles: t2, curveStyle: r2, nodeColors: a2, wrapLabelNWords: n2 });
      }
      async drawMermaidPng(e2) {
        return u(this.drawMermaid(e2), { backgroundColor: e2?.backgroundColor });
      }
    }
    function d(e2, t2 = []) {
      let r2 = new Set(e2.edges.filter((e3) => !t2.includes(e3.source)).map((e3) => e3.target)), a2 = [];
      for (let n2 of Object.values(e2.nodes))
        t2.includes(n2.id) || r2.has(n2.id) || a2.push(n2);
      return 1 === a2.length ? a2[0] : void 0;
    }
    function h(e2, t2 = []) {
      let r2 = new Set(e2.edges.filter((e3) => !t2.includes(e3.target)).map((e3) => e3.source)), a2 = [];
      for (let n2 of Object.values(e2.nodes))
        t2.includes(n2.id) || r2.has(n2.id) || a2.push(n2);
      return 1 === a2.length ? a2[0] : void 0;
    }
  };
  __namedExportsObject["__chunk_3735"] = (e, t, r) => {
    "use strict";
    r.d(t, { LE: () => u, Le: () => s, ov: () => i, q: () => c, t8: () => o, yG: () => d });
    var a = r(112), n = r(647);
    let i = 25;
    async function s(e2) {
      return a.CallbackManager._configureSync(e2?.callbacks, void 0, e2?.tags, void 0, e2?.metadata);
    }
    function o(...e2) {
      let t2 = {};
      for (let r2 of e2.filter((e3) => !!e3))
        for (let e3 of Object.keys(r2))
          if ("metadata" === e3)
            t2[e3] = { ...t2[e3], ...r2[e3] };
          else if ("tags" === e3) {
            let a2 = t2[e3] ?? [];
            t2[e3] = [...new Set(a2.concat(r2[e3] ?? []))];
          } else if ("configurable" === e3)
            t2[e3] = { ...t2[e3], ...r2[e3] };
          else if ("timeout" === e3)
            void 0 === t2.timeout ? t2.timeout = r2.timeout : void 0 !== r2.timeout && (t2.timeout = Math.min(t2.timeout, r2.timeout));
          else if ("signal" === e3)
            void 0 === t2.signal ? t2.signal = r2.signal : void 0 !== r2.signal && ("any" in AbortSignal ? t2.signal = AbortSignal.any([t2.signal, r2.signal]) : t2.signal = r2.signal);
          else if ("callbacks" === e3) {
            let e4 = t2.callbacks, n2 = r2.callbacks;
            if (Array.isArray(n2)) {
              if (e4) {
                if (Array.isArray(e4))
                  t2.callbacks = e4.concat(n2);
                else {
                  let r3 = e4.copy();
                  for (let e5 of n2)
                    r3.addHandler((0, a.ensureHandler)(e5), true);
                  t2.callbacks = r3;
                }
              } else
                t2.callbacks = n2;
            } else if (n2) {
              if (e4) {
                if (Array.isArray(e4)) {
                  let r3 = n2.copy();
                  for (let t3 of e4)
                    r3.addHandler((0, a.ensureHandler)(t3), true);
                  t2.callbacks = r3;
                } else
                  t2.callbacks = new a.CallbackManager(n2._parentRunId, { handlers: e4.handlers.concat(n2.handlers), inheritableHandlers: e4.inheritableHandlers.concat(n2.inheritableHandlers), tags: Array.from(new Set(e4.tags.concat(n2.tags))), inheritableTags: Array.from(new Set(e4.inheritableTags.concat(n2.inheritableTags))), metadata: { ...e4.metadata, ...n2.metadata } });
              } else
                t2.callbacks = n2;
            }
          } else
            t2[e3] = r2[e3] ?? t2[e3];
      return t2;
    }
    let l = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
    function u(e2) {
      let t2 = n.AO.getRunnableConfig(), r2 = { tags: [], metadata: {}, recursionLimit: 25, runId: void 0 };
      if (t2) {
        let { runId: e3, runName: a2, ...n2 } = t2;
        r2 = Object.entries(n2).reduce((e4, [t3, r3]) => (void 0 !== r3 && (e4[t3] = r3), e4), r2);
      }
      if (e2 && (r2 = Object.entries(e2).reduce((e3, [t3, r3]) => (void 0 !== r3 && (e3[t3] = r3), e3), r2)), r2?.configurable)
        for (let e3 of Object.keys(r2.configurable))
          l.has(typeof r2.configurable[e3]) && !r2.metadata?.[e3] && (r2.metadata || (r2.metadata = {}), r2.metadata[e3] = r2.configurable[e3]);
      if (void 0 !== r2.timeout) {
        if (r2.timeout <= 0)
          throw Error("Timeout must be a positive number");
        let e3 = AbortSignal.timeout(r2.timeout);
        void 0 !== r2.signal ? "any" in AbortSignal && (r2.signal = AbortSignal.any([r2.signal, e3])) : r2.signal = e3, delete r2.timeout;
      }
      return r2;
    }
    function c(e2 = {}, { callbacks: t2, maxConcurrency: r2, recursionLimit: a2, runName: n2, configurable: i2, runId: s2 } = {}) {
      let o2 = u(e2);
      return void 0 !== t2 && (delete o2.runName, o2.callbacks = t2), void 0 !== a2 && (o2.recursionLimit = a2), void 0 !== r2 && (o2.maxConcurrency = r2), void 0 !== n2 && (o2.runName = n2), void 0 !== i2 && (o2.configurable = { ...o2.configurable, ...i2 }), void 0 !== s2 && delete o2.runId, o2;
    }
    function d(e2) {
      return e2 ? { configurable: e2.configurable, recursionLimit: e2.recursionLimit, callbacks: e2.callbacks, tags: e2.tags, metadata: e2.metadata, maxConcurrency: e2.maxConcurrency, timeout: e2.timeout, signal: e2.signal } : void 0;
    }
  };
  __namedExportsObject["__chunk_1184"] = (e, t, r) => {
    "use strict";
    r.d(t, { eq: () => A, Vh: () => M, pX: () => k, ft: () => T, Y8: () => N, dT: () => I, bq: () => $, RJ: () => D, Dk: () => P, lW: () => C, Th: () => U, cx: () => j, Uv: () => S, k9: () => L });
    var a = r(5817), n = r(4779), i = r(2208), s = r(7928), o = r(9593), l = r(1610), u = r(3686), c = r(541), d = r(2047), h = r(3735), p = r(1550), f = r(9321);
    class m extends f.BaseTracer {
      constructor({ config: e2, onStart: t2, onEnd: r2, onError: a2 }) {
        super({ _awaitHandler: true }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "RootListenersTracer" }), Object.defineProperty(this, "rootId", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "config", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "argOnStart", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "argOnEnd", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "argOnError", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.config = e2, this.argOnStart = t2, this.argOnEnd = r2, this.argOnError = a2;
      }
      persistRun(e2) {
        return Promise.resolve();
      }
      async onRunCreate(e2) {
        !this.rootId && (this.rootId = e2.id, this.argOnStart && await this.argOnStart(e2, this.config));
      }
      async onRunUpdate(e2) {
        e2.id === this.rootId && (e2.error ? this.argOnError && await this.argOnError(e2, this.config) : this.argOnEnd && await this.argOnEnd(e2, this.config));
      }
    }
    var g = r(4939), y = r(647), b = r(6378);
    function v(e2) {
      return "object" == typeof e2 && null !== e2 && "function" == typeof e2[Symbol.iterator] && "function" == typeof e2.next;
    }
    let _ = (e2) => null != e2 && "object" == typeof e2 && "next" in e2 && "function" == typeof e2.next;
    function w(e2) {
      return "object" == typeof e2 && null !== e2 && "function" == typeof e2[Symbol.asyncIterator];
    }
    function* E(e2, t2) {
      for (; ; ) {
        let { value: r2, done: a2 } = y.AO.runWithConfig((0, h.yG)(e2), t2.next.bind(t2), true);
        if (a2)
          break;
        yield r2;
      }
    }
    async function* x(e2, t2) {
      let r2 = t2[Symbol.asyncIterator]();
      for (; ; ) {
        let { value: a2, done: n2 } = await y.AO.runWithConfig((0, h.yG)(e2), r2.next.bind(t2), true);
        if (n2)
          break;
        yield a2;
      }
    }
    var O = r(2493);
    function S(e2, t2) {
      return !e2 || Array.isArray(e2) || e2 instanceof Date || "object" != typeof e2 ? { [t2]: e2 } : e2;
    }
    class A extends u.Serializable {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_runnable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 });
      }
      getName(e2) {
        let t2 = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
        return e2 ? `${t2}${e2}` : t2;
      }
      bind(e2) {
        return new k({ bound: this, kwargs: e2, config: {} });
      }
      map() {
        return new T({ bound: this });
      }
      withRetry(e2) {
        return new P({ bound: this, kwargs: {}, config: {}, maxAttemptNumber: e2?.stopAfterAttempt, ...e2 });
      }
      withConfig(e2) {
        return new k({ bound: this, config: e2, kwargs: {} });
      }
      withFallbacks(e2) {
        return new j({ runnable: this, fallbacks: Array.isArray(e2) ? e2 : e2.fallbacks });
      }
      _getOptionsList(e2, t2 = 0) {
        if (Array.isArray(e2) && e2.length !== t2)
          throw Error(`Passed "options" must be an array with the same length as the inputs, but got ${e2.length} options for ${t2} inputs`);
        if (Array.isArray(e2))
          return e2.map(h.LE);
        if (t2 > 1 && !Array.isArray(e2) && e2.runId) {
          console.warn("Provided runId will be used only for the first element of the batch.");
          let r2 = Object.fromEntries(Object.entries(e2).filter(([e3]) => "runId" !== e3));
          return Array.from({ length: t2 }, (t3, a2) => (0, h.LE)(0 === a2 ? e2 : r2));
        }
        return Array.from({ length: t2 }, () => (0, h.LE)(e2));
      }
      async batch(e2, t2, r2) {
        let a2 = this._getOptionsList(t2 ?? {}, e2.length), n2 = a2[0]?.maxConcurrency ?? r2?.maxConcurrency, i2 = new p.AsyncCaller({ maxConcurrency: n2, onFailedAttempt: (e3) => {
          throw e3;
        } });
        return Promise.all(e2.map((e3, t3) => i2.call(async () => {
          try {
            return await this.invoke(e3, a2[t3]);
          } catch (e4) {
            if (r2?.returnExceptions)
              return e4;
            throw e4;
          }
        })));
      }
      async *_streamIterator(e2, t2) {
        yield this.invoke(e2, t2);
      }
      async stream(e2, t2) {
        let r2 = (0, h.LE)(t2), a2 = new c.AsyncGeneratorWithSetup({ generator: this._streamIterator(e2, r2), config: r2 });
        return await a2.setup, c.IterableReadableStream.fromAsyncGenerator(a2);
      }
      _separateRunnableConfigFromCallOptions(e2) {
        let t2;
        t2 = void 0 === e2 ? (0, h.LE)(e2) : (0, h.LE)({ callbacks: e2.callbacks, tags: e2.tags, metadata: e2.metadata, runName: e2.runName, configurable: e2.configurable, recursionLimit: e2.recursionLimit, maxConcurrency: e2.maxConcurrency, runId: e2.runId, timeout: e2.timeout, signal: e2.signal });
        let r2 = { ...e2 };
        return delete r2.callbacks, delete r2.tags, delete r2.metadata, delete r2.runName, delete r2.configurable, delete r2.recursionLimit, delete r2.maxConcurrency, delete r2.runId, delete r2.timeout, delete r2.signal, [t2, r2];
      }
      async _callWithConfig(e2, t2, r2) {
        let a2;
        let n2 = (0, h.LE)(r2), i2 = await (0, h.Le)(n2), s2 = await i2?.handleChainStart(this.toJSON(), S(t2, "input"), n2.runId, n2?.runType, void 0, void 0, n2?.runName ?? this.getName());
        delete n2.runId;
        try {
          let i3 = e2.call(this, t2, n2, s2);
          a2 = await (0, d.E)(i3, r2?.signal);
        } catch (e3) {
          throw await s2?.handleChainError(e3), e3;
        }
        return await s2?.handleChainEnd(S(a2, "output")), a2;
      }
      async _batchWithConfig(e2, t2, r2, a2) {
        let n2;
        let i2 = this._getOptionsList(r2 ?? {}, t2.length), s2 = await Promise.all(i2.map(h.Le)), o2 = await Promise.all(s2.map(async (e3, r3) => {
          let a3 = await e3?.handleChainStart(this.toJSON(), S(t2[r3], "input"), i2[r3].runId, i2[r3].runType, void 0, void 0, i2[r3].runName ?? this.getName());
          return delete i2[r3].runId, a3;
        }));
        try {
          let r3 = e2.call(this, t2, i2, o2, a2);
          n2 = await (0, d.E)(r3, i2?.[0]?.signal);
        } catch (e3) {
          throw await Promise.all(o2.map((t3) => t3?.handleChainError(e3))), e3;
        }
        return await Promise.all(o2.map((e3) => e3?.handleChainEnd(S(n2, "output")))), n2;
      }
      async *_transformStreamWithConfig(e2, t2, r2) {
        let a2, n2, i2;
        let s2 = true, u2 = true, d2 = (0, h.LE)(r2), p2 = await (0, h.Le)(d2);
        async function* f2() {
          for await (let t3 of e2) {
            if (s2) {
              if (void 0 === a2)
                a2 = t3;
              else
                try {
                  a2 = (0, c.concat)(a2, t3);
                } catch {
                  a2 = void 0, s2 = false;
                }
            }
            yield t3;
          }
        }
        try {
          let e3 = await (0, c.pipeGeneratorWithSetup)(t2.bind(this), f2(), async () => p2?.handleChainStart(this.toJSON(), { input: "" }, d2.runId, d2.runType, void 0, void 0, d2.runName ?? this.getName()), r2?.signal, d2);
          delete d2.runId, i2 = e3.setup;
          let a3 = i2?.handlers.find(l.C), s3 = e3.output;
          void 0 !== a3 && void 0 !== i2 && (s3 = a3.tapOutputIterable(i2.runId, s3));
          let h2 = i2?.handlers.find(o.isLogStreamHandler);
          for await (let e4 of (void 0 !== h2 && void 0 !== i2 && (s3 = h2.tapOutputIterable(i2.runId, s3)), s3))
            if (yield e4, u2) {
              if (void 0 === n2)
                n2 = e4;
              else
                try {
                  n2 = (0, c.concat)(n2, e4);
                } catch {
                  n2 = void 0, u2 = false;
                }
            }
        } catch (e3) {
          throw await i2?.handleChainError(e3, void 0, void 0, void 0, { inputs: S(a2, "input") }), e3;
        }
        await i2?.handleChainEnd(n2 ?? {}, void 0, void 0, void 0, { inputs: S(a2, "input") });
      }
      getGraph(e2) {
        let t2 = new b.k(), r2 = t2.addNode({ name: `${this.getName()}Input`, schema: a.z.any() }), n2 = t2.addNode(this), i2 = t2.addNode({ name: `${this.getName()}Output`, schema: a.z.any() });
        return t2.addEdge(r2, n2), t2.addEdge(n2, i2), t2;
      }
      pipe(e2) {
        return new C({ first: this, last: L(e2) });
      }
      pick(e2) {
        return this.pipe(new D(e2));
      }
      assign(e2) {
        return this.pipe(new M(new I({ steps: e2 })));
      }
      async *transform(e2, t2) {
        let r2;
        for await (let t3 of e2)
          r2 = void 0 === r2 ? t3 : (0, c.concat)(r2, t3);
        yield* this._streamIterator(r2, (0, h.LE)(t2));
      }
      async *streamLog(e2, t2, r2) {
        let a2 = new o.LogStreamCallbackHandler({ ...r2, autoClose: false, _schemaFormat: "original" }), n2 = (0, h.LE)(t2);
        yield* this._streamLog(e2, a2, n2);
      }
      async *_streamLog(e2, t2, r2) {
        let { callbacks: a2 } = r2;
        if (void 0 === a2)
          r2.callbacks = [t2];
        else if (Array.isArray(a2))
          r2.callbacks = a2.concat([t2]);
        else {
          let e3 = a2.copy();
          e3.addHandler(t2, true), r2.callbacks = e3;
        }
        let n2 = this.stream(e2, r2), i2 = async function() {
          try {
            for await (let e3 of await n2) {
              let r3 = new o.RunLogPatch({ ops: [{ op: "add", path: "/streamed_output/-", value: e3 }] });
              await t2.writer.write(r3);
            }
          } finally {
            await t2.writer.close();
          }
        }();
        try {
          for await (let e3 of t2)
            yield e3;
        } finally {
          await i2;
        }
      }
      streamEvents(e2, t2, r2) {
        let a2;
        if ("v1" === t2.version)
          a2 = this._streamEventsV1(e2, t2, r2);
        else if ("v2" === t2.version)
          a2 = this._streamEventsV2(e2, t2, r2);
        else
          throw Error('Only versions "v1" and "v2" of the schema are currently supported.');
        return "text/event-stream" === t2.encoding ? function(e3) {
          let t3 = new TextEncoder(), r3 = new ReadableStream({ async start(r4) {
            for await (let a3 of e3)
              r4.enqueue(t3.encode(`event: data
data: ${JSON.stringify(a3)}

`));
            r4.enqueue(t3.encode("event: end\n\n")), r4.close();
          } });
          return c.IterableReadableStream.fromReadableStream(r3);
        }(a2) : c.IterableReadableStream.fromAsyncGenerator(a2);
      }
      async *_streamEventsV2(e2, t2, r2) {
        let a2;
        let n2 = new l.d({ ...r2, autoClose: false }), s2 = (0, h.LE)(t2), o2 = s2.runId ?? (0, i.Z)();
        s2.runId = o2;
        let u2 = s2.callbacks;
        if (void 0 === u2)
          s2.callbacks = [n2];
        else if (Array.isArray(u2))
          s2.callbacks = u2.concat(n2);
        else {
          let e3 = u2.copy();
          e3.addHandler(n2, true), s2.callbacks = e3;
        }
        let c2 = this, d2 = async function() {
          try {
            let t3 = await c2.stream(e2, s2);
            for await (let e3 of n2.tapOutputIterable(o2, t3))
              ;
          } finally {
            await n2.finish();
          }
        }(), p2 = false;
        try {
          for await (let t3 of n2) {
            if (!p2) {
              t3.data.input = e2, p2 = true, a2 = t3.run_id, yield t3;
              continue;
            }
            t3.run_id === a2 && t3.event.endsWith("_end") && t3.data?.input && delete t3.data.input, yield t3;
          }
        } finally {
          await d2;
        }
      }
      async *_streamEventsV1(e2, t2, r2) {
        let a2;
        let n2 = false, i2 = (0, h.LE)(t2), s2 = i2.tags ?? [], l2 = i2.metadata ?? {}, u2 = i2.runName ?? this.getName(), c2 = new o.LogStreamCallbackHandler({ ...r2, autoClose: false, _schemaFormat: "streaming_events" }), d2 = new g.H({ ...r2 });
        for await (let t3 of this._streamLog(e2, c2, i2)) {
          if (void 0 === (a2 = a2 ? a2.concat(t3) : o.RunLog.fromRunLogPatch(t3)).state)
            throw Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
          if (!n2) {
            n2 = true;
            let t4 = { ...a2.state }, r4 = { run_id: t4.id, event: `on_${t4.type}_start`, name: u2, tags: s2, metadata: l2, data: { input: e2 } };
            d2.includeEvent(r4, t4.type) && (yield r4);
          }
          for (let e3 of [...new Set(t3.ops.filter((e4) => e4.path.startsWith("/logs/")).map((e4) => e4.path.split("/")[2]))]) {
            let t4;
            let r4 = {}, n3 = a2.state.logs[e3];
            if ("start" == (t4 = void 0 === n3.end_time ? n3.streamed_output.length > 0 ? "stream" : "start" : "end"))
              void 0 !== n3.inputs && (r4.input = n3.inputs);
            else if ("end" === t4)
              void 0 !== n3.inputs && (r4.input = n3.inputs), r4.output = n3.final_output;
            else if ("stream" === t4) {
              let e4 = n3.streamed_output.length;
              if (1 !== e4)
                throw Error(`Expected exactly one chunk of streamed output, got ${e4} instead. Encountered in: "${n3.name}"`);
              r4 = { chunk: n3.streamed_output[0] }, n3.streamed_output = [];
            }
            yield { event: `on_${n3.type}_${t4}`, name: n3.name, run_id: n3.id, tags: n3.tags, metadata: n3.metadata, data: r4 };
          }
          let { state: r3 } = a2;
          if (r3.streamed_output.length > 0) {
            let e3 = r3.streamed_output.length;
            if (1 !== e3)
              throw Error(`Expected exactly one chunk of streamed output, got ${e3} instead. Encountered in: "${r3.name}"`);
            let t4 = { chunk: r3.streamed_output[0] };
            r3.streamed_output = [];
            let a3 = { event: `on_${r3.type}_stream`, run_id: r3.id, tags: s2, metadata: l2, name: u2, data: t4 };
            d2.includeEvent(a3, r3.type) && (yield a3);
          }
        }
        let p2 = a2?.state;
        if (void 0 !== p2) {
          let e3 = { event: `on_${p2.type}_end`, name: u2, run_id: p2.id, tags: s2, metadata: l2, data: { output: p2.final_output } };
          d2.includeEvent(e3, p2.type) && (yield e3);
        }
      }
      static isRunnable(e2) {
        return (0, g.T)(e2);
      }
      withListeners({ onStart: e2, onEnd: t2, onError: r2 }) {
        return new k({ bound: this, config: {}, configFactories: [(a2) => ({ callbacks: [new m({ config: a2, onStart: e2, onEnd: t2, onError: r2 })] })] });
      }
      asTool(e2) {
        return function(e3, t2) {
          let r2 = t2.name ?? e3.getName(), n2 = t2.description ?? t2.schema?.description;
          return new U(t2.schema.constructor === a.z.ZodString ? { name: r2, description: n2, schema: a.z.object({ input: a.z.string() }).transform((e4) => e4.input), bound: e3 } : { name: r2, description: n2, schema: t2.schema, bound: e3 });
        }(this, e2);
      }
    }
    class k extends A {
      static lc_name() {
        return "RunnableBinding";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "bound", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "config", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "kwargs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "configFactories", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.bound = e2.bound, this.kwargs = e2.kwargs, this.config = e2.config, this.configFactories = e2.configFactories;
      }
      getName(e2) {
        return this.bound.getName(e2);
      }
      async _mergeConfig(...e2) {
        let t2 = (0, h.t8)(this.config, ...e2);
        return (0, h.t8)(t2, ...this.configFactories ? await Promise.all(this.configFactories.map(async (e3) => await e3(t2))) : []);
      }
      bind(e2) {
        return new this.constructor({ bound: this.bound, kwargs: { ...this.kwargs, ...e2 }, config: this.config });
      }
      withConfig(e2) {
        return new this.constructor({ bound: this.bound, kwargs: this.kwargs, config: { ...this.config, ...e2 } });
      }
      withRetry(e2) {
        return new this.constructor({ bound: this.bound.withRetry(e2), kwargs: this.kwargs, config: this.config });
      }
      async invoke(e2, t2) {
        return this.bound.invoke(e2, await this._mergeConfig((0, h.LE)(t2), this.kwargs));
      }
      async batch(e2, t2, r2) {
        let a2 = Array.isArray(t2) ? await Promise.all(t2.map(async (e3) => this._mergeConfig((0, h.LE)(e3), this.kwargs))) : await this._mergeConfig((0, h.LE)(t2), this.kwargs);
        return this.bound.batch(e2, a2, r2);
      }
      async *_streamIterator(e2, t2) {
        yield* this.bound._streamIterator(e2, await this._mergeConfig((0, h.LE)(t2), this.kwargs));
      }
      async stream(e2, t2) {
        return this.bound.stream(e2, await this._mergeConfig((0, h.LE)(t2), this.kwargs));
      }
      async *transform(e2, t2) {
        yield* this.bound.transform(e2, await this._mergeConfig((0, h.LE)(t2), this.kwargs));
      }
      streamEvents(e2, t2, r2) {
        let a2 = this, n2 = async function* () {
          yield* a2.bound.streamEvents(e2, { ...await a2._mergeConfig((0, h.LE)(t2), a2.kwargs), version: t2.version }, r2);
        };
        return c.IterableReadableStream.fromAsyncGenerator(n2());
      }
      static isRunnableBinding(e2) {
        return e2.bound && A.isRunnable(e2.bound);
      }
      withListeners({ onStart: e2, onEnd: t2, onError: r2 }) {
        return new k({ bound: this.bound, kwargs: this.kwargs, config: this.config, configFactories: [(a2) => ({ callbacks: [new m({ config: a2, onStart: e2, onEnd: t2, onError: r2 })] })] });
      }
    }
    class T extends A {
      static lc_name() {
        return "RunnableEach";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "bound", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.bound = e2.bound;
      }
      bind(e2) {
        return new T({ bound: this.bound.bind(e2) });
      }
      async invoke(e2, t2) {
        return this._callWithConfig(this._invoke.bind(this), e2, t2);
      }
      async _invoke(e2, t2, r2) {
        return this.bound.batch(e2, (0, h.q)(t2, { callbacks: r2?.getChild() }));
      }
      withListeners({ onStart: e2, onEnd: t2, onError: r2 }) {
        return new T({ bound: this.bound.withListeners({ onStart: e2, onEnd: t2, onError: r2 }) });
      }
    }
    class P extends k {
      static lc_name() {
        return "RunnableRetry";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "maxAttemptNumber", { enumerable: true, configurable: true, writable: true, value: 3 }), Object.defineProperty(this, "onFailedAttempt", { enumerable: true, configurable: true, writable: true, value: () => {
        } }), this.maxAttemptNumber = e2.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = e2.onFailedAttempt ?? this.onFailedAttempt;
      }
      _patchConfigForRetry(e2, t2, r2) {
        let a2 = e2 > 1 ? `retry:attempt:${e2}` : void 0;
        return (0, h.q)(t2, { callbacks: r2?.getChild(a2) });
      }
      async _invoke(e2, t2, r2) {
        return n((a2) => super.invoke(e2, this._patchConfigForRetry(a2, t2, r2)), { onFailedAttempt: (t3) => this.onFailedAttempt(t3, e2), retries: Math.max(this.maxAttemptNumber - 1, 0), randomize: true });
      }
      async invoke(e2, t2) {
        return this._callWithConfig(this._invoke.bind(this), e2, t2);
      }
      async _batch(e2, t2, r2, a2) {
        let i2 = {};
        try {
          await n(async (n2) => {
            let s2;
            let o2 = e2.map((e3, t3) => t3).filter((e3) => void 0 === i2[e3.toString()] || i2[e3.toString()] instanceof Error), l2 = o2.map((t3) => e2[t3]), u2 = o2.map((e3) => this._patchConfigForRetry(n2, t2?.[e3], r2?.[e3])), c2 = await super.batch(l2, u2, { ...a2, returnExceptions: true });
            for (let e3 = 0; e3 < c2.length; e3 += 1) {
              let t3 = c2[e3], r3 = o2[e3];
              t3 instanceof Error && void 0 === s2 && ((s2 = t3).input = l2[e3]), i2[r3.toString()] = t3;
            }
            if (s2)
              throw s2;
            return c2;
          }, { onFailedAttempt: (e3) => this.onFailedAttempt(e3, e3.input), retries: Math.max(this.maxAttemptNumber - 1, 0), randomize: true });
        } catch (e3) {
          if (a2?.returnExceptions !== true)
            throw e3;
        }
        return Object.keys(i2).sort((e3, t3) => parseInt(e3, 10) - parseInt(t3, 10)).map((e3) => i2[parseInt(e3, 10)]);
      }
      async batch(e2, t2, r2) {
        return this._batchWithConfig(this._batch.bind(this), e2, t2, r2);
      }
    }
    class C extends A {
      static lc_name() {
        return "RunnableSequence";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "first", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "middle", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "last", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "omitSequenceTags", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), this.first = e2.first, this.middle = e2.middle ?? this.middle, this.last = e2.last, this.name = e2.name, this.omitSequenceTags = e2.omitSequenceTags ?? this.omitSequenceTags;
      }
      get steps() {
        return [this.first, ...this.middle, this.last];
      }
      async invoke(e2, t2) {
        let r2;
        let a2 = (0, h.LE)(t2), n2 = await (0, h.Le)(a2), i2 = await n2?.handleChainStart(this.toJSON(), S(e2, "input"), a2.runId, void 0, void 0, void 0, a2?.runName);
        delete a2.runId;
        let s2 = e2;
        try {
          let e3 = [this.first, ...this.middle];
          for (let r3 = 0; r3 < e3.length; r3 += 1) {
            let n3 = e3[r3].invoke(s2, (0, h.q)(a2, { callbacks: i2?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${r3 + 1}`) }));
            s2 = await (0, d.E)(n3, t2?.signal);
          }
          if (t2?.signal?.aborted)
            throw Error("Aborted");
          r2 = await this.last.invoke(s2, (0, h.q)(a2, { callbacks: i2?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
        } catch (e3) {
          throw await i2?.handleChainError(e3), e3;
        }
        return await i2?.handleChainEnd(S(r2, "output")), r2;
      }
      async batch(e2, t2, r2) {
        let a2 = this._getOptionsList(t2 ?? {}, e2.length), n2 = await Promise.all(a2.map(h.Le)), i2 = await Promise.all(n2.map(async (t3, r3) => {
          let n3 = await t3?.handleChainStart(this.toJSON(), S(e2[r3], "input"), a2[r3].runId, void 0, void 0, void 0, a2[r3].runName);
          return delete a2[r3].runId, n3;
        })), s2 = e2;
        try {
          for (let e3 = 0; e3 < this.steps.length; e3 += 1) {
            let t3 = this.steps[e3].batch(s2, i2.map((t4, r3) => {
              let n3 = t4?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${e3 + 1}`);
              return (0, h.q)(a2[r3], { callbacks: n3 });
            }), r2);
            s2 = await (0, d.E)(t3, a2[0]?.signal);
          }
        } catch (e3) {
          throw await Promise.all(i2.map((t3) => t3?.handleChainError(e3))), e3;
        }
        return await Promise.all(i2.map((e3) => e3?.handleChainEnd(S(s2, "output")))), s2;
      }
      async *_streamIterator(e2, t2) {
        let r2;
        let a2 = await (0, h.Le)(t2), { runId: n2, ...i2 } = t2 ?? {}, s2 = await a2?.handleChainStart(this.toJSON(), S(e2, "input"), n2, void 0, void 0, void 0, i2?.runName), o2 = [this.first, ...this.middle, this.last], l2 = true;
        async function* u2() {
          yield e2;
        }
        try {
          let e3 = o2[0].transform(u2(), (0, h.q)(i2, { callbacks: s2?.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
          for (let t3 = 1; t3 < o2.length; t3 += 1) {
            let r3 = o2[t3];
            e3 = await r3.transform(e3, (0, h.q)(i2, { callbacks: s2?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${t3 + 1}`) }));
          }
          for await (let a3 of e3)
            if (t2?.signal?.throwIfAborted(), yield a3, l2) {
              if (void 0 === r2)
                r2 = a3;
              else
                try {
                  r2 = (0, c.concat)(r2, a3);
                } catch (e4) {
                  r2 = void 0, l2 = false;
                }
            }
        } catch (e3) {
          throw await s2?.handleChainError(e3), e3;
        }
        await s2?.handleChainEnd(S(r2, "output"));
      }
      getGraph(e2) {
        let t2 = new b.k(), r2 = null;
        return this.steps.forEach((a2, n2) => {
          let i2 = a2.getGraph(e2);
          0 !== n2 && i2.trimFirstNode(), n2 !== this.steps.length - 1 && i2.trimLastNode(), t2.extend(i2);
          let s2 = i2.firstNode();
          if (!s2)
            throw Error(`Runnable ${a2} has no first node`);
          r2 && t2.addEdge(r2, s2), r2 = i2.lastNode();
        }), t2;
      }
      pipe(e2) {
        return new C(C.isRunnableSequence(e2) ? { first: this.first, middle: this.middle.concat([this.last, e2.first, ...e2.middle]), last: e2.last, name: this.name ?? e2.name } : { first: this.first, middle: [...this.middle, this.last], last: L(e2), name: this.name });
      }
      static isRunnableSequence(e2) {
        return Array.isArray(e2.middle) && A.isRunnable(e2);
      }
      static from([e2, ...t2], r2) {
        let a2 = {};
        return "string" == typeof r2 ? a2.name = r2 : void 0 !== r2 && (a2 = r2), new C({ ...a2, first: L(e2), middle: t2.slice(0, -1).map(L), last: L(t2[t2.length - 1]) });
      }
    }
    class I extends A {
      static lc_name() {
        return "RunnableMap";
      }
      getStepsKeys() {
        return Object.keys(this.steps);
      }
      constructor(e2) {
        for (let [t2, r2] of (super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "steps", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.steps = {}, Object.entries(e2.steps)))
          this.steps[t2] = L(r2);
      }
      static from(e2) {
        return new I({ steps: e2 });
      }
      async invoke(e2, t2) {
        let r2 = (0, h.LE)(t2), a2 = await (0, h.Le)(r2), n2 = await a2?.handleChainStart(this.toJSON(), { input: e2 }, r2.runId, void 0, void 0, void 0, r2?.runName);
        delete r2.runId;
        let i2 = {};
        try {
          let a3 = Object.entries(this.steps).map(async ([t3, a4]) => {
            i2[t3] = await a4.invoke(e2, (0, h.q)(r2, { callbacks: n2?.getChild(`map:key:${t3}`) }));
          });
          await (0, d.E)(Promise.all(a3), t2?.signal);
        } catch (e3) {
          throw await n2?.handleChainError(e3), e3;
        }
        return await n2?.handleChainEnd(i2), i2;
      }
      async *_transform(e2, t2, r2) {
        let a2 = { ...this.steps }, n2 = (0, c.atee)(e2, Object.keys(a2).length), i2 = new Map(Object.entries(a2).map(([e3, a3], i3) => {
          let s2 = a3.transform(n2[i3], (0, h.q)(r2, { callbacks: t2?.getChild(`map:key:${e3}`) }));
          return [e3, s2.next().then((t3) => ({ key: e3, gen: s2, result: t3 }))];
        }));
        for (; i2.size; ) {
          let e3 = Promise.race(i2.values()), { key: t3, result: a3, gen: n3 } = await (0, d.E)(e3, r2?.signal);
          i2.delete(t3), a3.done || (yield { [t3]: a3.value }, i2.set(t3, n3.next().then((e4) => ({ key: t3, gen: n3, result: e4 }))));
        }
      }
      transform(e2, t2) {
        return this._transformStreamWithConfig(e2, this._transform.bind(this), t2);
      }
      async stream(e2, t2) {
        async function* r2() {
          yield e2;
        }
        let a2 = (0, h.LE)(t2), n2 = new c.AsyncGeneratorWithSetup({ generator: this.transform(r2(), a2), config: a2 });
        return await n2.setup, c.IterableReadableStream.fromAsyncGenerator(n2);
      }
    }
    class R extends A {
      constructor(e2) {
        if (super(e2), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "func", { enumerable: true, configurable: true, writable: true, value: void 0 }), !(0, s.xQ)(e2.func))
          throw Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
        this.func = e2.func;
      }
      async invoke(e2, t2) {
        let [r2] = this._getOptionsList(t2 ?? {}, 1), a2 = await (0, h.Le)(r2), n2 = this.func((0, h.q)(r2, { callbacks: a2 }), e2);
        return (0, d.E)(n2, r2?.signal);
      }
      async *_streamIterator(e2, t2) {
        let [r2] = this._getOptionsList(t2 ?? {}, 1), a2 = await this.invoke(e2, t2);
        if (w(a2)) {
          for await (let e3 of a2)
            r2?.signal?.throwIfAborted(), yield e3;
          return;
        }
        if (_(a2)) {
          for (; ; ) {
            r2?.signal?.throwIfAborted();
            let e3 = a2.next();
            if (e3.done)
              break;
            yield e3.value;
          }
          return;
        }
        yield a2;
      }
      static from(e2) {
        return new R({ func: e2 });
      }
    }
    class N extends A {
      static lc_name() {
        return "RunnableLambda";
      }
      constructor(e2) {
        if ((0, s.xQ)(e2.func))
          return R.from(e2.func);
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "func", { enumerable: true, configurable: true, writable: true, value: void 0 }), function(e3) {
          if ((0, s.xQ)(e3))
            throw Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
        }(e2.func), this.func = e2.func;
      }
      static from(e2) {
        return new N({ func: e2 });
      }
      async _invoke(e2, t2, r2) {
        return new Promise((a2, n2) => {
          let i2 = (0, h.q)(t2, { callbacks: r2?.getChild(), recursionLimit: (t2?.recursionLimit ?? h.ov) - 1 });
          y.AO.runWithConfig((0, h.yG)(i2), async () => {
            try {
              let r3 = await this.func(e2, { ...i2 });
              if (r3 && A.isRunnable(r3)) {
                if (t2?.recursionLimit === 0)
                  throw Error("Recursion limit reached.");
                r3 = await r3.invoke(e2, { ...i2, recursionLimit: (i2.recursionLimit ?? h.ov) - 1 });
              } else if (w(r3)) {
                let e3;
                for await (let a3 of x(i2, r3))
                  if (t2?.signal?.throwIfAborted(), void 0 === e3)
                    e3 = a3;
                  else
                    try {
                      e3 = (0, c.concat)(e3, a3);
                    } catch (t3) {
                      e3 = a3;
                    }
                r3 = e3;
              } else if (v(r3)) {
                let e3;
                for (let a3 of E(i2, r3))
                  if (t2?.signal?.throwIfAborted(), void 0 === e3)
                    e3 = a3;
                  else
                    try {
                      e3 = (0, c.concat)(e3, a3);
                    } catch (t3) {
                      e3 = a3;
                    }
                r3 = e3;
              }
              a2(r3);
            } catch (e3) {
              n2(e3);
            }
          });
        });
      }
      async invoke(e2, t2) {
        return this._callWithConfig(this._invoke.bind(this), e2, t2);
      }
      async *_transform(e2, t2, r2) {
        let a2;
        for await (let t3 of e2)
          if (void 0 === a2)
            a2 = t3;
          else
            try {
              a2 = (0, c.concat)(a2, t3);
            } catch (e3) {
              a2 = t3;
            }
        let n2 = (0, h.q)(r2, { callbacks: t2?.getChild(), recursionLimit: (r2?.recursionLimit ?? h.ov) - 1 }), i2 = await new Promise((e3, t3) => {
          y.AO.runWithConfig((0, h.yG)(n2), async () => {
            try {
              let t4 = await this.func(a2, { ...n2, config: n2 });
              e3(t4);
            } catch (e4) {
              t3(e4);
            }
          });
        });
        if (i2 && A.isRunnable(i2)) {
          if (r2?.recursionLimit === 0)
            throw Error("Recursion limit reached.");
          for await (let e3 of await i2.stream(a2, n2))
            yield e3;
        } else if (w(i2))
          for await (let e3 of x(n2, i2))
            r2?.signal?.throwIfAborted(), yield e3;
        else if (v(i2))
          for (let e3 of E(n2, i2))
            r2?.signal?.throwIfAborted(), yield e3;
        else
          yield i2;
      }
      transform(e2, t2) {
        return this._transformStreamWithConfig(e2, this._transform.bind(this), t2);
      }
      async stream(e2, t2) {
        async function* r2() {
          yield e2;
        }
        let a2 = (0, h.LE)(t2), n2 = new c.AsyncGeneratorWithSetup({ generator: this.transform(r2(), a2), config: a2 });
        return await n2.setup, c.IterableReadableStream.fromAsyncGenerator(n2);
      }
    }
    class $ extends I {
    }
    class j extends A {
      static lc_name() {
        return "RunnableWithFallbacks";
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "runnable", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fallbacks", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.runnable = e2.runnable, this.fallbacks = e2.fallbacks;
      }
      *runnables() {
        for (let e2 of (yield this.runnable, this.fallbacks))
          yield e2;
      }
      async invoke(e2, t2) {
        let r2;
        let a2 = (0, h.LE)(t2), n2 = await (0, h.Le)(t2), { runId: i2, ...s2 } = a2, o2 = await n2?.handleChainStart(this.toJSON(), S(e2, "input"), i2, void 0, void 0, void 0, s2?.runName);
        for (let t3 of this.runnables()) {
          a2?.signal?.throwIfAborted();
          try {
            let r3 = await t3.invoke(e2, (0, h.q)(s2, { callbacks: o2?.getChild() }));
            return await o2?.handleChainEnd(S(r3, "output")), r3;
          } catch (e3) {
            void 0 === r2 && (r2 = e3);
          }
        }
        if (void 0 === r2)
          throw Error("No error stored at end of fallback.");
        throw await o2?.handleChainError(r2), r2;
      }
      async *_streamIterator(e2, t2) {
        let r2, a2, n2;
        let i2 = (0, h.LE)(t2), s2 = await (0, h.Le)(t2), { runId: o2, ...l2 } = i2, u2 = await s2?.handleChainStart(this.toJSON(), S(e2, "input"), o2, void 0, void 0, void 0, l2?.runName);
        for (let t3 of this.runnables()) {
          i2?.signal?.throwIfAborted();
          let n3 = (0, h.q)(l2, { callbacks: u2?.getChild() });
          try {
            a2 = await t3.stream(e2, n3);
            break;
          } catch (e3) {
            void 0 === r2 && (r2 = e3);
          }
        }
        if (void 0 === a2) {
          let e3 = r2 ?? Error("No error stored at end of fallback.");
          throw await u2?.handleChainError(e3), e3;
        }
        try {
          for await (let e3 of a2) {
            yield e3;
            try {
              n2 = void 0 === n2 ? n2 : (0, c.concat)(n2, e3);
            } catch (e4) {
              n2 = void 0;
            }
          }
        } catch (e3) {
          throw await u2?.handleChainError(e3), e3;
        }
        await u2?.handleChainEnd(S(n2, "output"));
      }
      async batch(e2, t2, r2) {
        let a2;
        if (r2?.returnExceptions)
          throw Error("Not implemented.");
        let n2 = this._getOptionsList(t2 ?? {}, e2.length), i2 = await Promise.all(n2.map((e3) => (0, h.Le)(e3))), s2 = await Promise.all(i2.map(async (t3, r3) => {
          let a3 = await t3?.handleChainStart(this.toJSON(), S(e2[r3], "input"), n2[r3].runId, void 0, void 0, void 0, n2[r3].runName);
          return delete n2[r3].runId, a3;
        }));
        for (let t3 of this.runnables()) {
          n2[0].signal?.throwIfAborted();
          try {
            let a3 = await t3.batch(e2, s2.map((e3, t4) => (0, h.q)(n2[t4], { callbacks: e3?.getChild() })), r2);
            return await Promise.all(s2.map((e3, t4) => e3?.handleChainEnd(S(a3[t4], "output")))), a3;
          } catch (e3) {
            void 0 === a2 && (a2 = e3);
          }
        }
        if (!a2)
          throw Error("No error stored at end of fallbacks.");
        throw await Promise.all(s2.map((e3) => e3?.handleChainError(a2))), a2;
      }
    }
    function L(e2) {
      if ("function" == typeof e2)
        return new N({ func: e2 });
      if (A.isRunnable(e2))
        return e2;
      if (Array.isArray(e2) || "object" != typeof e2)
        throw Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
      {
        let t2 = {};
        for (let [r2, a2] of Object.entries(e2))
          t2[r2] = L(a2);
        return new I({ steps: t2 });
      }
    }
    class M extends A {
      static lc_name() {
        return "RunnableAssign";
      }
      constructor(e2) {
        e2 instanceof I && (e2 = { mapper: e2 }), super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "mapper", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.mapper = e2.mapper;
      }
      async invoke(e2, t2) {
        let r2 = await this.mapper.invoke(e2, t2);
        return { ...e2, ...r2 };
      }
      async *_transform(e2, t2, r2) {
        let a2 = this.mapper.getStepsKeys(), [n2, i2] = (0, c.atee)(e2), s2 = this.mapper.transform(i2, (0, h.q)(r2, { callbacks: t2?.getChild() })), o2 = s2.next();
        for await (let e3 of n2) {
          if ("object" != typeof e3 || Array.isArray(e3))
            throw Error(`RunnableAssign can only be used with objects as input, got ${typeof e3}`);
          let t3 = Object.fromEntries(Object.entries(e3).filter(([e4]) => !a2.includes(e4)));
          Object.keys(t3).length > 0 && (yield t3);
        }
        for await (let e3 of (yield (await o2).value, s2))
          yield e3;
      }
      transform(e2, t2) {
        return this._transformStreamWithConfig(e2, this._transform.bind(this), t2);
      }
      async stream(e2, t2) {
        async function* r2() {
          yield e2;
        }
        let a2 = (0, h.LE)(t2), n2 = new c.AsyncGeneratorWithSetup({ generator: this.transform(r2(), a2), config: a2 });
        return await n2.setup, c.IterableReadableStream.fromAsyncGenerator(n2);
      }
    }
    class D extends A {
      static lc_name() {
        return "RunnablePick";
      }
      constructor(e2) {
        ("string" == typeof e2 || Array.isArray(e2)) && (e2 = { keys: e2 }), super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "runnables"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "keys", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.keys = e2.keys;
      }
      async _pick(e2) {
        if ("string" == typeof this.keys)
          return e2[this.keys];
        {
          let t2 = this.keys.map((t3) => [t3, e2[t3]]).filter((e3) => void 0 !== e3[1]);
          return 0 === t2.length ? void 0 : Object.fromEntries(t2);
        }
      }
      async invoke(e2, t2) {
        return this._callWithConfig(this._pick.bind(this), e2, t2);
      }
      async *_transform(e2) {
        for await (let t2 of e2) {
          let e3 = await this._pick(t2);
          void 0 !== e3 && (yield e3);
        }
      }
      transform(e2, t2) {
        return this._transformStreamWithConfig(e2, this._transform.bind(this), t2);
      }
      async stream(e2, t2) {
        async function* r2() {
          yield e2;
        }
        let a2 = (0, h.LE)(t2), n2 = new c.AsyncGeneratorWithSetup({ generator: this.transform(r2(), a2), config: a2 });
        return await n2.setup, c.IterableReadableStream.fromAsyncGenerator(n2);
      }
    }
    class U extends k {
      constructor(e2) {
        super({ bound: C.from([N.from(async (e3) => {
          let t2;
          if ((0, O.u)(e3))
            try {
              t2 = await this.schema.parseAsync(e3.args);
            } catch (t3) {
              throw new O.Y("Received tool input did not match expected schema", JSON.stringify(e3.args));
            }
          else
            t2 = e3;
          return t2;
        }).withConfig({ runName: `${e2.name}:parse_input` }), e2.bound]).withConfig({ runName: e2.name }), config: e2.config ?? {} }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "description", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "schema", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.name = e2.name, this.description = e2.description, this.schema = e2.schema;
      }
      static lc_name() {
        return "RunnableToolLike";
      }
    }
  };
  __namedExportsObject["__chunk_4135"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BasePromptValue: () => s, ChatPromptValue: () => l, ImagePromptValue: () => u, StringPromptValue: () => o });
    var a = r(3686), n = r(9074), i = r(6131);
    class s extends a.Serializable {
    }
    class o extends s {
      static lc_name() {
        return "StringPromptValue";
      }
      constructor(e2) {
        super({ value: e2 }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "prompt_values"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.value = e2;
      }
      toString() {
        return this.value;
      }
      toChatMessages() {
        return [new n.xk(this.value)];
      }
    }
    class l extends s {
      static lc_name() {
        return "ChatPromptValue";
      }
      constructor(e2) {
        Array.isArray(e2) && (e2 = { messages: e2 }), super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "prompt_values"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "messages", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.messages = e2.messages;
      }
      toString() {
        return (0, i.zs)(this.messages);
      }
      toChatMessages() {
        return this.messages;
      }
    }
    class u extends s {
      static lc_name() {
        return "ImagePromptValue";
      }
      constructor(e2) {
        "imageUrl" in e2 || (e2 = { imageUrl: e2 }), super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "prompt_values"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "imageUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.imageUrl = e2.imageUrl;
      }
      toString() {
        return this.imageUrl.url;
      }
      toChatMessages() {
        return [new n.xk({ content: [{ type: "image_url", image_url: { detail: this.imageUrl.detail, url: this.imageUrl.url } }] })];
      }
    }
  };
  __namedExportsObject["__chunk_3926"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { ChatGenerationChunk: () => i, GenerationChunk: () => n, RUN_KEY: () => a });
    let a = "__run";
    class n {
      constructor(e2) {
        Object.defineProperty(this, "text", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "generationInfo", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.text = e2.text, this.generationInfo = e2.generationInfo;
      }
      concat(e2) {
        return new n({ text: this.text + e2.text, generationInfo: { ...this.generationInfo, ...e2.generationInfo } });
      }
    }
    class i extends n {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "message", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.message = e2.message;
      }
      concat(e2) {
        return new i({ text: this.text + e2.text, generationInfo: { ...this.generationInfo, ...e2.generationInfo }, message: this.message.concat(e2.message) });
      }
    }
  };
  __namedExportsObject["__chunk_9757"] = (e, t, r) => {
    "use strict";
    r.d(t, { G: () => l, g: () => u });
    var a = r(2811), n = r(4886), i = r(6131), s = r(3926), o = r(2003);
    class l extends a.bI {
      async *_transform(e2) {
        for await (let t2 of e2)
          "string" == typeof t2 ? yield this.parseResult([{ text: t2 }]) : yield this.parseResult([{ message: t2, text: this._baseMessageToString(t2) }]);
      }
      async *transform(e2, t2) {
        yield* this._transformStreamWithConfig(e2, this._transform.bind(this), { ...t2, runType: "parser" });
      }
    }
    class u extends l {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "diff", { enumerable: true, configurable: true, writable: true, value: false }), this.diff = e2?.diff ?? this.diff;
      }
      async *_transform(e2) {
        let t2, r2;
        for await (let a2 of e2) {
          let e3;
          if ("string" != typeof a2 && "string" != typeof a2.content)
            throw Error("Cannot handle non-string output.");
          if ((0, n.a2)(a2)) {
            if ("string" != typeof a2.content)
              throw Error("Cannot handle non-string message output.");
            e3 = new s.ChatGenerationChunk({ message: a2, text: a2.content });
          } else if ((0, n.QW)(a2)) {
            if ("string" != typeof a2.content)
              throw Error("Cannot handle non-string message output.");
            e3 = new s.ChatGenerationChunk({ message: (0, i.Oy)(a2), text: a2.content });
          } else
            e3 = new s.GenerationChunk({ text: a2 });
          r2 = void 0 === r2 ? e3 : r2.concat(e3);
          let l2 = await this.parsePartialResult([r2]);
          null == l2 || (0, o.hh)(l2, t2) || (this.diff ? yield this._diff(t2, l2) : yield l2, t2 = l2);
        }
      }
      getFormatInstructions() {
        return "";
      }
    }
  };
  __namedExportsObject["__chunk_5747"] = (e, t, r) => {
    "use strict";
    r.d(t, { Mw: () => i.M, Qh: () => s, gP: () => i.g });
    var a = r(9757), n = r(349), i = r(5466);
    class s extends a.g {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true });
      }
      static lc_name() {
        return "JsonOutputParser";
      }
      _diff(e2, t2) {
        return t2 ? e2 ? (0, n.compare)(e2, t2) : [{ op: "replace", path: "", value: t2 }] : void 0;
      }
      async parsePartialResult(e2) {
        return (0, i.M)(e2[0].text);
      }
      async parse(e2) {
        return (0, i.M)(e2, JSON.parse);
      }
      getFormatInstructions() {
        return "";
      }
    }
  };
  __namedExportsObject["__chunk_1272"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { AsymmetricStructuredOutputParser: () => g, BaseCumulativeTransformOutputParser: () => n.g, BaseLLMOutputParser: () => a.tw, BaseOutputParser: () => a.bI, BaseTransformOutputParser: () => n.G, BytesOutputParser: () => i, CommaSeparatedListOutputParser: () => o, CustomListOutputParser: () => l, JsonMarkdownStructuredOutputParser: () => m, JsonOutputParser: () => y.Qh, ListOutputParser: () => s, MarkdownListOutputParser: () => c, NumberedListOutputParser: () => u, OutputParserException: () => a.dS, StringOutputParser: () => d, StructuredOutputParser: () => f, XMLOutputParser: () => w, XML_FORMAT_INSTRUCTIONS: () => _, parseJsonMarkdown: () => y.Mw, parsePartialJson: () => y.gP, parseXMLMarkdown: () => O });
    var a = r(2811), n = r(9757);
    class i extends n.G {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers", "bytes"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "textEncoder", { enumerable: true, configurable: true, writable: true, value: new TextEncoder() });
      }
      static lc_name() {
        return "BytesOutputParser";
      }
      parse(e2) {
        return Promise.resolve(this.textEncoder.encode(e2));
      }
      getFormatInstructions() {
        return "";
      }
    }
    class s extends n.G {
      constructor() {
        super(...arguments), Object.defineProperty(this, "re", { enumerable: true, configurable: true, writable: true, value: void 0 });
      }
      async *_transform(e2) {
        let t2 = "";
        for await (let r2 of e2)
          if ("string" == typeof r2 ? t2 += r2 : t2 += r2.content, this.re) {
            let e3 = [...t2.matchAll(this.re)];
            if (e3.length > 1) {
              let r3 = 0;
              for (let t3 of e3.slice(0, -1))
                yield [t3[1]], r3 += (t3.index ?? 0) + t3[0].length;
              t2 = t2.slice(r3);
            }
          } else {
            let e3 = await this.parse(t2);
            if (e3.length > 1) {
              for (let t3 of e3.slice(0, -1))
                yield [t3];
              t2 = e3[e3.length - 1];
            }
          }
        for (let e3 of await this.parse(t2))
          yield [e3];
      }
    }
    class o extends s {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers", "list"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true });
      }
      static lc_name() {
        return "CommaSeparatedListOutputParser";
      }
      async parse(e2) {
        try {
          return e2.trim().split(",").map((e3) => e3.trim());
        } catch (t2) {
          throw new a.dS(`Could not parse output: ${e2}`, e2);
        }
      }
      getFormatInstructions() {
        return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
      }
    }
    class l extends s {
      constructor({ length: e2, separator: t2 }) {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers", "list"] }), Object.defineProperty(this, "length", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "separator", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.length = e2, this.separator = t2 || ",";
      }
      async parse(e2) {
        try {
          let t2 = e2.trim().split(this.separator).map((e3) => e3.trim());
          if (void 0 !== this.length && t2.length !== this.length)
            throw new a.dS(`Incorrect number of items. Expected ${this.length}, got ${t2.length}.`);
          return t2;
        } catch (t2) {
          if (Object.getPrototypeOf(t2) === a.dS.prototype)
            throw t2;
          throw new a.dS(`Could not parse output: ${e2}`);
        }
      }
      getFormatInstructions() {
        return `Your response should be a list of ${void 0 === this.length ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
      }
    }
    class u extends s {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers", "list"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "re", { enumerable: true, configurable: true, writable: true, value: /\d+\.\s([^\n]+)/g });
      }
      static lc_name() {
        return "NumberedListOutputParser";
      }
      getFormatInstructions() {
        return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
      }
      async parse(e2) {
        return [...e2.matchAll(this.re) ?? []].map((e3) => e3[1]);
      }
    }
    class c extends s {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers", "list"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "re", { enumerable: true, configurable: true, writable: true, value: /^\s*[-*]\s([^\n]+)$/gm });
      }
      static lc_name() {
        return "NumberedListOutputParser";
      }
      getFormatInstructions() {
        return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
      }
      async parse(e2) {
        return [...e2.matchAll(this.re) ?? []].map((e3) => e3[1]);
      }
    }
    class d extends n.G {
      constructor() {
        super(...arguments), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers", "string"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true });
      }
      static lc_name() {
        return "StrOutputParser";
      }
      parse(e2) {
        return Promise.resolve(e2);
      }
      getFormatInstructions() {
        return "";
      }
      _textContentToString(e2) {
        return e2.text;
      }
      _imageUrlContentToString(e2) {
        throw Error('Cannot coerce a multimodal "image_url" message part into a string.');
      }
      _messageContentComplexToString(e2) {
        switch (e2.type) {
          case "text":
          case "text_delta":
            if ("text" in e2)
              return this._textContentToString(e2);
            break;
          case "image_url":
            if ("image_url" in e2)
              return this._imageUrlContentToString(e2);
            break;
          default:
            throw Error(`Cannot coerce "${e2.type}" message part into a string.`);
        }
        throw Error(`Invalid content type: ${e2.type}`);
      }
      _baseMessageContentToString(e2) {
        return e2.reduce((e3, t2) => e3 + this._messageContentComplexToString(t2), "");
      }
    }
    var h = r(5817), p = r(7026);
    class f extends a.bI {
      static lc_name() {
        return "StructuredOutputParser";
      }
      toJSON() {
        return this.toJSONNotImplemented();
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "schema", { enumerable: true, configurable: true, writable: true, value: e2 }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain", "output_parsers", "structured"] });
      }
      static fromZodSchema(e2) {
        return new this(e2);
      }
      static fromNamesAndDescriptions(e2) {
        return new this(h.z.object(Object.fromEntries(Object.entries(e2).map(([e3, t2]) => [e3, h.z.string().describe(t2)]))));
      }
      getFormatInstructions() {
        return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify((0, p.Y_)(this.schema))}
\`\`\`
`;
      }
      async parse(e2) {
        try {
          let t2 = (e2.includes("```") ? e2.trim().split(/```(?:json)?/)[1] : e2.trim()).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (e3, t3) => {
            let r2 = t3.replace(/\n/g, "\\n");
            return `"${r2}"`;
          }).replace(/\n/g, "");
          return await this.schema.parseAsync(JSON.parse(t2));
        } catch (t2) {
          throw new a.dS(`Failed to parse. Text: "${e2}". Error: ${t2}`, e2);
        }
      }
    }
    class m extends f {
      static lc_name() {
        return "JsonMarkdownStructuredOutputParser";
      }
      getFormatInstructions(e2) {
        let t2 = e2?.interpolationDepth ?? 1;
        if (t2 < 1)
          throw Error("f string interpolation depth must be at least 1");
        return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction((0, p.Y_)(this.schema)).replaceAll("{", "{".repeat(t2)).replaceAll("}", "}".repeat(t2))}
\`\`\``;
      }
      _schemaToInstruction(e2, t2 = 2) {
        if ("type" in e2) {
          let r2, a2 = false;
          if (Array.isArray(e2.type)) {
            let t3 = e2.type.findIndex((e3) => "null" === e3);
            -1 !== t3 && (a2 = true, e2.type.splice(t3, 1)), r2 = e2.type.join(" | ");
          } else
            r2 = e2.type;
          if ("object" === e2.type && e2.properties) {
            let r3 = e2.description ? ` // ${e2.description}` : "", a3 = Object.entries(e2.properties).map(([r4, a4]) => {
              let n3 = e2.required?.includes(r4) ? "" : " (optional)";
              return `${" ".repeat(t2)}"${r4}": ${this._schemaToInstruction(a4, t2 + 2)}${n3}`;
            }).join("\n");
            return `{
${a3}
${" ".repeat(t2 - 2)}}${r3}`;
          }
          if ("array" === e2.type && e2.items) {
            let r3 = e2.description ? ` // ${e2.description}` : "";
            return `array[
${" ".repeat(t2)}${this._schemaToInstruction(e2.items, t2 + 2)}
${" ".repeat(t2 - 2)}] ${r3}`;
          }
          let n2 = a2 ? " (nullable)" : "", i2 = e2.description ? ` // ${e2.description}` : "";
          return `${r2}${i2}${n2}`;
        }
        if ("anyOf" in e2)
          return e2.anyOf.map((e3) => this._schemaToInstruction(e3, t2)).join(`
${" ".repeat(t2 - 2)}`);
        throw Error("unsupported schema type");
      }
      static fromZodSchema(e2) {
        return new this(e2);
      }
      static fromNamesAndDescriptions(e2) {
        return new this(h.z.object(Object.fromEntries(Object.entries(e2).map(([e3, t2]) => [e3, h.z.string().describe(t2)]))));
      }
    }
    class g extends a.bI {
      constructor({ inputSchema: e2 }) {
        super(...arguments), Object.defineProperty(this, "structuredInputParser", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.structuredInputParser = new m(e2);
      }
      async parse(e2) {
        let t2;
        try {
          t2 = await this.structuredInputParser.parse(e2);
        } catch (t3) {
          throw new a.dS(`Failed to parse. Text: "${e2}". Error: ${t3}`, e2);
        }
        return this.outputProcessor(t2);
      }
      getFormatInstructions() {
        return this.structuredInputParser.getFormatInstructions();
      }
    }
    var y = r(5747), b = r(349);
    let v = function() {
      let e2 = {};
      e2.parser = function(e3, t3) {
        return new r2(e3, t3);
      }, e2.SAXParser = r2, e2.SAXStream = l2, e2.createStream = function(e3, t3) {
        return new l2(e3, t3);
      }, e2.MAX_BUFFER_LENGTH = 65536;
      let t2 = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
      function r2(a3, n3) {
        if (!(this instanceof r2))
          return new r2(a3, n3);
        (function(e3) {
          for (var r3 = 0, a4 = t2.length; r3 < a4; r3++)
            e3[t2[r3]] = "";
        })(this), this.q = this.c = "", this.bufferCheckPosition = e2.MAX_BUFFER_LENGTH, this.opt = n3 || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], this.closed = this.closedRoot = this.sawRoot = false, this.tag = this.error = null, this.strict = !!a3, this.noscript = !!(a3 || this.opt.noscript), this.state = v2.BEGIN, this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(e2.XML_ENTITIES) : Object.create(e2.ENTITIES), this.attribList = [], this.opt.xmlns && (this.ns = Object.create(d2)), this.trackPosition = false !== this.opt.position, this.trackPosition && (this.position = this.line = this.column = 0), w2(this, "onready");
      }
      e2.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function(e3) {
        function t3() {
        }
        return t3.prototype = e3, new t3();
      }), Object.keys || (Object.keys = function(e3) {
        var t3 = [];
        for (var r3 in e3)
          e3.hasOwnProperty(r3) && t3.push(r3);
        return t3;
      }), r2.prototype = { end: function() {
        A(this);
      }, write: function(r3) {
        if (this.error)
          throw this.error;
        if (this.closed)
          return S(this, "Cannot write after close. Assign an onready handler.");
        if (null === r3)
          return A(this);
        "object" == typeof r3 && (r3 = r3.toString());
        for (var a3 = 0, n3 = ""; n3 = $(r3, a3++), this.c = n3, n3; )
          switch (this.trackPosition && (this.position++, "\n" === n3 ? (this.line++, this.column = 0) : this.column++), this.state) {
            case v2.BEGIN:
              if (this.state = v2.BEGIN_WHITESPACE, "\uFEFF" === n3)
                continue;
              N(this, n3);
              continue;
            case v2.BEGIN_WHITESPACE:
              N(this, n3);
              continue;
            case v2.TEXT:
              if (this.sawRoot && !this.closedRoot) {
                for (var i3 = a3 - 1; n3 && "<" !== n3 && "&" !== n3; )
                  (n3 = $(r3, a3++)) && this.trackPosition && (this.position++, "\n" === n3 ? (this.line++, this.column = 0) : this.column++);
                this.textNode += r3.substring(i3, a3 - 1);
              }
              "<" !== n3 || this.sawRoot && this.closedRoot && !this.strict ? (g2(n3) || this.sawRoot && !this.closedRoot || k(this, "Text data outside of root node."), "&" === n3 ? this.state = v2.TEXT_ENTITY : this.textNode += n3) : (this.state = v2.OPEN_WAKA, this.startTagPosition = this.position);
              continue;
            case v2.SCRIPT:
              "<" === n3 ? this.state = v2.SCRIPT_ENDING : this.script += n3;
              continue;
            case v2.SCRIPT_ENDING:
              "/" === n3 ? this.state = v2.CLOSE_TAG : (this.script += "<" + n3, this.state = v2.SCRIPT);
              continue;
            case v2.OPEN_WAKA:
              "!" === n3 ? (this.state = v2.SGML_DECL, this.sgmlDecl = "") : g2(n3) || (b2(h2, n3) ? (this.state = v2.OPEN_TAG, this.tagName = n3) : "/" === n3 ? (this.state = v2.CLOSE_TAG, this.tagName = "") : "?" === n3 ? (this.state = v2.PROC_INST, this.procInstName = this.procInstBody = "") : (k(this, "Unencoded <"), this.startTagPosition + 1 < this.position && (n3 = Array(this.position - this.startTagPosition).join(" ") + n3), this.textNode += "<" + n3, this.state = v2.TEXT));
              continue;
            case v2.SGML_DECL:
              "[CDATA[" === (this.sgmlDecl + n3).toUpperCase() ? (E2(this, "onopencdata"), this.state = v2.CDATA, this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + n3 === "--" ? (this.state = v2.COMMENT, this.comment = "", this.sgmlDecl = "") : "DOCTYPE" === (this.sgmlDecl + n3).toUpperCase() ? (this.state = v2.DOCTYPE, (this.doctype || this.sawRoot) && k(this, "Inappropriately located doctype declaration"), this.doctype = "", this.sgmlDecl = "") : ">" === n3 ? (E2(this, "onsgmldeclaration", this.sgmlDecl), this.sgmlDecl = "", this.state = v2.TEXT) : (y2(n3) && (this.state = v2.SGML_DECL_QUOTED), this.sgmlDecl += n3);
              continue;
            case v2.SGML_DECL_QUOTED:
              n3 === this.q && (this.state = v2.SGML_DECL, this.q = ""), this.sgmlDecl += n3;
              continue;
            case v2.DOCTYPE:
              ">" === n3 ? (this.state = v2.TEXT, E2(this, "ondoctype", this.doctype), this.doctype = true) : (this.doctype += n3, "[" === n3 ? this.state = v2.DOCTYPE_DTD : y2(n3) && (this.state = v2.DOCTYPE_QUOTED, this.q = n3));
              continue;
            case v2.DOCTYPE_QUOTED:
              this.doctype += n3, n3 === this.q && (this.q = "", this.state = v2.DOCTYPE);
              continue;
            case v2.DOCTYPE_DTD:
              this.doctype += n3, "]" === n3 ? this.state = v2.DOCTYPE : y2(n3) && (this.state = v2.DOCTYPE_DTD_QUOTED, this.q = n3);
              continue;
            case v2.DOCTYPE_DTD_QUOTED:
              this.doctype += n3, n3 === this.q && (this.state = v2.DOCTYPE_DTD, this.q = "");
              continue;
            case v2.COMMENT:
              "-" === n3 ? this.state = v2.COMMENT_ENDING : this.comment += n3;
              continue;
            case v2.COMMENT_ENDING:
              "-" === n3 ? (this.state = v2.COMMENT_ENDED, this.comment = O2(this.opt, this.comment), this.comment && E2(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + n3, this.state = v2.COMMENT);
              continue;
            case v2.COMMENT_ENDED:
              ">" !== n3 ? (k(this, "Malformed comment"), this.comment += "--" + n3, this.state = v2.COMMENT) : this.state = v2.TEXT;
              continue;
            case v2.CDATA:
              "]" === n3 ? this.state = v2.CDATA_ENDING : this.cdata += n3;
              continue;
            case v2.CDATA_ENDING:
              "]" === n3 ? this.state = v2.CDATA_ENDING_2 : (this.cdata += "]" + n3, this.state = v2.CDATA);
              continue;
            case v2.CDATA_ENDING_2:
              ">" === n3 ? (this.cdata && E2(this, "oncdata", this.cdata), E2(this, "onclosecdata"), this.cdata = "", this.state = v2.TEXT) : "]" === n3 ? this.cdata += "]" : (this.cdata += "]]" + n3, this.state = v2.CDATA);
              continue;
            case v2.PROC_INST:
              "?" === n3 ? this.state = v2.PROC_INST_ENDING : g2(n3) ? this.state = v2.PROC_INST_BODY : this.procInstName += n3;
              continue;
            case v2.PROC_INST_BODY:
              !this.procInstBody && g2(n3) || ("?" === n3 ? this.state = v2.PROC_INST_ENDING : this.procInstBody += n3);
              continue;
            case v2.PROC_INST_ENDING:
              ">" === n3 ? (E2(this, "onprocessinginstruction", { name: this.procInstName, body: this.procInstBody }), this.procInstName = this.procInstBody = "", this.state = v2.TEXT) : (this.procInstBody += "?" + n3, this.state = v2.PROC_INST_BODY);
              continue;
            case v2.OPEN_TAG:
              b2(p2, n3) ? this.tagName += n3 : (function(e3) {
                e3.strict || (e3.tagName = e3.tagName[e3.looseCase]());
                var t3 = e3.tags[e3.tags.length - 1] || e3, r4 = e3.tag = { name: e3.tagName, attributes: {} };
                e3.opt.xmlns && (r4.ns = t3.ns), e3.attribList.length = 0, E2(e3, "onopentagstart", r4);
              }(this), ">" === n3 ? C(this) : "/" === n3 ? this.state = v2.OPEN_TAG_SLASH : (g2(n3) || k(this, "Invalid character in tag name"), this.state = v2.ATTRIB));
              continue;
            case v2.OPEN_TAG_SLASH:
              ">" === n3 ? (C(this, true), I(this)) : (k(this, "Forward-slash in opening tag not followed by >"), this.state = v2.ATTRIB);
              continue;
            case v2.ATTRIB:
              g2(n3) || (">" === n3 ? C(this) : "/" === n3 ? this.state = v2.OPEN_TAG_SLASH : b2(h2, n3) ? (this.attribName = n3, this.attribValue = "", this.state = v2.ATTRIB_NAME) : k(this, "Invalid attribute name"));
              continue;
            case v2.ATTRIB_NAME:
              "=" === n3 ? this.state = v2.ATTRIB_VALUE : ">" === n3 ? (k(this, "Attribute without value"), this.attribValue = this.attribName, P(this), C(this)) : g2(n3) ? this.state = v2.ATTRIB_NAME_SAW_WHITE : b2(p2, n3) ? this.attribName += n3 : k(this, "Invalid attribute name");
              continue;
            case v2.ATTRIB_NAME_SAW_WHITE:
              "=" === n3 ? this.state = v2.ATTRIB_VALUE : g2(n3) || (k(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", this.attribValue = "", E2(this, "onattribute", { name: this.attribName, value: "" }), this.attribName = "", ">" === n3 ? C(this) : b2(h2, n3) ? (this.attribName = n3, this.state = v2.ATTRIB_NAME) : (k(this, "Invalid attribute name"), this.state = v2.ATTRIB));
              continue;
            case v2.ATTRIB_VALUE:
              g2(n3) || (y2(n3) ? (this.q = n3, this.state = v2.ATTRIB_VALUE_QUOTED) : (k(this, "Unquoted attribute value"), this.state = v2.ATTRIB_VALUE_UNQUOTED, this.attribValue = n3));
              continue;
            case v2.ATTRIB_VALUE_QUOTED:
              if (n3 !== this.q) {
                "&" === n3 ? this.state = v2.ATTRIB_VALUE_ENTITY_Q : this.attribValue += n3;
                continue;
              }
              P(this), this.q = "", this.state = v2.ATTRIB_VALUE_CLOSED;
              continue;
            case v2.ATTRIB_VALUE_CLOSED:
              g2(n3) ? this.state = v2.ATTRIB : ">" === n3 ? C(this) : "/" === n3 ? this.state = v2.OPEN_TAG_SLASH : b2(h2, n3) ? (k(this, "No whitespace between attributes"), this.attribName = n3, this.attribValue = "", this.state = v2.ATTRIB_NAME) : k(this, "Invalid attribute name");
              continue;
            case v2.ATTRIB_VALUE_UNQUOTED:
              if (!(">" === (s3 = n3) || g2(s3))) {
                "&" === n3 ? this.state = v2.ATTRIB_VALUE_ENTITY_U : this.attribValue += n3;
                continue;
              }
              P(this), ">" === n3 ? C(this) : this.state = v2.ATTRIB;
              continue;
            case v2.CLOSE_TAG:
              this.tagName ? ">" === n3 ? I(this) : b2(p2, n3) ? this.tagName += n3 : this.script ? (this.script += "</" + this.tagName, this.tagName = "", this.state = v2.SCRIPT) : (g2(n3) || k(this, "Invalid tagname in closing tag"), this.state = v2.CLOSE_TAG_SAW_WHITE) : g2(n3) || (b2(h2, n3) ? this.tagName = n3 : this.script ? (this.script += "</" + n3, this.state = v2.SCRIPT) : k(this, "Invalid tagname in closing tag."));
              continue;
            case v2.CLOSE_TAG_SAW_WHITE:
              if (g2(n3))
                continue;
              ">" === n3 ? I(this) : k(this, "Invalid characters in closing tag");
              continue;
            case v2.TEXT_ENTITY:
            case v2.ATTRIB_VALUE_ENTITY_Q:
            case v2.ATTRIB_VALUE_ENTITY_U:
              switch (this.state) {
                case v2.TEXT_ENTITY:
                  o3 = v2.TEXT, l3 = "textNode";
                  break;
                case v2.ATTRIB_VALUE_ENTITY_Q:
                  o3 = v2.ATTRIB_VALUE_QUOTED, l3 = "attribValue";
                  break;
                case v2.ATTRIB_VALUE_ENTITY_U:
                  o3 = v2.ATTRIB_VALUE_UNQUOTED, l3 = "attribValue";
              }
              if (";" === n3) {
                if (this.opt.unparsedEntities) {
                  var s3, o3, l3, u3 = R(this);
                  this.entity = "", this.state = o3, this.write(u3);
                } else
                  this[l3] += R(this), this.entity = "", this.state = o3;
              } else
                b2(this.entity.length ? m2 : f2, n3) ? this.entity += n3 : (k(this, "Invalid character in entity name"), this[l3] += "&" + this.entity + n3, this.entity = "", this.state = o3);
              continue;
            default:
              throw Error(this, "Unknown state: " + this.state);
          }
        return this.position >= this.bufferCheckPosition && function(r4) {
          for (var a4 = Math.max(e2.MAX_BUFFER_LENGTH, 10), n4 = 0, i4 = 0, s4 = t2.length; i4 < s4; i4++) {
            var o4 = r4[t2[i4]].length;
            if (o4 > a4)
              switch (t2[i4]) {
                case "textNode":
                  x2(r4);
                  break;
                case "cdata":
                  E2(r4, "oncdata", r4.cdata), r4.cdata = "";
                  break;
                case "script":
                  E2(r4, "onscript", r4.script), r4.script = "";
                  break;
                default:
                  S(r4, "Max buffer length exceeded: " + t2[i4]);
              }
            n4 = Math.max(n4, o4);
          }
          var l4 = e2.MAX_BUFFER_LENGTH - n4;
          r4.bufferCheckPosition = l4 + r4.position;
        }(this), this;
      }, resume: function() {
        return this.error = null, this;
      }, close: function() {
        return this.write(null);
      }, flush: function() {
        x2(this), "" !== this.cdata && (E2(this, "oncdata", this.cdata), this.cdata = ""), "" !== this.script && (E2(this, "onscript", this.script), this.script = "");
      } };
      var a2, n2, i2, s2 = ReadableStream;
      s2 || (s2 = function() {
      });
      var o2 = e2.EVENTS.filter(function(e3) {
        return "error" !== e3 && "end" !== e3;
      });
      function l2(e3, t3) {
        if (!(this instanceof l2))
          return new l2(e3, t3);
        s2.apply(this), this._parser = new r2(e3, t3), this.writable = true, this.readable = true;
        var a3 = this;
        this._parser.onend = function() {
          a3.emit("end");
        }, this._parser.onerror = function(e4) {
          a3.emit("error", e4), a3._parser.error = null;
        }, this._decoder = null, o2.forEach(function(e4) {
          Object.defineProperty(a3, "on" + e4, { get: function() {
            return a3._parser["on" + e4];
          }, set: function(t4) {
            if (!t4)
              return a3.removeAllListeners(e4), a3._parser["on" + e4] = t4, t4;
            a3.on(e4, t4);
          }, enumerable: true, configurable: false });
        });
      }
      l2.prototype = Object.create(s2.prototype, { constructor: { value: l2 } }), l2.prototype.write = function(e3) {
        return this._parser.write(e3.toString()), this.emit("data", e3), true;
      }, l2.prototype.end = function(e3) {
        return e3 && e3.length && this.write(e3), this._parser.end(), true;
      }, l2.prototype.on = function(e3, t3) {
        var r3 = this;
        return r3._parser["on" + e3] || -1 === o2.indexOf(e3) || (r3._parser["on" + e3] = function() {
          var t4 = 1 == arguments.length ? [arguments[0]] : Array.apply(null, arguments);
          t4.splice(0, 0, e3), r3.emit.apply(r3, t4);
        }), s2.prototype.on.call(r3, e3, t3);
      };
      var u2 = "http://www.w3.org/XML/1998/namespace", c2 = "http://www.w3.org/2000/xmlns/", d2 = { xml: u2, xmlns: c2 }, h2 = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, p2 = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, f2 = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, m2 = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function g2(e3) {
        return " " === e3 || "\n" === e3 || "\r" === e3 || "	" === e3;
      }
      function y2(e3) {
        return '"' === e3 || "'" === e3;
      }
      function b2(e3, t3) {
        return e3.test(t3);
      }
      var v2 = 0;
      for (var _2 in e2.STATE = { BEGIN: v2++, BEGIN_WHITESPACE: v2++, TEXT: v2++, TEXT_ENTITY: v2++, OPEN_WAKA: v2++, SGML_DECL: v2++, SGML_DECL_QUOTED: v2++, DOCTYPE: v2++, DOCTYPE_QUOTED: v2++, DOCTYPE_DTD: v2++, DOCTYPE_DTD_QUOTED: v2++, COMMENT_STARTING: v2++, COMMENT: v2++, COMMENT_ENDING: v2++, COMMENT_ENDED: v2++, CDATA: v2++, CDATA_ENDING: v2++, CDATA_ENDING_2: v2++, PROC_INST: v2++, PROC_INST_BODY: v2++, PROC_INST_ENDING: v2++, OPEN_TAG: v2++, OPEN_TAG_SLASH: v2++, ATTRIB: v2++, ATTRIB_NAME: v2++, ATTRIB_NAME_SAW_WHITE: v2++, ATTRIB_VALUE: v2++, ATTRIB_VALUE_QUOTED: v2++, ATTRIB_VALUE_CLOSED: v2++, ATTRIB_VALUE_UNQUOTED: v2++, ATTRIB_VALUE_ENTITY_Q: v2++, ATTRIB_VALUE_ENTITY_U: v2++, CLOSE_TAG: v2++, CLOSE_TAG_SAW_WHITE: v2++, SCRIPT: v2++, SCRIPT_ENDING: v2++ }, e2.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, e2.ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'", AElig: 198, Aacute: 193, Acirc: 194, Agrave: 192, Aring: 197, Atilde: 195, Auml: 196, Ccedil: 199, ETH: 208, Eacute: 201, Ecirc: 202, Egrave: 200, Euml: 203, Iacute: 205, Icirc: 206, Igrave: 204, Iuml: 207, Ntilde: 209, Oacute: 211, Ocirc: 212, Ograve: 210, Oslash: 216, Otilde: 213, Ouml: 214, THORN: 222, Uacute: 218, Ucirc: 219, Ugrave: 217, Uuml: 220, Yacute: 221, aacute: 225, acirc: 226, aelig: 230, agrave: 224, aring: 229, atilde: 227, auml: 228, ccedil: 231, eacute: 233, ecirc: 234, egrave: 232, eth: 240, euml: 235, iacute: 237, icirc: 238, igrave: 236, iuml: 239, ntilde: 241, oacute: 243, ocirc: 244, ograve: 242, oslash: 248, otilde: 245, ouml: 246, szlig: 223, thorn: 254, uacute: 250, ucirc: 251, ugrave: 249, uuml: 252, yacute: 253, yuml: 255, copy: 169, reg: 174, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, deg: 176, plusmn: 177, sup1: 185, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, times: 215, divide: 247, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }, Object.keys(e2.ENTITIES).forEach(function(t3) {
        var r3 = e2.ENTITIES[t3], a3 = "number" == typeof r3 ? String.fromCharCode(r3) : r3;
        e2.ENTITIES[t3] = a3;
      }), e2.STATE)
        e2.STATE[e2.STATE[_2]] = _2;
      function w2(e3, t3, r3) {
        e3[t3] && e3[t3](r3);
      }
      function E2(e3, t3, r3) {
        e3.textNode && x2(e3), w2(e3, t3, r3);
      }
      function x2(e3) {
        e3.textNode = O2(e3.opt, e3.textNode), e3.textNode && w2(e3, "ontext", e3.textNode), e3.textNode = "";
      }
      function O2(e3, t3) {
        return e3.trim && (t3 = t3.trim()), e3.normalize && (t3 = t3.replace(/\s+/g, " ")), t3;
      }
      function S(e3, t3) {
        return x2(e3), e3.trackPosition && (t3 += "\nLine: " + e3.line + "\nColumn: " + e3.column + "\nChar: " + e3.c), t3 = Error(t3), e3.error = t3, w2(e3, "onerror", t3), e3;
      }
      function A(e3) {
        return e3.sawRoot && !e3.closedRoot && k(e3, "Unclosed root tag"), e3.state !== v2.BEGIN && e3.state !== v2.BEGIN_WHITESPACE && e3.state !== v2.TEXT && S(e3, "Unexpected end"), x2(e3), e3.c = "", e3.closed = true, w2(e3, "onend"), r2.call(e3, e3.strict, e3.opt), e3;
      }
      function k(e3, t3) {
        if ("object" != typeof e3 || !(e3 instanceof r2))
          throw Error("bad call to strictFail");
        e3.strict && S(e3, t3);
      }
      function T(e3, t3) {
        var r3 = 0 > e3.indexOf(":") ? ["", e3] : e3.split(":"), a3 = r3[0], n3 = r3[1];
        return t3 && "xmlns" === e3 && (a3 = "xmlns", n3 = ""), { prefix: a3, local: n3 };
      }
      function P(e3) {
        if (e3.strict || (e3.attribName = e3.attribName[e3.looseCase]()), -1 !== e3.attribList.indexOf(e3.attribName) || e3.tag.attributes.hasOwnProperty(e3.attribName)) {
          e3.attribName = e3.attribValue = "";
          return;
        }
        if (e3.opt.xmlns) {
          var t3 = T(e3.attribName, true), r3 = t3.prefix, a3 = t3.local;
          if ("xmlns" === r3) {
            if ("xml" === a3 && e3.attribValue !== u2)
              k(e3, "xml: prefix must be bound to " + u2 + "\nActual: " + e3.attribValue);
            else if ("xmlns" === a3 && e3.attribValue !== c2)
              k(e3, "xmlns: prefix must be bound to " + c2 + "\nActual: " + e3.attribValue);
            else {
              var n3 = e3.tag, i3 = e3.tags[e3.tags.length - 1] || e3;
              n3.ns === i3.ns && (n3.ns = Object.create(i3.ns)), n3.ns[a3] = e3.attribValue;
            }
          }
          e3.attribList.push([e3.attribName, e3.attribValue]);
        } else
          e3.tag.attributes[e3.attribName] = e3.attribValue, E2(e3, "onattribute", { name: e3.attribName, value: e3.attribValue });
        e3.attribName = e3.attribValue = "";
      }
      function C(e3, t3) {
        if (e3.opt.xmlns) {
          var r3 = e3.tag, a3 = T(e3.tagName);
          r3.prefix = a3.prefix, r3.local = a3.local, r3.uri = r3.ns[a3.prefix] || "", r3.prefix && !r3.uri && (k(e3, "Unbound namespace prefix: " + JSON.stringify(e3.tagName)), r3.uri = a3.prefix);
          var n3 = e3.tags[e3.tags.length - 1] || e3;
          r3.ns && n3.ns !== r3.ns && Object.keys(r3.ns).forEach(function(t4) {
            E2(e3, "onopennamespace", { prefix: t4, uri: r3.ns[t4] });
          });
          for (var i3 = 0, s3 = e3.attribList.length; i3 < s3; i3++) {
            var o3 = e3.attribList[i3], l3 = o3[0], u3 = o3[1], c3 = T(l3, true), d3 = c3.prefix, h3 = c3.local, p3 = "" === d3 ? "" : r3.ns[d3] || "", f3 = { name: l3, value: u3, prefix: d3, local: h3, uri: p3 };
            d3 && "xmlns" !== d3 && !p3 && (k(e3, "Unbound namespace prefix: " + JSON.stringify(d3)), f3.uri = d3), e3.tag.attributes[l3] = f3, E2(e3, "onattribute", f3);
          }
          e3.attribList.length = 0;
        }
        e3.tag.isSelfClosing = !!t3, e3.sawRoot = true, e3.tags.push(e3.tag), E2(e3, "onopentag", e3.tag), t3 || (e3.noscript || "script" !== e3.tagName.toLowerCase() ? e3.state = v2.TEXT : e3.state = v2.SCRIPT, e3.tag = null, e3.tagName = ""), e3.attribName = e3.attribValue = "", e3.attribList.length = 0;
      }
      function I(e3) {
        if (!e3.tagName) {
          k(e3, "Weird empty close tag."), e3.textNode += "</>", e3.state = v2.TEXT;
          return;
        }
        if (e3.script) {
          if ("script" !== e3.tagName) {
            e3.script += "</" + e3.tagName + ">", e3.tagName = "", e3.state = v2.SCRIPT;
            return;
          }
          E2(e3, "onscript", e3.script), e3.script = "";
        }
        var t3 = e3.tags.length, r3 = e3.tagName;
        e3.strict || (r3 = r3[e3.looseCase]());
        for (var a3 = r3; t3--; )
          if (e3.tags[t3].name !== a3)
            k(e3, "Unexpected close tag");
          else
            break;
        if (t3 < 0) {
          k(e3, "Unmatched closing tag: " + e3.tagName), e3.textNode += "</" + e3.tagName + ">", e3.state = v2.TEXT;
          return;
        }
        e3.tagName = r3;
        for (var n3 = e3.tags.length; n3-- > t3; ) {
          var i3 = e3.tag = e3.tags.pop();
          e3.tagName = e3.tag.name, E2(e3, "onclosetag", e3.tagName);
          var s3 = {};
          for (var o3 in i3.ns)
            s3[o3] = i3.ns[o3];
          var l3 = e3.tags[e3.tags.length - 1] || e3;
          e3.opt.xmlns && i3.ns !== l3.ns && Object.keys(i3.ns).forEach(function(t4) {
            var r4 = i3.ns[t4];
            E2(e3, "onclosenamespace", { prefix: t4, uri: r4 });
          });
        }
        0 === t3 && (e3.closedRoot = true), e3.tagName = e3.attribValue = e3.attribName = "", e3.attribList.length = 0, e3.state = v2.TEXT;
      }
      function R(e3) {
        var t3, r3 = e3.entity, a3 = r3.toLowerCase(), n3 = "";
        return e3.ENTITIES[r3] ? e3.ENTITIES[r3] : e3.ENTITIES[a3] ? e3.ENTITIES[a3] : ("#" === (r3 = a3).charAt(0) && (n3 = "x" === r3.charAt(1) ? (t3 = parseInt(r3 = r3.slice(2), 16)).toString(16) : (t3 = parseInt(r3 = r3.slice(1), 10)).toString(10)), r3 = r3.replace(/^0+/, ""), isNaN(t3) || n3.toLowerCase() !== r3) ? (k(e3, "Invalid character entity"), "&" + e3.entity + ";") : String.fromCodePoint(t3);
      }
      function N(e3, t3) {
        "<" === t3 ? (e3.state = v2.OPEN_WAKA, e3.startTagPosition = e3.position) : g2(t3) || (k(e3, "Non-whitespace before first tag."), e3.textNode = t3, e3.state = v2.TEXT);
      }
      function $(e3, t3) {
        var r3 = "";
        return t3 < e3.length && (r3 = e3.charAt(t3)), r3;
      }
      return v2 = e2.STATE, String.fromCodePoint || (a2 = String.fromCharCode, n2 = Math.floor, i2 = function() {
        var e3, t3, r3 = [], i3 = -1, s3 = arguments.length;
        if (!s3)
          return "";
        for (var o3 = ""; ++i3 < s3; ) {
          var l3 = Number(arguments[i3]);
          if (!isFinite(l3) || l3 < 0 || l3 > 1114111 || n2(l3) !== l3)
            throw RangeError("Invalid code point: " + l3);
          l3 <= 65535 ? r3.push(l3) : (l3 -= 65536, e3 = (l3 >> 10) + 55296, t3 = l3 % 1024 + 56320, r3.push(e3, t3)), (i3 + 1 === s3 || r3.length > 16384) && (o3 += a2.apply(null, r3), r3.length = 0);
        }
        return o3;
      }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", { value: i2, configurable: true, writable: true }) : String.fromCodePoint = i2), e2;
    }(), _ = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
    class w extends n.g {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "output_parsers"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), this.tags = e2?.tags;
      }
      static lc_name() {
        return "XMLOutputParser";
      }
      _diff(e2, t2) {
        return t2 ? e2 ? (0, b.compare)(e2, t2) : [{ op: "replace", path: "", value: t2 }] : void 0;
      }
      async parsePartialResult(e2) {
        return O(e2[0].text);
      }
      async parse(e2) {
        return O(e2);
      }
      getFormatInstructions() {
        return this.tags && this.tags.length > 0 ? _.replace("{tags}", this.tags?.join(", ") ?? "") : _;
      }
    }
    let E = (e2) => e2.split("\n").map((e3) => e3.replace(/^\s+/, "")).join("\n").trim(), x = (e2) => {
      if (0 === Object.keys(e2).length)
        return {};
      let t2 = {};
      return e2.children.length > 0 ? t2[e2.name] = e2.children.map(x) : t2[e2.name] = e2.text ?? void 0, t2;
    };
    function O(e2) {
      let t2 = E(e2), r2 = v.parser(true), a2 = {}, n2 = [];
      r2.onopentag = (e3) => {
        let t3 = { name: e3.name, attributes: e3.attributes, children: [], text: "", isSelfClosing: e3.isSelfClosing };
        n2.length > 0 ? n2[n2.length - 1].children.push(t3) : a2 = t3, e3.isSelfClosing || n2.push(t3);
      }, r2.onclosetag = () => {
        if (n2.length > 0) {
          let e3 = n2.pop();
          0 === n2.length && e3 && (a2 = e3);
        }
      }, r2.ontext = (e3) => {
        if (n2.length > 0) {
          let t3 = n2[n2.length - 1];
          t3.text += e3;
        }
      }, r2.onattribute = (e3) => {
        n2.length > 0 && (n2[n2.length - 1].attributes[e3.name] = e3.value);
      };
      let i2 = /```(xml)?(.*)```/s.exec(t2), s2 = i2 ? i2[2] : t2;
      return r2.write(s2).close(), a2 && "?xml" === a2.name && (a2 = a2.children[0]), x(a2);
    }
  };
  __namedExportsObject["__chunk_2811"] = (e, t, r) => {
    "use strict";
    r.d(t, { bI: () => s, dS: () => o, tw: () => i });
    var a = r(3874), n = r(2397);
    class i extends a.Runnable {
      parseResultWithPrompt(e2, t2, r2) {
        return this.parseResult(e2, r2);
      }
      _baseMessageToString(e2) {
        return "string" == typeof e2.content ? e2.content : this._baseMessageContentToString(e2.content);
      }
      _baseMessageContentToString(e2) {
        return JSON.stringify(e2);
      }
      async invoke(e2, t2) {
        return "string" == typeof e2 ? this._callWithConfig(async (e3, t3) => this.parseResult([{ text: e3 }], t3?.callbacks), e2, { ...t2, runType: "parser" }) : this._callWithConfig(async (e3, t3) => this.parseResult([{ message: e3, text: this._baseMessageToString(e3) }], t3?.callbacks), e2, { ...t2, runType: "parser" });
      }
    }
    class s extends i {
      parseResult(e2, t2) {
        return this.parse(e2[0].text, t2);
      }
      async parseWithPrompt(e2, t2, r2) {
        return this.parse(e2, r2);
      }
      _type() {
        throw Error("_type not implemented");
      }
    }
    class o extends Error {
      constructor(e2, t2, r2, a2 = false) {
        if (super(e2), Object.defineProperty(this, "llmOutput", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "observation", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "sendToLLM", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.llmOutput = t2, this.observation = r2, this.sendToLLM = a2, a2 && (void 0 === r2 || void 0 === t2))
          throw Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
        (0, n.r)(this, "OUTPUT_PARSING_FAILURE");
      }
    }
  };
  __namedExportsObject["__chunk_6131"] = (e, t, r) => {
    "use strict";
    r.d(t, { DC: () => y, E1: () => f, Oy: () => v, rk: () => g, xb: () => b, zs: () => m });
    var a = r(2397), n = r(2493), i = r(1582), s = r(4886), o = r(8398), l = r(9203), u = r(9074), c = r(8878), d = r(4806);
    function h(e2) {
      return (0, n.u)(e2) ? e2 : "string" == typeof e2.id && "function" === e2.type && "object" == typeof e2.function && null !== e2.function && "arguments" in e2.function && "string" == typeof e2.function.arguments && "name" in e2.function && "string" == typeof e2.function.name ? { id: e2.id, args: JSON.parse(e2.function.arguments), name: e2.function.name, type: "tool_call" } : e2;
    }
    function p(e2) {
      let t2, r2;
      if ("object" == typeof e2 && null != e2 && 1 === e2.lc && Array.isArray(e2.id) && null != e2.kwargs && "object" == typeof e2.kwargs) {
        let a2 = e2.id.at(-1);
        t2 = "HumanMessage" === a2 || "HumanMessageChunk" === a2 ? "user" : "AIMessage" === a2 || "AIMessageChunk" === a2 ? "assistant" : "SystemMessage" === a2 || "SystemMessageChunk" === a2 ? "system" : "unknown", r2 = e2.kwargs;
      } else {
        let { type: a2, ...n2 } = e2;
        t2 = a2, r2 = n2;
      }
      if ("human" === t2 || "user" === t2)
        return new u.xk(r2);
      if ("ai" === t2 || "assistant" === t2) {
        let { tool_calls: e3, ...t3 } = r2;
        if (!Array.isArray(e3))
          return new i.gY(r2);
        let a2 = e3.map(h);
        return new i.gY({ ...t3, tool_calls: a2 });
      }
      if ("system" === t2)
        return new c.jN(r2);
      if ("tool" === t2 && "tool_call_id" in r2)
        return new d.Cq({ ...r2, content: r2.content, tool_call_id: r2.tool_call_id, name: r2.name });
      throw (0, a.r)(Error(`Unable to coerce message from array: only human, AI, system, or tool message coercion is currently supported.

Received: ${JSON.stringify(e2, null, 2)}`), "MESSAGE_COERCION_FAILURE");
    }
    function f(e2) {
      if ("string" == typeof e2)
        return new u.xk(e2);
      if ((0, s.QW)(e2))
        return e2;
      if (Array.isArray(e2)) {
        let [t2, r2] = e2;
        return p({ type: t2, content: r2 });
      }
      if (!(0, s.gQ)(e2))
        return p(e2);
      {
        let { role: t2, ...r2 } = e2;
        return p({ ...r2, type: t2 });
      }
    }
    function m(e2, t2 = "Human", r2 = "AI") {
      let a2 = [];
      for (let n2 of e2) {
        let e3;
        if ("human" === n2._getType())
          e3 = t2;
        else if ("ai" === n2._getType())
          e3 = r2;
        else if ("system" === n2._getType())
          e3 = "System";
        else if ("function" === n2._getType())
          e3 = "Function";
        else if ("tool" === n2._getType())
          e3 = "Tool";
        else if ("generic" === n2._getType())
          e3 = n2.role;
        else
          throw Error(`Got unsupported message type: ${n2._getType()}`);
        let i2 = n2.name ? `${n2.name}, ` : "", s2 = "string" == typeof n2.content ? n2.content : JSON.stringify(n2.content, null, 2);
        a2.push(`${e3}: ${i2}${s2}`);
      }
      return a2.join("\n");
    }
    function g(e2) {
      let t2 = void 0 !== e2.data ? e2 : { type: e2.type, data: { content: e2.text, role: e2.role, name: void 0, tool_call_id: void 0 } };
      switch (t2.type) {
        case "human":
          return new u.xk(t2.data);
        case "ai":
          return new i.gY(t2.data);
        case "system":
          return new c.jN(t2.data);
        case "function":
          if (void 0 === t2.data.name)
            throw Error("Name must be defined for function messages");
          return new l.TN(t2.data);
        case "tool":
          if (void 0 === t2.data.tool_call_id)
            throw Error("Tool call ID must be defined for tool messages");
          return new d.Cq(t2.data);
        case "generic":
          if (void 0 === t2.data.role)
            throw Error("Role must be defined for chat messages");
          return new o.J(t2.data);
        default:
          throw Error(`Got unexpected type: ${t2.type}`);
      }
    }
    function y(e2) {
      return e2.map(g);
    }
    function b(e2) {
      return e2.map((e3) => e3.toDict());
    }
    function v(e2) {
      let t2 = e2._getType();
      if ("human" === t2)
        return new u.ro({ ...e2 });
      if ("ai" === t2) {
        let t3 = { ...e2 };
        return "tool_calls" in t3 && (t3 = { ...t3, tool_call_chunks: t3.tool_calls?.map((e3) => ({ ...e3, type: "tool_call_chunk", index: void 0, args: JSON.stringify(e3.args) })) }), new i.GC({ ...t3 });
      }
      if ("system" === t2)
        return new c.xq({ ...e2 });
      if ("function" === t2)
        return new l.Cr({ ...e2 });
      if (o.J.isInstance(e2))
        return new o.HD({ ...e2 });
      throw Error("Unknown message type.");
    }
  };
  __namedExportsObject["__chunk_4806"] = (e, t, r) => {
    "use strict";
    r.d(t, { BM: () => l, Cq: () => n, Rf: () => o, Xz: () => i, jC: () => s });
    var a = r(4886);
    class n extends a.ku {
      static lc_name() {
        return "ToolMessage";
      }
      get lc_aliases() {
        return { tool_call_id: "tool_call_id" };
      }
      constructor(e2, t2, r2) {
        "string" == typeof e2 && (e2 = { content: e2, name: r2, tool_call_id: t2 }), super(e2), Object.defineProperty(this, "status", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tool_call_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "artifact", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.tool_call_id = e2.tool_call_id, this.artifact = e2.artifact, this.status = e2.status;
      }
      _getType() {
        return "tool";
      }
      static isInstance(e2) {
        return "tool" === e2._getType();
      }
      get _printableFields() {
        return { ...super._printableFields, tool_call_id: this.tool_call_id, artifact: this.artifact };
      }
    }
    class i extends a.$k {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "tool_call_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "status", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "artifact", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.tool_call_id = e2.tool_call_id, this.artifact = e2.artifact, this.status = e2.status;
      }
      static lc_name() {
        return "ToolMessageChunk";
      }
      _getType() {
        return "tool";
      }
      concat(e2) {
        return new i({ content: (0, a.Wf)(this.content, e2.content), additional_kwargs: (0, a.wv)(this.additional_kwargs, e2.additional_kwargs), response_metadata: (0, a.wv)(this.response_metadata, e2.response_metadata), artifact: (0, a.x)(this.artifact, e2.artifact), tool_call_id: this.tool_call_id, id: this.id ?? e2.id, status: (0, a.n4)(this.status, e2.status) });
      }
      get _printableFields() {
        return { ...super._printableFields, tool_call_id: this.tool_call_id, artifact: this.artifact };
      }
    }
    function s(e2) {
      let t2 = [], r2 = [];
      for (let a2 of e2)
        if (a2.function) {
          let e3 = a2.function.name;
          try {
            let r3 = JSON.parse(a2.function.arguments), n2 = { name: e3 || "", args: r3 || {}, id: a2.id };
            t2.push(n2);
          } catch (t3) {
            r2.push({ name: e3, args: a2.function.arguments, id: a2.id, error: "Malformed args." });
          }
        }
      return [t2, r2];
    }
    function o(e2) {
      return "tool" === e2._getType();
    }
    function l(e2) {
      return "tool" === e2._getType();
    }
  };
  __namedExportsObject["__chunk_8878"] = (e, t, r) => {
    "use strict";
    r.d(t, { Ew: () => s, fe: () => o, jN: () => n, xq: () => i });
    var a = r(4886);
    class n extends a.ku {
      static lc_name() {
        return "SystemMessage";
      }
      _getType() {
        return "system";
      }
    }
    class i extends a.$k {
      static lc_name() {
        return "SystemMessageChunk";
      }
      _getType() {
        return "system";
      }
      concat(e2) {
        return new i({ content: (0, a.Wf)(this.content, e2.content), additional_kwargs: (0, a.wv)(this.additional_kwargs, e2.additional_kwargs), response_metadata: (0, a.wv)(this.response_metadata, e2.response_metadata), id: this.id ?? e2.id });
      }
    }
    function s(e2) {
      return "system" === e2._getType();
    }
    function o(e2) {
      return "system" === e2._getType();
    }
  };
  __namedExportsObject["__chunk_9730"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { AIMessage: () => a.gY, AIMessageChunk: () => a.GC, BaseMessage: () => n.ku, BaseMessageChunk: () => n.$k, ChatMessage: () => i.J, ChatMessageChunk: () => i.HD, FunctionMessage: () => s.TN, FunctionMessageChunk: () => s.Cr, HumanMessage: () => o.xk, HumanMessageChunk: () => o.ro, RemoveMessage: () => d, SystemMessage: () => l.jN, SystemMessageChunk: () => l.xq, ToolMessage: () => h.Cq, ToolMessageChunk: () => h.Xz, _isMessageFieldWithRole: () => n.gQ, _mergeDicts: () => n.wv, _mergeLists: () => n.eL, _mergeObj: () => n.x, _mergeStatus: () => n.n4, coerceMessageLikeToMessage: () => u.E1, convertToChunk: () => u.Oy, defaultTextSplitter: () => O, filterMessages: () => f, getBufferString: () => u.zs, isAIMessage: () => a.Z0, isAIMessageChunk: () => a.wT, isBaseMessage: () => n.QW, isBaseMessageChunk: () => n.a2, isChatMessage: () => i.XC, isChatMessageChunk: () => i.r6, isFunctionMessage: () => s.ng, isFunctionMessageChunk: () => s._Y, isHumanMessage: () => o.Q1, isHumanMessageChunk: () => o.cP, isOpenAIToolCallArray: () => n.AJ, isSystemMessage: () => l.Ew, isSystemMessageChunk: () => l.fe, isToolMessage: () => h.Rf, isToolMessageChunk: () => h.BM, mapChatMessagesToStoredMessages: () => u.xb, mapStoredMessageToChatMessage: () => u.rk, mapStoredMessagesToChatMessages: () => u.DC, mergeContent: () => n.Wf, mergeMessageRuns: () => g, trimMessages: () => b });
    var a = r(1582), n = r(4886), i = r(8398), s = r(9203), o = r(9074), l = r(8878), u = r(6131), c = r(1184);
    class d extends n.ku {
      constructor(e2) {
        super({ ...e2, content: "" }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.id = e2.id;
      }
      _getType() {
        return "remove";
      }
      get _printableFields() {
        return { ...super._printableFields, id: this.id };
      }
    }
    var h = r(4806);
    let p = (e2, t2) => {
      let r2 = [...new Set(t2?.map((e3) => {
        if ("string" == typeof e3)
          return e3;
        let t3 = new e3({});
        if (!("_getType" in t3) || "function" != typeof t3._getType)
          throw Error("Invalid type provided.");
        return t3._getType();
      }))], a2 = e2._getType();
      return r2.some((e3) => e3 === a2);
    };
    function f(e2, t2) {
      return Array.isArray(e2) ? m(e2, t2) : c.Y8.from((t3) => m(t3, e2));
    }
    function m(e2, t2 = {}) {
      let { includeNames: r2, excludeNames: a2, includeTypes: n2, excludeTypes: i2, includeIds: s2, excludeIds: o2 } = t2, l2 = [];
      for (let t3 of e2)
        if (!(a2 && t3.name && a2.includes(t3.name))) {
          if (i2 && p(t3, i2) || o2 && t3.id && o2.includes(t3.id))
            continue;
          n2 || s2 || r2 ? r2 && t3.name && r2.some((e3) => e3 === t3.name) ? l2.push(t3) : n2 && p(t3, n2) ? l2.push(t3) : s2 && t3.id && s2.some((e3) => e3 === t3.id) && l2.push(t3) : l2.push(t3);
        }
      return l2;
    }
    function g(e2) {
      return Array.isArray(e2) ? y(e2) : c.Y8.from(y);
    }
    function y(e2) {
      if (!e2.length)
        return [];
      let t2 = [];
      for (let r2 of e2) {
        let e3 = t2.pop();
        if (e3) {
          if ("tool" === r2._getType() || r2._getType() !== e3._getType())
            t2.push(e3, r2);
          else {
            let a2 = (0, u.Oy)(e3), n2 = (0, u.Oy)(r2), i2 = a2.concat(n2);
            "string" == typeof a2.content && "string" == typeof n2.content && (i2.content = `${a2.content}
${n2.content}`), t2.push(function(e4) {
              let t3;
              let r3 = e4._getType(), a3 = Object.fromEntries(Object.entries(e4).filter(([e5]) => !["type", "tool_call_chunks"].includes(e5) && !e5.startsWith("lc_")));
              if (r3 in E && (t3 = x(r3, a3)), !t3)
                throw Error(`Unrecognized message chunk class ${r3}. Supported classes are ${Object.keys(E)}`);
              return t3;
            }(i2));
          }
        } else
          t2.push(r2);
      }
      return t2;
    }
    function b(e2, t2) {
      if (!Array.isArray(e2))
        return c.Y8.from((t3) => v(t3, e2));
      if (!t2)
        throw Error("Options parameter is required when providing messages.");
      return v(e2, t2);
    }
    async function v(e2, t2) {
      let r2;
      let { maxTokens: a2, tokenCounter: n2, strategy: i2 = "last", allowPartial: s2 = false, endOn: o2, startOn: l2, includeSystem: u2 = false, textSplitter: c2 } = t2;
      if (l2 && "first" === i2)
        throw Error("`startOn` should only be specified if `strategy` is 'last'.");
      if (u2 && "first" === i2)
        throw Error("`includeSystem` should only be specified if `strategy` is 'last'.");
      r2 = "getNumTokens" in n2 ? async (e3) => (await Promise.all(e3.map((e4) => n2.getNumTokens(e4.content)))).reduce((e4, t3) => e4 + t3, 0) : async (e3) => n2(e3);
      let d2 = O;
      if (c2 && (d2 = "splitText" in c2 ? c2.splitText : async (e3) => c2(e3)), "first" === i2)
        return _(e2, { maxTokens: a2, tokenCounter: r2, textSplitter: d2, partialStrategy: s2 ? "first" : void 0, endOn: o2 });
      if ("last" === i2)
        return w(e2, { maxTokens: a2, tokenCounter: r2, textSplitter: d2, allowPartial: s2, includeSystem: u2, startOn: l2, endOn: o2 });
      throw Error(`Unrecognized strategy: '${i2}'. Must be one of 'first' or 'last'.`);
    }
    async function _(e2, t2) {
      let { maxTokens: r2, tokenCounter: a2, textSplitter: n2, partialStrategy: i2, endOn: s2 } = t2, o2 = [...e2], l2 = 0;
      for (let e3 = 0; e3 < o2.length; e3 += 1) {
        let t3 = e3 > 0 ? o2.slice(0, -e3) : o2;
        if (await a2(t3) <= r2) {
          l2 = o2.length - e3;
          break;
        }
      }
      if (l2 < o2.length - 1 && i2) {
        let e3 = false;
        if (Array.isArray(o2[l2].content)) {
          let t3 = o2[l2];
          if ("string" == typeof t3.content)
            throw Error("Expected content to be an array.");
          let n3 = t3.content.length, s3 = "last" === i2 ? [...t3.content].reverse() : t3.content;
          for (let u2 = 1; u2 <= n3; u2 += 1) {
            let n4 = "first" === i2 ? s3.slice(0, u2) : s3.slice(-u2), c2 = Object.fromEntries(Object.entries(t3).filter(([e4]) => "type" !== e4 && !e4.startsWith("lc_"))), d2 = x(t3._getType(), { ...c2, content: n4 }), h2 = [...o2.slice(0, l2), d2];
            if (await a2(h2) <= r2)
              o2 = h2, l2 += 1, e3 = true;
            else
              break;
          }
          e3 && "last" === i2 && (t3.content = [...s3].reverse());
        }
        if (!e3) {
          let e4;
          let t3 = o2[l2];
          if (Array.isArray(t3.content) && t3.content.some((e5) => "string" == typeof e5 || "text" === e5.type)) {
            let r3 = t3.content.find((e5) => "text" === e5.type && e5.text);
            e4 = r3?.text;
          } else
            "string" == typeof t3.content && (e4 = t3.content);
          if (e4) {
            let s3 = await n2(e4), u2 = s3.length;
            "last" === i2 && s3.reverse();
            for (let e5 = 0; e5 < u2 - 1; e5 += 1)
              if (s3.pop(), t3.content = s3.join(""), await a2([...o2.slice(0, l2), t3]) <= r2) {
                "last" === i2 && (t3.content = [...s3].reverse().join("")), o2 = [...o2.slice(0, l2), t3], l2 += 1;
                break;
              }
          }
        }
      }
      if (s2) {
        let e3 = Array.isArray(s2) ? s2 : [s2];
        for (; l2 > 0 && !p(o2[l2 - 1], e3); )
          l2 -= 1;
      }
      return o2.slice(0, l2);
    }
    async function w(e2, t2) {
      let { allowPartial: r2 = false, includeSystem: a2 = false, endOn: n2, startOn: i2, ...s2 } = t2;
      if (n2) {
        let t3 = Array.isArray(n2) ? n2 : [n2];
        for (; e2 && !p(e2[e2.length - 1], t3); )
          e2.pop();
      }
      let o2 = a2 && "system" === e2[0]._getType(), l2 = o2 ? e2.slice(0, 1).concat(e2.slice(1).reverse()) : e2.reverse();
      return (l2 = await _(l2, { ...s2, partialStrategy: r2 ? "last" : void 0, endOn: i2 }), o2) ? [l2[0], ...l2.slice(1).reverse()] : l2.reverse();
    }
    let E = { human: { message: o.xk, messageChunk: o.ro }, ai: { message: a.gY, messageChunk: a.GC }, system: { message: l.jN, messageChunk: l.xq }, tool: { message: h.Cq, messageChunk: h.Xz }, function: { message: s.TN, messageChunk: s.Cr }, generic: { message: i.J, messageChunk: i.HD }, remove: { message: d, messageChunk: d } };
    function x(e2, t2, r2) {
      let n2, u2;
      switch (e2) {
        case "human":
          r2 ? n2 = new o.ro(t2) : u2 = new o.xk(t2);
          break;
        case "ai":
          if (r2) {
            let e3 = { ...t2 };
            "tool_calls" in e3 && (e3 = { ...e3, tool_call_chunks: e3.tool_calls?.map((e4) => ({ ...e4, type: "tool_call_chunk", index: void 0, args: JSON.stringify(e4.args) })) }), n2 = new a.GC(e3);
          } else
            u2 = new a.gY(t2);
          break;
        case "system":
          r2 ? n2 = new l.xq(t2) : u2 = new l.jN(t2);
          break;
        case "tool":
          if ("tool_call_id" in t2)
            r2 ? n2 = new h.Xz(t2) : u2 = new h.Cq(t2);
          else
            throw Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
          break;
        case "function":
          if (r2)
            n2 = new s.Cr(t2);
          else {
            if (!t2.name)
              throw Error("FunctionMessage must have a 'name' field");
            u2 = new s.TN(t2);
          }
          break;
        case "generic":
          if ("role" in t2)
            r2 ? n2 = new i.HD(t2) : u2 = new i.J(t2);
          else
            throw Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
          break;
        default:
          throw Error(`Unrecognized message type ${e2}`);
      }
      if (r2 && n2)
        return n2;
      if (u2)
        return u2;
      throw Error(`Unrecognized message type ${e2}`);
    }
    function O(e2) {
      let t2 = e2.split("\n");
      return Promise.resolve([...t2.slice(0, -1).map((e3) => `${e3}
`), t2[t2.length - 1]]);
    }
  };
  __namedExportsObject["__chunk_9074"] = (e, t, r) => {
    "use strict";
    r.d(t, { Q1: () => s, cP: () => o, ro: () => i, xk: () => n });
    var a = r(4886);
    class n extends a.ku {
      static lc_name() {
        return "HumanMessage";
      }
      _getType() {
        return "human";
      }
    }
    class i extends a.$k {
      static lc_name() {
        return "HumanMessageChunk";
      }
      _getType() {
        return "human";
      }
      concat(e2) {
        return new i({ content: (0, a.Wf)(this.content, e2.content), additional_kwargs: (0, a.wv)(this.additional_kwargs, e2.additional_kwargs), response_metadata: (0, a.wv)(this.response_metadata, e2.response_metadata), id: this.id ?? e2.id });
      }
    }
    function s(e2) {
      return "human" === e2.getType();
    }
    function o(e2) {
      return "human" === e2.getType();
    }
  };
  __namedExportsObject["__chunk_9203"] = (e, t, r) => {
    "use strict";
    r.d(t, { Cr: () => i, TN: () => n, _Y: () => o, ng: () => s });
    var a = r(4886);
    class n extends a.ku {
      static lc_name() {
        return "FunctionMessage";
      }
      constructor(e2, t2) {
        "string" == typeof e2 && (e2 = { content: e2, name: t2 }), super(e2);
      }
      _getType() {
        return "function";
      }
    }
    class i extends a.$k {
      static lc_name() {
        return "FunctionMessageChunk";
      }
      _getType() {
        return "function";
      }
      concat(e2) {
        return new i({ content: (0, a.Wf)(this.content, e2.content), additional_kwargs: (0, a.wv)(this.additional_kwargs, e2.additional_kwargs), response_metadata: (0, a.wv)(this.response_metadata, e2.response_metadata), name: this.name ?? "", id: this.id ?? e2.id });
      }
    }
    function s(e2) {
      return "function" === e2._getType();
    }
    function o(e2) {
      return "function" === e2._getType();
    }
  };
  __namedExportsObject["__chunk_8398"] = (e, t, r) => {
    "use strict";
    r.d(t, { HD: () => i, J: () => n, XC: () => s, r6: () => o });
    var a = r(4886);
    class n extends a.ku {
      static lc_name() {
        return "ChatMessage";
      }
      static _chatMessageClass() {
        return n;
      }
      constructor(e2, t2) {
        "string" == typeof e2 && (e2 = { content: e2, role: t2 }), super(e2), Object.defineProperty(this, "role", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.role = e2.role;
      }
      _getType() {
        return "generic";
      }
      static isInstance(e2) {
        return "generic" === e2._getType();
      }
      get _printableFields() {
        return { ...super._printableFields, role: this.role };
      }
    }
    class i extends a.$k {
      static lc_name() {
        return "ChatMessageChunk";
      }
      constructor(e2, t2) {
        "string" == typeof e2 && (e2 = { content: e2, role: t2 }), super(e2), Object.defineProperty(this, "role", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.role = e2.role;
      }
      _getType() {
        return "generic";
      }
      concat(e2) {
        return new i({ content: (0, a.Wf)(this.content, e2.content), additional_kwargs: (0, a.wv)(this.additional_kwargs, e2.additional_kwargs), response_metadata: (0, a.wv)(this.response_metadata, e2.response_metadata), role: this.role, id: this.id ?? e2.id });
      }
      get _printableFields() {
        return { ...super._printableFields, role: this.role };
      }
    }
    function s(e2) {
      return "generic" === e2._getType();
    }
    function o(e2) {
      return "generic" === e2._getType();
    }
  };
  __namedExportsObject["__chunk_4886"] = (e, t, r) => {
    "use strict";
    r.d(t, { $k: () => d, AJ: () => o, QW: () => p, Wf: () => n, a2: () => f, eL: () => u, gQ: () => h, ku: () => s, n4: () => i, wv: () => l, x: () => c });
    var a = r(3686);
    function n(e2, t2) {
      return "string" == typeof e2 ? "string" == typeof t2 ? e2 + t2 : [{ type: "text", text: e2 }, ...t2] : Array.isArray(t2) ? u(e2, t2) ?? [...e2, ...t2] : [...e2, { type: "text", text: t2 }];
    }
    function i(e2, t2) {
      return "error" === e2 || "error" === t2 ? "error" : "success";
    }
    class s extends a.Serializable {
      get lc_aliases() {
        return { additional_kwargs: "additional_kwargs", response_metadata: "response_metadata" };
      }
      get text() {
        return "string" == typeof this.content ? this.content : "";
      }
      getType() {
        return this._getType();
      }
      constructor(e2, t2) {
        "string" == typeof e2 && (e2 = { content: e2, additional_kwargs: t2, response_metadata: {} }), e2.additional_kwargs || (e2.additional_kwargs = {}), e2.response_metadata || (e2.response_metadata = {}), super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain_core", "messages"] }), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "content", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "additional_kwargs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "response_metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.name = e2.name, this.content = e2.content, this.additional_kwargs = e2.additional_kwargs, this.response_metadata = e2.response_metadata, this.id = e2.id;
      }
      toDict() {
        return { type: this._getType(), data: this.toJSON().kwargs };
      }
      static lc_name() {
        return "BaseMessage";
      }
      get _printableFields() {
        return { id: this.id, content: this.content, name: this.name, additional_kwargs: this.additional_kwargs, response_metadata: this.response_metadata };
      }
      _updateId(e2) {
        this.id = e2, this.lc_kwargs.id = e2;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.lc_name();
      }
      [Symbol.for("nodejs.util.inspect.custom")](e2) {
        var t2, r2;
        if (null === e2)
          return this;
        let a2 = (t2 = this._printableFields, r2 = Math.max(4, e2), JSON.stringify(function e3(t3, a3) {
          if ("object" != typeof t3 || null == t3)
            return t3;
          if (a3 >= r2)
            return Array.isArray(t3) ? "[Array]" : "[Object]";
          if (Array.isArray(t3))
            return t3.map((t4) => e3(t4, a3 + 1));
          let n2 = {};
          for (let r3 of Object.keys(t3))
            n2[r3] = e3(t3[r3], a3 + 1);
          return n2;
        }(t2, 0), null, 2));
        return `${this.constructor.lc_name()} ${a2}`;
      }
    }
    function o(e2) {
      return Array.isArray(e2) && e2.every((e3) => "number" == typeof e3.index);
    }
    function l(e2, t2) {
      let r2 = { ...e2 };
      for (let [e3, a2] of Object.entries(t2))
        if (null == r2[e3])
          r2[e3] = a2;
        else if (null == a2)
          continue;
        else if (typeof r2[e3] != typeof a2 || Array.isArray(r2[e3]) !== Array.isArray(a2))
          throw Error(`field[${e3}] already exists in the message chunk, but with a different type.`);
        else if ("string" == typeof r2[e3]) {
          if ("type" === e3)
            continue;
          r2[e3] += a2;
        } else if ("object" != typeof r2[e3] || Array.isArray(r2[e3])) {
          if (Array.isArray(r2[e3]))
            r2[e3] = u(r2[e3], a2);
          else {
            if (r2[e3] === a2)
              continue;
            console.warn(`field[${e3}] already exists in this message chunk and value has unsupported type.`);
          }
        } else
          r2[e3] = l(r2[e3], a2);
      return r2;
    }
    function u(e2, t2) {
      if (void 0 !== e2 || void 0 !== t2) {
        if (void 0 === e2 || void 0 === t2)
          return e2 || t2;
        {
          let r2 = [...e2];
          for (let e3 of t2)
            if ("object" == typeof e3 && "index" in e3 && "number" == typeof e3.index) {
              let t3 = r2.findIndex((t4) => t4.index === e3.index);
              -1 !== t3 ? r2[t3] = l(r2[t3], e3) : r2.push(e3);
            } else {
              if ("object" == typeof e3 && "text" in e3 && "" === e3.text)
                continue;
              r2.push(e3);
            }
          return r2;
        }
      }
    }
    function c(e2, t2) {
      if (!e2 && !t2)
        throw Error("Cannot merge two undefined objects.");
      if (!e2 || !t2)
        return e2 || t2;
      if (typeof e2 != typeof t2)
        throw Error(`Cannot merge objects of different types.
Left ${typeof e2}
Right ${typeof t2}`);
      if ("string" == typeof e2 && "string" == typeof t2)
        return e2 + t2;
      if (Array.isArray(e2) && Array.isArray(t2))
        return u(e2, t2);
      if ("object" == typeof e2 && "object" == typeof t2)
        return l(e2, t2);
      if (e2 === t2)
        return e2;
      throw Error(`Can not merge objects of different types.
Left ${e2}
Right ${t2}`);
    }
    class d extends s {
    }
    function h(e2) {
      return "string" == typeof e2.role;
    }
    function p(e2) {
      return "function" == typeof e2?._getType;
    }
    function f(e2) {
      return p(e2) && "function" == typeof e2.concat;
    }
  };
  __namedExportsObject["__chunk_1582"] = (e, t, r) => {
    "use strict";
    r.d(t, { GC: () => u, Z0: () => o, gY: () => s, wT: () => l });
    var a = r(5466), n = r(4886), i = r(4806);
    class s extends n.ku {
      get lc_aliases() {
        return { ...super.lc_aliases, tool_calls: "tool_calls", invalid_tool_calls: "invalid_tool_calls" };
      }
      constructor(e2, t2) {
        let r2;
        if ("string" == typeof e2)
          r2 = { content: e2, tool_calls: [], invalid_tool_calls: [], additional_kwargs: t2 ?? {} };
        else {
          r2 = e2;
          let t3 = r2.additional_kwargs?.tool_calls, a2 = r2.tool_calls;
          null != t3 && t3.length > 0 && (void 0 === a2 || 0 === a2.length) && console.warn("New LangChain packages are available that more efficiently handle tool calling.\n\nPlease upgrade your packages to versions that set message tool calls. e.g., `yarn add @langchain/anthropic`, yarn add @langchain/openai`, etc.");
          try {
            if (null != t3 && void 0 === a2) {
              let [e3, a3] = (0, i.jC)(t3);
              r2.tool_calls = e3 ?? [], r2.invalid_tool_calls = a3 ?? [];
            } else
              r2.tool_calls = r2.tool_calls ?? [], r2.invalid_tool_calls = r2.invalid_tool_calls ?? [];
          } catch (e3) {
            r2.tool_calls = [], r2.invalid_tool_calls = [];
          }
        }
        super(r2), Object.defineProperty(this, "tool_calls", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "invalid_tool_calls", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "usage_metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), "string" != typeof r2 && (this.tool_calls = r2.tool_calls ?? this.tool_calls, this.invalid_tool_calls = r2.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = r2.usage_metadata;
      }
      static lc_name() {
        return "AIMessage";
      }
      _getType() {
        return "ai";
      }
      get _printableFields() {
        return { ...super._printableFields, tool_calls: this.tool_calls, invalid_tool_calls: this.invalid_tool_calls, usage_metadata: this.usage_metadata };
      }
    }
    function o(e2) {
      return "ai" === e2._getType();
    }
    function l(e2) {
      return "ai" === e2._getType();
    }
    class u extends n.$k {
      constructor(e2) {
        let t2;
        if ("string" == typeof e2)
          t2 = { content: e2, tool_calls: [], invalid_tool_calls: [], tool_call_chunks: [] };
        else if (void 0 === e2.tool_call_chunks)
          t2 = { ...e2, tool_calls: e2.tool_calls ?? [], invalid_tool_calls: [], tool_call_chunks: [], usage_metadata: void 0 !== e2.usage_metadata ? e2.usage_metadata : void 0 };
        else {
          let r2 = [], n2 = [];
          for (let t3 of e2.tool_call_chunks) {
            let e3 = {};
            try {
              if (e3 = (0, a.g)(t3.args || "{}"), null === e3 || "object" != typeof e3 || Array.isArray(e3))
                throw Error("Malformed tool call chunk args.");
              r2.push({ name: t3.name ?? "", args: e3, id: t3.id, type: "tool_call" });
            } catch (e4) {
              n2.push({ name: t3.name, args: t3.args, id: t3.id, error: "Malformed args.", type: "invalid_tool_call" });
            }
          }
          t2 = { ...e2, tool_calls: r2, invalid_tool_calls: n2, usage_metadata: void 0 !== e2.usage_metadata ? e2.usage_metadata : void 0 };
        }
        super(t2), Object.defineProperty(this, "tool_calls", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "invalid_tool_calls", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "tool_call_chunks", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "usage_metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.tool_call_chunks = t2.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = t2.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t2.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = t2.usage_metadata;
      }
      get lc_aliases() {
        return { ...super.lc_aliases, tool_calls: "tool_calls", invalid_tool_calls: "invalid_tool_calls", tool_call_chunks: "tool_call_chunks" };
      }
      static lc_name() {
        return "AIMessageChunk";
      }
      _getType() {
        return "ai";
      }
      get _printableFields() {
        return { ...super._printableFields, tool_calls: this.tool_calls, tool_call_chunks: this.tool_call_chunks, invalid_tool_calls: this.invalid_tool_calls, usage_metadata: this.usage_metadata };
      }
      concat(e2) {
        let t2 = { content: (0, n.Wf)(this.content, e2.content), additional_kwargs: (0, n.wv)(this.additional_kwargs, e2.additional_kwargs), response_metadata: (0, n.wv)(this.response_metadata, e2.response_metadata), tool_call_chunks: [], id: this.id ?? e2.id };
        if (void 0 !== this.tool_call_chunks || void 0 !== e2.tool_call_chunks) {
          let r2 = (0, n.eL)(this.tool_call_chunks, e2.tool_call_chunks);
          void 0 !== r2 && r2.length > 0 && (t2.tool_call_chunks = r2);
        }
        if (void 0 !== this.usage_metadata || void 0 !== e2.usage_metadata) {
          let r2 = { ...(this.usage_metadata?.input_token_details?.audio !== void 0 || e2.usage_metadata?.input_token_details?.audio !== void 0) && { audio: (this.usage_metadata?.input_token_details?.audio ?? 0) + (e2.usage_metadata?.input_token_details?.audio ?? 0) }, ...(this.usage_metadata?.input_token_details?.cache_read !== void 0 || e2.usage_metadata?.input_token_details?.cache_read !== void 0) && { cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) + (e2.usage_metadata?.input_token_details?.cache_read ?? 0) }, ...(this.usage_metadata?.input_token_details?.cache_creation !== void 0 || e2.usage_metadata?.input_token_details?.cache_creation !== void 0) && { cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) + (e2.usage_metadata?.input_token_details?.cache_creation ?? 0) } }, a2 = { ...(this.usage_metadata?.output_token_details?.audio !== void 0 || e2.usage_metadata?.output_token_details?.audio !== void 0) && { audio: (this.usage_metadata?.output_token_details?.audio ?? 0) + (e2.usage_metadata?.output_token_details?.audio ?? 0) }, ...(this.usage_metadata?.output_token_details?.reasoning !== void 0 || e2.usage_metadata?.output_token_details?.reasoning !== void 0) && { reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) + (e2.usage_metadata?.output_token_details?.reasoning ?? 0) } }, n2 = this.usage_metadata ?? { input_tokens: 0, output_tokens: 0, total_tokens: 0 }, i2 = e2.usage_metadata ?? { input_tokens: 0, output_tokens: 0, total_tokens: 0 }, s2 = { input_tokens: n2.input_tokens + i2.input_tokens, output_tokens: n2.output_tokens + i2.output_tokens, total_tokens: n2.total_tokens + i2.total_tokens, ...Object.keys(r2).length > 0 && { input_token_details: r2 }, ...Object.keys(a2).length > 0 && { output_token_details: a2 } };
          t2.usage_metadata = s2;
        }
        return new u(t2);
      }
    }
  };
  __namedExportsObject["__chunk_3686"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { Serializable: () => s, get_lc_unique_name: () => i });
    var a = r(3345);
    function n(e2) {
      return Array.isArray(e2) ? [...e2] : { ...e2 };
    }
    function i(e2) {
      let t2 = Object.getPrototypeOf(e2);
      return "function" == typeof e2.lc_name && ("function" != typeof t2.lc_name || e2.lc_name() !== t2.lc_name()) ? e2.lc_name() : e2.name;
    }
    class s {
      static lc_name() {
        return this.name;
      }
      get lc_id() {
        return [...this.lc_namespace, i(this.constructor)];
      }
      get lc_secrets() {
      }
      get lc_attributes() {
      }
      get lc_aliases() {
      }
      constructor(e2, ...t2) {
        Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "lc_kwargs", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.lc_kwargs = e2 || {};
      }
      toJSON() {
        if (!this.lc_serializable || this.lc_kwargs instanceof s || "object" != typeof this.lc_kwargs || Array.isArray(this.lc_kwargs))
          return this.toJSONNotImplemented();
        let e2 = {}, t2 = {}, r2 = Object.keys(this.lc_kwargs).reduce((e3, t3) => (e3[t3] = t3 in this ? this[t3] : this.lc_kwargs[t3], e3), {});
        for (let a2 = Object.getPrototypeOf(this); a2; a2 = Object.getPrototypeOf(a2))
          Object.assign(e2, Reflect.get(a2, "lc_aliases", this)), Object.assign(t2, Reflect.get(a2, "lc_secrets", this)), Object.assign(r2, Reflect.get(a2, "lc_attributes", this));
        return Object.keys(t2).forEach((e3) => {
          let t3 = this, a2 = r2, [n2, ...i2] = e3.split(".").reverse();
          for (let e4 of i2.reverse()) {
            if (!(e4 in t3) || void 0 === t3[e4])
              return;
            e4 in a2 && void 0 !== a2[e4] || ("object" == typeof t3[e4] && null != t3[e4] ? a2[e4] = {} : Array.isArray(t3[e4]) && (a2[e4] = [])), t3 = t3[e4], a2 = a2[e4];
          }
          n2 in t3 && void 0 !== t3[n2] && (a2[n2] = a2[n2] || t3[n2]);
        }), { lc: 1, type: "constructor", id: this.lc_id, kwargs: (0, a.Cw)(Object.keys(t2).length ? function(e3, t3) {
          let r3 = n(e3);
          for (let [e4, a2] of Object.entries(t3)) {
            let [t4, ...i2] = e4.split(".").reverse(), s2 = r3;
            for (let e5 of i2.reverse()) {
              if (void 0 === s2[e5])
                break;
              s2[e5] = n(s2[e5]), s2 = s2[e5];
            }
            void 0 !== s2[t4] && (s2[t4] = { lc: 1, type: "secret", id: [a2] });
          }
          return r3;
        }(r2, t2) : r2, a.VR, e2) };
      }
      toJSONNotImplemented() {
        return { lc: 1, type: "not_implemented", id: this.lc_id };
      }
    }
  };
  __namedExportsObject["__chunk_3345"] = (e, t, r) => {
    "use strict";
    r.d(t, { Cw: () => o, QZ: () => s, VR: () => i });
    var a = r(5792), n = r(2513);
    function i(e2, t2) {
      return t2?.[e2] || a(e2);
    }
    function s(e2, t2) {
      return t2?.[e2] || n(e2);
    }
    function o(e2, t2, r2) {
      let a2 = {};
      for (let n2 in e2)
        Object.hasOwn(e2, n2) && (a2[t2(n2, r2)] = e2[n2]);
      return a2;
    }
  };
  __namedExportsObject["__chunk_7418"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseLLM: () => c, LLM: () => d });
    var a = r(9730), n = r(3926), i = r(112), s = r(8718), o = r(1610), l = r(9593), u = r(541);
    class c extends s.BaseLanguageModel {
      constructor({ concurrency: e2, ...t2 }) {
        super(e2 ? { maxConcurrency: e2, ...t2 } : t2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain", "llms", this._llmType()] });
      }
      async invoke(e2, t2) {
        let r2 = c._convertInputToPromptValue(e2);
        return (await this.generatePrompt([r2], t2, t2?.callbacks)).generations[0][0].text;
      }
      async *_streamResponseChunks(e2, t2, r2) {
        throw Error("Not implemented.");
      }
      _separateRunnableConfigFromCallOptionsCompat(e2) {
        let [t2, r2] = super._separateRunnableConfigFromCallOptions(e2);
        return r2.signal = t2.signal, [t2, r2];
      }
      async *_streamIterator(e2, t2) {
        if (this._streamResponseChunks === c.prototype._streamResponseChunks)
          yield this.invoke(e2, t2);
        else {
          let r2 = c._convertInputToPromptValue(e2), [a2, s2] = this._separateRunnableConfigFromCallOptionsCompat(t2), o2 = await i.CallbackManager.configure(a2.callbacks, this.callbacks, a2.tags, this.tags, a2.metadata, this.metadata, { verbose: this.verbose }), l2 = { options: s2, invocation_params: this?.invocationParams(s2), batch_size: 1 }, u2 = await o2?.handleLLMStart(this.toJSON(), [r2.toString()], a2.runId, void 0, l2, void 0, void 0, a2.runName), d2 = new n.GenerationChunk({ text: "" });
          try {
            for await (let e3 of this._streamResponseChunks(r2.toString(), s2, u2?.[0]))
              d2 = d2 ? d2.concat(e3) : e3, "string" == typeof e3.text && (yield e3.text);
          } catch (e3) {
            throw await Promise.all((u2 ?? []).map((t3) => t3?.handleLLMError(e3))), e3;
          }
          await Promise.all((u2 ?? []).map((e3) => e3?.handleLLMEnd({ generations: [[d2]] })));
        }
      }
      async generatePrompt(e2, t2, r2) {
        let a2 = e2.map((e3) => e3.toString());
        return this.generate(a2, t2, r2);
      }
      invocationParams(e2) {
        return {};
      }
      _flattenLLMResult(e2) {
        let t2 = [];
        for (let r2 = 0; r2 < e2.generations.length; r2 += 1) {
          let a2 = e2.generations[r2];
          if (0 === r2)
            t2.push({ generations: [a2], llmOutput: e2.llmOutput });
          else {
            let r3 = e2.llmOutput ? { ...e2.llmOutput, tokenUsage: {} } : void 0;
            t2.push({ generations: [a2], llmOutput: r3 });
          }
        }
        return t2;
      }
      async _generateUncached(e2, t2, r2) {
        let a2;
        let s2 = await i.CallbackManager.configure(r2.callbacks, this.callbacks, r2.tags, this.tags, r2.metadata, this.metadata, { verbose: this.verbose }), d2 = { options: t2, invocation_params: this?.invocationParams(t2), batch_size: e2.length }, h = await s2?.handleLLMStart(this.toJSON(), e2, r2.runId, void 0, d2, void 0, void 0, r2?.runName);
        if (h?.[0].handlers.find((e3) => o.C(e3) || l.isLogStreamHandler(e3)) && 1 === e2.length && this._streamResponseChunks !== c.prototype._streamResponseChunks)
          try {
            let r3;
            for await (let a3 of await this._streamResponseChunks(e2[0], t2, h?.[0]))
              r3 = void 0 === r3 ? a3 : (0, u.concat)(r3, a3);
            if (void 0 === r3)
              throw Error("Received empty response from chat model call.");
            a2 = { generations: [[r3]], llmOutput: {} }, await h?.[0].handleLLMEnd(a2);
          } catch (e3) {
            throw await h?.[0].handleLLMError(e3), e3;
          }
        else {
          try {
            a2 = await this._generate(e2, t2, h?.[0]);
          } catch (e3) {
            throw await Promise.all((h ?? []).map((t3) => t3?.handleLLMError(e3))), e3;
          }
          let r3 = this._flattenLLMResult(a2);
          await Promise.all((h ?? []).map((e3, t3) => e3?.handleLLMEnd(r3[t3])));
        }
        let p = h?.map((e3) => e3.runId) || void 0;
        return Object.defineProperty(a2, n.RUN_KEY, { value: p ? { runIds: p } : void 0, configurable: true }), a2;
      }
      async _generateCached({ prompts: e2, cache: t2, llmStringKey: r2, parsedOptions: a2, handledOptions: s2, runId: o2 }) {
        let l2 = await i.CallbackManager.configure(s2.callbacks, this.callbacks, s2.tags, this.tags, s2.metadata, this.metadata, { verbose: this.verbose }), u2 = { options: a2, invocation_params: this?.invocationParams(a2), batch_size: e2.length, cached: true }, c2 = await l2?.handleLLMStart(this.toJSON(), e2, o2, void 0, u2, void 0, void 0, s2?.runName), d2 = [], h = (await Promise.allSettled(e2.map(async (e3, a3) => {
          let n2 = await t2.lookup(e3, r2);
          return null == n2 && d2.push(a3), n2;
        }))).map((e3, t3) => ({ result: e3, runManager: c2?.[t3] })).filter(({ result: e3 }) => "fulfilled" === e3.status && null != e3.value || "rejected" === e3.status), p = [];
        await Promise.all(h.map(async ({ result: e3, runManager: t3 }, r3) => {
          if ("fulfilled" !== e3.status)
            return await t3?.handleLLMError(e3.reason), Promise.reject(e3.reason);
          {
            let a3 = e3.value;
            return p[r3] = a3, a3.length && await t3?.handleLLMNewToken(a3[0].text), t3?.handleLLMEnd({ generations: [a3] });
          }
        }));
        let f = { generations: p, missingPromptIndices: d2 };
        return Object.defineProperty(f, n.RUN_KEY, { value: c2 ? { runIds: c2?.map((e3) => e3.runId) } : void 0, configurable: true }), f;
      }
      async generate(e2, t2, r2) {
        let a2;
        if (!Array.isArray(e2))
          throw Error("Argument 'prompts' is expected to be a string[]");
        a2 = Array.isArray(t2) ? { stop: t2 } : t2;
        let [n2, i2] = this._separateRunnableConfigFromCallOptionsCompat(a2);
        if (n2.callbacks = n2.callbacks ?? r2, !this.cache)
          return this._generateUncached(e2, i2, n2);
        let { cache: s2 } = this, o2 = this._getSerializedCacheKeyParametersForCall(i2), { generations: l2, missingPromptIndices: u2 } = await this._generateCached({ prompts: e2, cache: s2, llmStringKey: o2, parsedOptions: i2, handledOptions: n2, runId: n2.runId }), c2 = {};
        if (u2.length > 0) {
          let t3 = await this._generateUncached(u2.map((t4) => e2[t4]), i2, n2);
          await Promise.all(t3.generations.map(async (t4, r3) => {
            let a3 = u2[r3];
            return l2[a3] = t4, s2.update(e2[a3], o2, t4);
          })), c2 = t3.llmOutput ?? {};
        }
        return { generations: l2, llmOutput: c2 };
      }
      async call(e2, t2, r2) {
        let { generations: a2 } = await this.generate([e2], t2, r2);
        return a2[0][0].text;
      }
      async predict(e2, t2, r2) {
        return this.call(e2, t2, r2);
      }
      async predictMessages(e2, t2, r2) {
        let n2 = (0, a.getBufferString)(e2), i2 = await this.call(n2, t2, r2);
        return new a.AIMessage(i2);
      }
      _identifyingParams() {
        return {};
      }
      serialize() {
        return { ...this._identifyingParams(), _type: this._llmType(), _model: this._modelType() };
      }
      _modelType() {
        return "base_llm";
      }
    }
    class d extends c {
      async _generate(e2, t2, r2) {
        return { generations: await Promise.all(e2.map((e3, a2) => this._call(e3, { ...t2, promptIndex: a2 }, r2).then((e4) => [{ text: e4 }]))) };
      }
    }
  };
  __namedExportsObject["__chunk_4220"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseChatModel: () => m, SimpleChatModel: () => g, createChatMessageChunkEncoderStream: () => f });
    var a = r(7026), n = r(9730), i = r(3926), s = r(8718), o = r(112), l = r(1184), u = r(1610), c = r(9593), d = r(541), h = r(5314), p = r(1742);
    function f() {
      let e2 = new TextEncoder();
      return new TransformStream({ transform(t2, r2) {
        r2.enqueue(e2.encode("string" == typeof t2.content ? t2.content : JSON.stringify(t2.content)));
      } });
    }
    class m extends s.BaseLanguageModel {
      constructor(e2) {
        super(e2), Object.defineProperty(this, "lc_namespace", { enumerable: true, configurable: true, writable: true, value: ["langchain", "chat_models", this._llmType()] });
      }
      _separateRunnableConfigFromCallOptionsCompat(e2) {
        let [t2, r2] = super._separateRunnableConfigFromCallOptions(e2);
        return r2.signal = t2.signal, [t2, r2];
      }
      async invoke(e2, t2) {
        let r2 = m._convertInputToPromptValue(e2);
        return (await this.generatePrompt([r2], t2, t2?.callbacks)).generations[0][0].message;
      }
      async *_streamResponseChunks(e2, t2, r2) {
        throw Error("Not implemented.");
      }
      async *_streamIterator(e2, t2) {
        if (this._streamResponseChunks === m.prototype._streamResponseChunks)
          yield this.invoke(e2, t2);
        else {
          let r2, a2;
          let i2 = m._convertInputToPromptValue(e2).toChatMessages(), [s2, l2] = this._separateRunnableConfigFromCallOptionsCompat(t2), u2 = { ...s2.metadata, ...this.getLsParams(l2) }, c2 = await o.CallbackManager.configure(s2.callbacks, this.callbacks, s2.tags, this.tags, u2, this.metadata, { verbose: this.verbose }), d2 = { options: l2, invocation_params: this?.invocationParams(l2), batch_size: 1 }, h2 = await c2?.handleChatModelStart(this.toJSON(), [i2], s2.runId, void 0, d2, void 0, void 0, s2.runName);
          try {
            for await (let e3 of this._streamResponseChunks(i2, l2, h2?.[0])) {
              if (null == e3.message.id) {
                let t3 = h2?.at(0)?.runId;
                null != t3 && e3.message._updateId(`run-${t3}`);
              }
              e3.message.response_metadata = { ...e3.generationInfo, ...e3.message.response_metadata }, yield e3.message, r2 = r2 ? r2.concat(e3) : e3, (0, n.isAIMessageChunk)(e3.message) && void 0 !== e3.message.usage_metadata && (a2 = { tokenUsage: { promptTokens: e3.message.usage_metadata.input_tokens, completionTokens: e3.message.usage_metadata.output_tokens, totalTokens: e3.message.usage_metadata.total_tokens } });
            }
          } catch (e3) {
            throw await Promise.all((h2 ?? []).map((t3) => t3?.handleLLMError(e3))), e3;
          }
          await Promise.all((h2 ?? []).map((e3) => e3?.handleLLMEnd({ generations: [[r2]], llmOutput: a2 })));
        }
      }
      getLsParams(e2) {
        let t2 = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
        return { ls_model_type: "chat", ls_stop: e2.stop, ls_provider: t2 };
      }
      async _generateUncached(e2, t2, r2) {
        let a2 = e2.map((e3) => e3.map(n.coerceMessageLikeToMessage)), s2 = { ...r2.metadata, ...this.getLsParams(t2) }, l2 = await o.CallbackManager.configure(r2.callbacks, this.callbacks, r2.tags, this.tags, s2, this.metadata, { verbose: this.verbose }), h2 = { options: t2, invocation_params: this?.invocationParams(t2), batch_size: 1 }, p2 = await l2?.handleChatModelStart(this.toJSON(), a2, r2.runId, void 0, h2, void 0, void 0, r2.runName), f2 = [], g2 = [];
        if (p2?.[0].handlers.find((e3) => u.C(e3) || c.isLogStreamHandler(e3)) && 1 === a2.length && this._streamResponseChunks !== m.prototype._streamResponseChunks)
          try {
            let e3, r3;
            for await (let i2 of await this._streamResponseChunks(a2[0], t2, p2?.[0])) {
              if (null == i2.message.id) {
                let e4 = p2?.at(0)?.runId;
                null != e4 && i2.message._updateId(`run-${e4}`);
              }
              e3 = void 0 === e3 ? i2 : (0, d.concat)(e3, i2), (0, n.isAIMessageChunk)(i2.message) && void 0 !== i2.message.usage_metadata && (r3 = { tokenUsage: { promptTokens: i2.message.usage_metadata.input_tokens, completionTokens: i2.message.usage_metadata.output_tokens, totalTokens: i2.message.usage_metadata.total_tokens } });
            }
            if (void 0 === e3)
              throw Error("Received empty response from chat model call.");
            f2.push([e3]), await p2?.[0].handleLLMEnd({ generations: f2, llmOutput: r3 });
          } catch (e3) {
            throw await p2?.[0].handleLLMError(e3), e3;
          }
        else {
          let e3 = await Promise.allSettled(a2.map((e4, r3) => this._generate(e4, { ...t2, promptIndex: r3 }, p2?.[r3])));
          await Promise.all(e3.map(async (e4, t3) => {
            if ("fulfilled" !== e4.status)
              return await p2?.[t3]?.handleLLMError(e4.reason), Promise.reject(e4.reason);
            {
              let r3 = e4.value;
              for (let e5 of r3.generations) {
                if (null == e5.message.id) {
                  let t4 = p2?.at(0)?.runId;
                  null != t4 && e5.message._updateId(`run-${t4}`);
                }
                e5.message.response_metadata = { ...e5.generationInfo, ...e5.message.response_metadata };
              }
              return 1 === r3.generations.length && (r3.generations[0].message.response_metadata = { ...r3.llmOutput, ...r3.generations[0].message.response_metadata }), f2[t3] = r3.generations, g2[t3] = r3.llmOutput, p2?.[t3]?.handleLLMEnd({ generations: [r3.generations], llmOutput: r3.llmOutput });
            }
          }));
        }
        let y = { generations: f2, llmOutput: g2.length ? this._combineLLMOutput?.(...g2) : void 0 };
        return Object.defineProperty(y, i.RUN_KEY, { value: p2 ? { runIds: p2?.map((e3) => e3.runId) } : void 0, configurable: true }), y;
      }
      async _generateCached({ messages: e2, cache: t2, llmStringKey: r2, parsedOptions: a2, handledOptions: s2 }) {
        let l2 = e2.map((e3) => e3.map(n.coerceMessageLikeToMessage)), u2 = { ...s2.metadata, ...this.getLsParams(a2) }, c2 = await o.CallbackManager.configure(s2.callbacks, this.callbacks, s2.tags, this.tags, u2, this.metadata, { verbose: this.verbose }), d2 = { options: a2, invocation_params: this?.invocationParams(a2), batch_size: 1, cached: true }, h2 = await c2?.handleChatModelStart(this.toJSON(), l2, s2.runId, void 0, d2, void 0, void 0, s2.runName), p2 = [], f2 = (await Promise.allSettled(l2.map(async (e3, a3) => {
          let n2 = m._convertInputToPromptValue(e3).toString(), i2 = await t2.lookup(n2, r2);
          return null == i2 && p2.push(a3), i2;
        }))).map((e3, t3) => ({ result: e3, runManager: h2?.[t3] })).filter(({ result: e3 }) => "fulfilled" === e3.status && null != e3.value || "rejected" === e3.status), g2 = [];
        await Promise.all(f2.map(async ({ result: e3, runManager: t3 }, r3) => {
          if ("fulfilled" !== e3.status)
            return await t3?.handleLLMError(e3.reason), Promise.reject(e3.reason);
          {
            let a3 = e3.value;
            return g2[r3] = a3, a3.length && await t3?.handleLLMNewToken(a3[0].text), t3?.handleLLMEnd({ generations: [a3] });
          }
        }));
        let y = { generations: g2, missingPromptIndices: p2 };
        return Object.defineProperty(y, i.RUN_KEY, { value: h2 ? { runIds: h2?.map((e3) => e3.runId) } : void 0, configurable: true }), y;
      }
      async generate(e2, t2, r2) {
        let a2;
        a2 = Array.isArray(t2) ? { stop: t2 } : t2;
        let i2 = e2.map((e3) => e3.map(n.coerceMessageLikeToMessage)), [s2, o2] = this._separateRunnableConfigFromCallOptionsCompat(a2);
        if (s2.callbacks = s2.callbacks ?? r2, !this.cache)
          return this._generateUncached(i2, o2, s2);
        let { cache: l2 } = this, u2 = this._getSerializedCacheKeyParametersForCall(o2), { generations: c2, missingPromptIndices: d2 } = await this._generateCached({ messages: i2, cache: l2, llmStringKey: u2, parsedOptions: o2, handledOptions: s2 }), h2 = {};
        if (d2.length > 0) {
          let e3 = await this._generateUncached(d2.map((e4) => i2[e4]), o2, s2);
          await Promise.all(e3.generations.map(async (e4, t3) => {
            let r3 = d2[t3];
            c2[r3] = e4;
            let a3 = m._convertInputToPromptValue(i2[r3]).toString();
            return l2.update(a3, u2, e4);
          })), h2 = e3.llmOutput ?? {};
        }
        return { generations: c2, llmOutput: h2 };
      }
      invocationParams(e2) {
        return {};
      }
      _modelType() {
        return "base_chat_model";
      }
      serialize() {
        return { ...this.invocationParams(), _type: this._llmType(), _model: this._modelType() };
      }
      async generatePrompt(e2, t2, r2) {
        let a2 = e2.map((e3) => e3.toChatMessages());
        return this.generate(a2, t2, r2);
      }
      async call(e2, t2, r2) {
        return (await this.generate([e2.map(n.coerceMessageLikeToMessage)], t2, r2)).generations[0][0].message;
      }
      async callPrompt(e2, t2, r2) {
        let a2 = e2.toChatMessages();
        return this.call(a2, t2, r2);
      }
      async predictMessages(e2, t2, r2) {
        return this.call(e2, t2, r2);
      }
      async predict(e2, t2, r2) {
        let a2 = new n.HumanMessage(e2), i2 = await this.call([a2], t2, r2);
        if ("string" != typeof i2.content)
          throw Error("Cannot use predict when output is not a string.");
        return i2.content;
      }
      withStructuredOutput(e2, t2) {
        let r2;
        if ("function" != typeof this.bindTools)
          throw Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
        if (t2?.strict)
          throw Error('"strict" mode is not supported for this model by default.');
        let n2 = t2?.name, i2 = e2.description ?? "A function available to call.", s2 = t2?.method, o2 = t2?.includeRaw;
        if ("jsonMode" === s2)
          throw Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
        let u2 = n2 ?? "extract";
        (0, p.F)(e2) ? r2 = [{ type: "function", function: { name: u2, description: i2, parameters: (0, a.Y_)(e2) } }] : ("name" in e2 && (u2 = e2.name), r2 = [{ type: "function", function: { name: u2, description: i2, parameters: e2 } }]);
        let c2 = this.bindTools(r2), d2 = l.Y8.from((e3) => {
          if (!e3.tool_calls || 0 === e3.tool_calls.length)
            throw Error("No tool calls found in the response.");
          let t3 = e3.tool_calls.find((e4) => e4.name === u2);
          if (!t3)
            throw Error(`No tool call found with name ${u2}.`);
          return t3.args;
        });
        if (!o2)
          return c2.pipe(d2).withConfig({ runName: "StructuredOutput" });
        let f2 = h.s.assign({ parsed: (e3, t3) => d2.invoke(e3.raw, t3) }), m2 = h.s.assign({ parsed: () => null }), g2 = f2.withFallbacks({ fallbacks: [m2] });
        return l.lW.from([{ raw: c2 }, g2]).withConfig({ runName: "StructuredOutputRunnable" });
      }
    }
    class g extends m {
      async _generate(e2, t2, r2) {
        let a2 = await this._call(e2, t2, r2), i2 = new n.AIMessage(a2);
        if ("string" != typeof i2.content)
          throw Error("Cannot generate with a simple chat model when output is not a string.");
        return { generations: [{ text: i2.content, message: i2 }] };
      }
    }
  };
  __namedExportsObject["__chunk_8718"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseLangChain: () => m, BaseLanguageModel: () => g, calculateMaxTokens: () => p, getEmbeddingContextSize: () => c, getModelContextSize: () => d, getModelNameForTiktoken: () => u, isOpenAITool: () => h });
    var a = r(7783), n = r(4135), i = r(6131), s = r(1550), o = r(1930), l = r(1184);
    let u = (e2) => e2.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : e2.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : e2.startsWith("gpt-4-32k") ? "gpt-4-32k" : e2.startsWith("gpt-4-") ? "gpt-4" : e2.startsWith("gpt-4o") ? "gpt-4o" : e2, c = (e2) => "text-embedding-ada-002" === e2 ? 8191 : 2046, d = (e2) => {
      switch (u(e2)) {
        case "gpt-3.5-turbo-16k":
          return 16384;
        case "gpt-3.5-turbo":
          return 4096;
        case "gpt-4-32k":
          return 32768;
        case "gpt-4":
          return 8192;
        case "text-davinci-003":
        default:
          return 4097;
        case "text-curie-001":
        case "text-babbage-001":
        case "text-ada-001":
        case "code-cushman-001":
          return 2048;
        case "code-davinci-002":
          return 8e3;
      }
    };
    function h(e2) {
      return "object" == typeof e2 && !!e2 && "type" in e2 && "function" === e2.type && "function" in e2 && "object" == typeof e2.function && !!e2.function && "name" in e2.function && "parameters" in e2.function;
    }
    let p = async ({ prompt: e2, modelName: t2 }) => {
      let r2;
      try {
        r2 = (await (0, o.encodingForModel)(u(t2))).encode(e2).length;
      } catch (t3) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count"), r2 = Math.ceil(e2.length / 4);
      }
      return d(t2) - r2;
    }, f = () => false;
    class m extends l.eq {
      get lc_attributes() {
        return { callbacks: void 0, verbose: void 0 };
      }
      constructor(e2) {
        super(e2), Object.defineProperty(this, "verbose", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "callbacks", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.verbose = e2.verbose ?? f(), this.callbacks = e2.callbacks, this.tags = e2.tags ?? [], this.metadata = e2.metadata ?? {};
      }
    }
    class g extends m {
      get callKeys() {
        return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"];
      }
      constructor({ callbacks: e2, callbackManager: t2, ...r2 }) {
        let { cache: n2, ...i2 } = r2;
        super({ callbacks: e2 ?? t2, ...i2 }), Object.defineProperty(this, "caller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "cache", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_encoding", { enumerable: true, configurable: true, writable: true, value: void 0 }), "object" == typeof n2 ? this.cache = n2 : n2 ? this.cache = a.InMemoryCache.global() : this.cache = void 0, this.caller = new s.AsyncCaller(r2 ?? {});
      }
      async getNumTokens(e2) {
        if ("string" != typeof e2)
          return 0;
        let t2 = Math.ceil(e2.length / 4);
        if (!this._encoding)
          try {
            this._encoding = await (0, o.encodingForModel)("modelName" in this ? u(this.modelName) : "gpt2");
          } catch (e3) {
            console.warn("Failed to calculate number of tokens, falling back to approximate count", e3);
          }
        if (this._encoding)
          try {
            t2 = this._encoding.encode(e2).length;
          } catch (e3) {
            console.warn("Failed to calculate number of tokens, falling back to approximate count", e3);
          }
        return t2;
      }
      static _convertInputToPromptValue(e2) {
        return "string" == typeof e2 ? new n.StringPromptValue(e2) : Array.isArray(e2) ? new n.ChatPromptValue(e2.map(i.E1)) : e2;
      }
      _identifyingParams() {
        return {};
      }
      _getSerializedCacheKeyParametersForCall({ config: e2, ...t2 }) {
        return Object.entries({ ...this._identifyingParams(), ...t2, _type: this._llmType(), _model: this._modelType() }).filter(([e3, t3]) => void 0 !== t3).map(([e3, t3]) => `${e3}:${JSON.stringify(t3)}`).sort().join(",");
      }
      serialize() {
        return { ...this._identifyingParams(), _type: this._llmType(), _model: this._modelType() };
      }
      static async deserialize(e2) {
        throw Error("Use .toJSON() instead");
      }
    }
  };
  __namedExportsObject["__chunk_2397"] = (e, t, r) => {
    "use strict";
    function a(e2, t2) {
      return e2.lc_error_code = t2, e2.message = `${e2.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${t2}/
`, e2;
    }
    r.d(t, { r: () => a });
  };
  __namedExportsObject["__chunk_7714"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { Embeddings: () => n });
    var a = r(1550);
    class n {
      constructor(e2) {
        Object.defineProperty(this, "caller", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.caller = new a.AsyncCaller(e2 ?? {});
      }
    }
  };
  __namedExportsObject["__chunk_755"] = (e, t, r) => {
    "use strict";
    let a;
    r.r(t), r.d(t, { awaitAllCallbacks: () => o, consumeCallback: () => s });
    var n = r(7439), i = r(5285);
    async function s(e2, t2) {
      true === t2 ? void 0 !== (0, i.IU)() ? await (0, i.IU)().run(void 0, async () => e2()) : await e2() : (void 0 === a && (a = new n.default({ autoStart: true, concurrency: 1 })), a.add(async () => {
        void 0 !== (0, i.IU)() ? await (0, i.IU)().run(void 0, async () => e2()) : await e2();
      }));
    }
    function o() {
      return void 0 !== a ? a.onIdle() : Promise.resolve();
    }
  };
  __namedExportsObject["__chunk_112"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseCallbackManager: () => p, BaseRunManager: () => f, CallbackManager: () => v, CallbackManagerForChainRun: () => y, CallbackManagerForLLMRun: () => g, CallbackManagerForRetrieverRun: () => m, CallbackManagerForToolRun: () => b, TraceGroup: () => w, ensureHandler: () => _, parseCallbackConfigArg: () => h, traceAsGroup: () => E });
    var a = r(2208), n = r(7250), i = r(7997), s = r(6131), o = r(5266), l = r(9205), u = r(755);
    let c = (e2) => void 0 !== e2 ? e2 : !!["LANGSMITH_TRACING_V2", "LANGCHAIN_TRACING_V2", "LANGSMITH_TRACING", "LANGCHAIN_TRACING"].find((e3) => "true" === (0, o.getEnvironmentVariable)(e3));
    var d = r(9321);
    function h(e2) {
      return e2 ? Array.isArray(e2) || "name" in e2 ? { callbacks: e2 } : e2 : {};
    }
    class p {
      setHandler(e2) {
        return this.setHandlers([e2]);
      }
    }
    class f {
      constructor(e2, t2, r2, a2, n2, i2, s2, o2) {
        Object.defineProperty(this, "runId", { enumerable: true, configurable: true, writable: true, value: e2 }), Object.defineProperty(this, "handlers", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "inheritableHandlers", { enumerable: true, configurable: true, writable: true, value: r2 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: a2 }), Object.defineProperty(this, "inheritableTags", { enumerable: true, configurable: true, writable: true, value: n2 }), Object.defineProperty(this, "metadata", { enumerable: true, configurable: true, writable: true, value: i2 }), Object.defineProperty(this, "inheritableMetadata", { enumerable: true, configurable: true, writable: true, value: s2 }), Object.defineProperty(this, "_parentRunId", { enumerable: true, configurable: true, writable: true, value: o2 });
      }
      get parentRunId() {
        return this._parentRunId;
      }
      async handleText(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          try {
            await t2.handleText?.(e2, this.runId, this._parentRunId, this.tags);
          } catch (e3) {
            if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleText: ${e3}`), t2.raiseError)
              throw e3;
          }
        }, t2.awaitHandlers)));
      }
      async handleCustomEvent(e2, t2, r2, a2, n2) {
        await Promise.all(this.handlers.map((r3) => (0, u.consumeCallback)(async () => {
          try {
            await r3.handleCustomEvent?.(e2, t2, this.runId, this.tags, this.metadata);
          } catch (e3) {
            if ((r3.raiseError ? console.error : console.warn)(`Error in handler ${r3.constructor.name}, handleCustomEvent: ${e3}`), r3.raiseError)
              throw e3;
          }
        }, r3.awaitHandlers)));
      }
    }
    class m extends f {
      getChild(e2) {
        let t2 = new v(this.runId);
        return t2.setHandlers(this.inheritableHandlers), t2.addTags(this.inheritableTags), t2.addMetadata(this.inheritableMetadata), e2 && t2.addTags([e2], false), t2;
      }
      async handleRetrieverEnd(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreRetriever)
            try {
              await t2.handleRetrieverEnd?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleRetriever`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
      async handleRetrieverError(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreRetriever)
            try {
              await t2.handleRetrieverError?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (r2) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleRetrieverError: ${r2}`), t2.raiseError)
                throw e2;
            }
        }, t2.awaitHandlers)));
      }
    }
    class g extends f {
      async handleLLMNewToken(e2, t2, r2, a2, n2, i2) {
        await Promise.all(this.handlers.map((r3) => (0, u.consumeCallback)(async () => {
          if (!r3.ignoreLLM)
            try {
              await r3.handleLLMNewToken?.(e2, t2 ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, i2);
            } catch (e3) {
              if ((r3.raiseError ? console.error : console.warn)(`Error in handler ${r3.constructor.name}, handleLLMNewToken: ${e3}`), r3.raiseError)
                throw e3;
            }
        }, r3.awaitHandlers)));
      }
      async handleLLMError(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreLLM)
            try {
              await t2.handleLLMError?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleLLMError: ${e3}`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
      async handleLLMEnd(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreLLM)
            try {
              await t2.handleLLMEnd?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleLLMEnd: ${e3}`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
    }
    class y extends f {
      getChild(e2) {
        let t2 = new v(this.runId);
        return t2.setHandlers(this.inheritableHandlers), t2.addTags(this.inheritableTags), t2.addMetadata(this.inheritableMetadata), e2 && t2.addTags([e2], false), t2;
      }
      async handleChainError(e2, t2, r2, a2, n2) {
        await Promise.all(this.handlers.map((t3) => (0, u.consumeCallback)(async () => {
          if (!t3.ignoreChain)
            try {
              await t3.handleChainError?.(e2, this.runId, this._parentRunId, this.tags, n2);
            } catch (e3) {
              if ((t3.raiseError ? console.error : console.warn)(`Error in handler ${t3.constructor.name}, handleChainError: ${e3}`), t3.raiseError)
                throw e3;
            }
        }, t3.awaitHandlers)));
      }
      async handleChainEnd(e2, t2, r2, a2, n2) {
        await Promise.all(this.handlers.map((t3) => (0, u.consumeCallback)(async () => {
          if (!t3.ignoreChain)
            try {
              await t3.handleChainEnd?.(e2, this.runId, this._parentRunId, this.tags, n2);
            } catch (e3) {
              if ((t3.raiseError ? console.error : console.warn)(`Error in handler ${t3.constructor.name}, handleChainEnd: ${e3}`), t3.raiseError)
                throw e3;
            }
        }, t3.awaitHandlers)));
      }
      async handleAgentAction(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreAgent)
            try {
              await t2.handleAgentAction?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleAgentAction: ${e3}`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
      async handleAgentEnd(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreAgent)
            try {
              await t2.handleAgentEnd?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleAgentEnd: ${e3}`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
    }
    class b extends f {
      getChild(e2) {
        let t2 = new v(this.runId);
        return t2.setHandlers(this.inheritableHandlers), t2.addTags(this.inheritableTags), t2.addMetadata(this.inheritableMetadata), e2 && t2.addTags([e2], false), t2;
      }
      async handleToolError(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreAgent)
            try {
              await t2.handleToolError?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleToolError: ${e3}`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
      async handleToolEnd(e2) {
        await Promise.all(this.handlers.map((t2) => (0, u.consumeCallback)(async () => {
          if (!t2.ignoreAgent)
            try {
              await t2.handleToolEnd?.(e2, this.runId, this._parentRunId, this.tags);
            } catch (e3) {
              if ((t2.raiseError ? console.error : console.warn)(`Error in handler ${t2.constructor.name}, handleToolEnd: ${e3}`), t2.raiseError)
                throw e3;
            }
        }, t2.awaitHandlers)));
      }
    }
    class v extends p {
      constructor(e2, t2) {
        super(), Object.defineProperty(this, "handlers", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "inheritableHandlers", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "inheritableTags", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "metadata", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "inheritableMetadata", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "callback_manager" }), Object.defineProperty(this, "_parentRunId", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.handlers = t2?.handlers ?? this.handlers, this.inheritableHandlers = t2?.inheritableHandlers ?? this.inheritableHandlers, this.tags = t2?.tags ?? this.tags, this.inheritableTags = t2?.inheritableTags ?? this.inheritableTags, this.metadata = t2?.metadata ?? this.metadata, this.inheritableMetadata = t2?.inheritableMetadata ?? this.inheritableMetadata, this._parentRunId = e2;
      }
      getParentRunId() {
        return this._parentRunId;
      }
      async handleLLMStart(e2, t2, r2, n2, i2, s2, o2, l2) {
        return Promise.all(t2.map(async (t3, n3) => {
          let s3 = 0 === n3 && r2 ? r2 : (0, a.Z)();
          return await Promise.all(this.handlers.map((r3) => {
            if (!r3.ignoreLLM)
              return (0, d.isBaseTracer)(r3) && r3._createRunForLLMStart(e2, [t3], s3, this._parentRunId, i2, this.tags, this.metadata, l2), (0, u.consumeCallback)(async () => {
                try {
                  await r3.handleLLMStart?.(e2, [t3], s3, this._parentRunId, i2, this.tags, this.metadata, l2);
                } catch (e3) {
                  if ((r3.raiseError ? console.error : console.warn)(`Error in handler ${r3.constructor.name}, handleLLMStart: ${e3}`), r3.raiseError)
                    throw e3;
                }
              }, r3.awaitHandlers);
          })), new g(s3, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
        }));
      }
      async handleChatModelStart(e2, t2, r2, n2, i2, o2, l2, c2) {
        return Promise.all(t2.map(async (t3, n3) => {
          let o3 = 0 === n3 && r2 ? r2 : (0, a.Z)();
          return await Promise.all(this.handlers.map((r3) => {
            if (!r3.ignoreLLM)
              return (0, d.isBaseTracer)(r3) && r3._createRunForChatModelStart(e2, [t3], o3, this._parentRunId, i2, this.tags, this.metadata, c2), (0, u.consumeCallback)(async () => {
                try {
                  if (r3.handleChatModelStart)
                    await r3.handleChatModelStart?.(e2, [t3], o3, this._parentRunId, i2, this.tags, this.metadata, c2);
                  else if (r3.handleLLMStart) {
                    let a2 = (0, s.zs)(t3);
                    await r3.handleLLMStart?.(e2, [a2], o3, this._parentRunId, i2, this.tags, this.metadata, c2);
                  }
                } catch (e3) {
                  if ((r3.raiseError ? console.error : console.warn)(`Error in handler ${r3.constructor.name}, handleLLMStart: ${e3}`), r3.raiseError)
                    throw e3;
                }
              }, r3.awaitHandlers);
          })), new g(o3, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
        }));
      }
      async handleChainStart(e2, t2, r2 = (0, a.Z)(), n2, i2, s2, o2) {
        return await Promise.all(this.handlers.map((a2) => {
          if (!a2.ignoreChain)
            return (0, d.isBaseTracer)(a2) && a2._createRunForChainStart(e2, t2, r2, this._parentRunId, this.tags, this.metadata, n2, o2), (0, u.consumeCallback)(async () => {
              try {
                await a2.handleChainStart?.(e2, t2, r2, this._parentRunId, this.tags, this.metadata, n2, o2);
              } catch (e3) {
                if ((a2.raiseError ? console.error : console.warn)(`Error in handler ${a2.constructor.name}, handleChainStart: ${e3}`), a2.raiseError)
                  throw e3;
              }
            }, a2.awaitHandlers);
        })), new y(r2, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleToolStart(e2, t2, r2 = (0, a.Z)(), n2, i2, s2, o2) {
        return await Promise.all(this.handlers.map((a2) => {
          if (!a2.ignoreAgent)
            return (0, d.isBaseTracer)(a2) && a2._createRunForToolStart(e2, t2, r2, this._parentRunId, this.tags, this.metadata, o2), (0, u.consumeCallback)(async () => {
              try {
                await a2.handleToolStart?.(e2, t2, r2, this._parentRunId, this.tags, this.metadata, o2);
              } catch (e3) {
                if ((a2.raiseError ? console.error : console.warn)(`Error in handler ${a2.constructor.name}, handleToolStart: ${e3}`), a2.raiseError)
                  throw e3;
              }
            }, a2.awaitHandlers);
        })), new b(r2, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleRetrieverStart(e2, t2, r2 = (0, a.Z)(), n2, i2, s2, o2) {
        return await Promise.all(this.handlers.map((a2) => {
          if (!a2.ignoreRetriever)
            return (0, d.isBaseTracer)(a2) && a2._createRunForRetrieverStart(e2, t2, r2, this._parentRunId, this.tags, this.metadata, o2), (0, u.consumeCallback)(async () => {
              try {
                await a2.handleRetrieverStart?.(e2, t2, r2, this._parentRunId, this.tags, this.metadata, o2);
              } catch (e3) {
                if ((a2.raiseError ? console.error : console.warn)(`Error in handler ${a2.constructor.name}, handleRetrieverStart: ${e3}`), a2.raiseError)
                  throw e3;
              }
            }, a2.awaitHandlers);
        })), new m(r2, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleCustomEvent(e2, t2, r2, a2, n2) {
        await Promise.all(this.handlers.map((a3) => (0, u.consumeCallback)(async () => {
          if (!a3.ignoreCustomEvent)
            try {
              await a3.handleCustomEvent?.(e2, t2, r2, this.tags, this.metadata);
            } catch (e3) {
              if ((a3.raiseError ? console.error : console.warn)(`Error in handler ${a3.constructor.name}, handleCustomEvent: ${e3}`), a3.raiseError)
                throw e3;
            }
        }, a3.awaitHandlers)));
      }
      addHandler(e2, t2 = true) {
        this.handlers.push(e2), t2 && this.inheritableHandlers.push(e2);
      }
      removeHandler(e2) {
        this.handlers = this.handlers.filter((t2) => t2 !== e2), this.inheritableHandlers = this.inheritableHandlers.filter((t2) => t2 !== e2);
      }
      setHandlers(e2, t2 = true) {
        for (let r2 of (this.handlers = [], this.inheritableHandlers = [], e2))
          this.addHandler(r2, t2);
      }
      addTags(e2, t2 = true) {
        this.removeTags(e2), this.tags.push(...e2), t2 && this.inheritableTags.push(...e2);
      }
      removeTags(e2) {
        this.tags = this.tags.filter((t2) => !e2.includes(t2)), this.inheritableTags = this.inheritableTags.filter((t2) => !e2.includes(t2));
      }
      addMetadata(e2, t2 = true) {
        this.metadata = { ...this.metadata, ...e2 }, t2 && (this.inheritableMetadata = { ...this.inheritableMetadata, ...e2 });
      }
      removeMetadata(e2) {
        for (let t2 of Object.keys(e2))
          delete this.metadata[t2], delete this.inheritableMetadata[t2];
      }
      copy(e2 = [], t2 = true) {
        let r2 = new v(this._parentRunId);
        for (let e3 of this.handlers) {
          let t3 = this.inheritableHandlers.includes(e3);
          r2.addHandler(e3, t3);
        }
        for (let e3 of this.tags) {
          let t3 = this.inheritableTags.includes(e3);
          r2.addTags([e3], t3);
        }
        for (let e3 of Object.keys(this.metadata)) {
          let t3 = Object.keys(this.inheritableMetadata).includes(e3);
          r2.addMetadata({ [e3]: this.metadata[e3] }, t3);
        }
        for (let a2 of e2)
          r2.handlers.filter((e3) => "console_callback_handler" === e3.name).some((e3) => e3.name === a2.name) || r2.addHandler(a2, t2);
        return r2;
      }
      static fromHandlers(e2) {
        class t2 extends n.BaseCallbackHandler {
          constructor() {
            super(), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: (0, a.Z)() }), Object.assign(this, e2);
          }
        }
        let r2 = new this();
        return r2.addHandler(new t2()), r2;
      }
      static configure(e2, t2, r2, a2, n2, i2, s2) {
        return this._configureSync(e2, t2, r2, a2, n2, i2, s2);
      }
      static _configureSync(e2, t2, r2, a2, n2, s2, u2) {
        let d2;
        (e2 || t2) && (Array.isArray(e2) || !e2 ? (d2 = new v()).setHandlers(e2?.map(_) ?? [], true) : d2 = e2, d2 = d2.copy(Array.isArray(t2) ? t2.map(_) : t2?.handlers, false));
        let h2 = "true" === (0, o.getEnvironmentVariable)("LANGCHAIN_VERBOSE") || u2?.verbose, p2 = l.LangChainTracer.getTraceableRunTree()?.tracingEnabled || c(), f2 = p2 || ((0, o.getEnvironmentVariable)("LANGCHAIN_TRACING") ?? false);
        if (h2 || f2) {
          if (d2 || (d2 = new v()), h2 && !d2.handlers.some((e3) => e3.name === i.ConsoleCallbackHandler.prototype.name)) {
            let e3 = new i.ConsoleCallbackHandler();
            d2.addHandler(e3, true);
          }
          if (f2 && !d2.handlers.some((e3) => "langchain_tracer" === e3.name) && p2) {
            let e3 = new l.LangChainTracer();
            d2.addHandler(e3, true), d2._parentRunId = l.LangChainTracer.getTraceableRunTree()?.id ?? d2._parentRunId;
          }
        }
        return (r2 || a2) && d2 && (d2.addTags(r2 ?? []), d2.addTags(a2 ?? [], false)), (n2 || s2) && d2 && (d2.addMetadata(n2 ?? {}), d2.addMetadata(s2 ?? {}, false)), d2;
      }
    }
    function _(e2) {
      return "name" in e2 ? e2 : n.BaseCallbackHandler.fromMethods(e2);
    }
    class w {
      constructor(e2, t2) {
        Object.defineProperty(this, "groupName", { enumerable: true, configurable: true, writable: true, value: e2 }), Object.defineProperty(this, "options", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "runManager", { enumerable: true, configurable: true, writable: true, value: void 0 });
      }
      async getTraceGroupCallbackManager(e2, t2, r2) {
        let a2 = new l.LangChainTracer(r2), n2 = await v.configure([a2]), i2 = await n2?.handleChainStart({ lc: 1, type: "not_implemented", id: ["langchain", "callbacks", "groups", e2] }, t2 ?? {});
        if (!i2)
          throw Error("Failed to create run group callback manager.");
        return i2;
      }
      async start(e2) {
        return this.runManager || (this.runManager = await this.getTraceGroupCallbackManager(this.groupName, e2, this.options)), this.runManager.getChild();
      }
      async error(e2) {
        this.runManager && (await this.runManager.handleChainError(e2), this.runManager = void 0);
      }
      async end(e2) {
        this.runManager && (await this.runManager.handleChainEnd(e2 ?? {}), this.runManager = void 0);
      }
    }
    async function E(e2, t2, ...r2) {
      let a2 = new w(e2.name, e2), n2 = await a2.start({ ...r2 });
      try {
        let e3 = await t2(n2, ...r2);
        return await a2.end(e3 && !Array.isArray(e3) && "object" == typeof e3 ? e3 : { output: e3 }), e3;
      } catch (e3) {
        throw await a2.error(e3), e3;
      }
    }
  };
  __namedExportsObject["__chunk_7250"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseCallbackHandler: () => o });
    var a = r(2208), n = r(3686), i = r(5266);
    class s {
    }
    class o extends s {
      get lc_namespace() {
        return ["langchain_core", "callbacks", this.name];
      }
      get lc_secrets() {
      }
      get lc_attributes() {
      }
      get lc_aliases() {
      }
      static lc_name() {
        return this.name;
      }
      get lc_id() {
        return [...this.lc_namespace, (0, n.get_lc_unique_name)(this.constructor)];
      }
      constructor(e2) {
        super(), Object.defineProperty(this, "lc_serializable", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "lc_kwargs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "ignoreLLM", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "ignoreChain", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "ignoreAgent", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "ignoreRetriever", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "ignoreCustomEvent", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "raiseError", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "awaitHandlers", { enumerable: true, configurable: true, writable: true, value: "false" === (0, i.getEnvironmentVariable)("LANGCHAIN_CALLBACKS_BACKGROUND") }), this.lc_kwargs = e2 || {}, e2 && (this.ignoreLLM = e2.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = e2.ignoreChain ?? this.ignoreChain, this.ignoreAgent = e2.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = e2.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = e2.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = e2.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (e2._awaitHandler ?? this.awaitHandlers));
      }
      copy() {
        return new this.constructor(this);
      }
      toJSON() {
        return n.Serializable.prototype.toJSON.call(this);
      }
      toJSONNotImplemented() {
        return n.Serializable.prototype.toJSONNotImplemented.call(this);
      }
      static fromMethods(e2) {
        class t2 extends o {
          constructor() {
            super(), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: a.Z() }), Object.assign(this, e2);
          }
        }
        return new t2();
      }
    }
  };
  __namedExportsObject["__chunk_7783"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { BaseCache: () => l, InMemoryCache: () => c, deserializeStoredGeneration: () => s, getCacheKey: () => i, serializeGeneration: () => o });
    var a = r(2110), n = r(6131);
    let i = (...e2) => (0, a.insecureHash)(e2.join("_"));
    function s(e2) {
      return void 0 !== e2.message ? { text: e2.text, message: (0, n.rk)(e2.message) } : { text: e2.text };
    }
    function o(e2) {
      let t2 = { text: e2.text };
      return void 0 !== e2.message && (t2.message = e2.message.toDict()), t2;
    }
    class l {
    }
    let u = /* @__PURE__ */ new Map();
    class c extends l {
      constructor(e2) {
        super(), Object.defineProperty(this, "cache", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.cache = e2 ?? /* @__PURE__ */ new Map();
      }
      lookup(e2, t2) {
        return Promise.resolve(this.cache.get(i(e2, t2)) ?? null);
      }
      async update(e2, t2, r2) {
        this.cache.set(i(e2, t2), r2);
      }
      static global() {
        return new c(u);
      }
    }
  };
  __namedExportsObject["__chunk_9182"] = (e, t, r) => {
    "use strict";
    r.d(t, { A: () => a });
    let a = (0, r(5228).P)();
  };
  __namedExportsObject["__chunk_8983"] = (e, t, r) => {
    "use strict";
    r.d(t, { O: () => a });
    let a = (0, r(5228).P)();
  };
  __namedExportsObject["__chunk_5228"] = (e, t, r) => {
    "use strict";
    r.d(t, { P: () => s });
    let a = Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    class n {
      disable() {
        throw a;
      }
      getStore() {
      }
      run() {
        throw a;
      }
      exit() {
        throw a;
      }
      enterWith() {
        throw a;
      }
    }
    let i = globalThis.AsyncLocalStorage;
    function s() {
      return i ? new i() : new n();
    }
  };
  __namedExportsObject["__chunk_8212"] = (e, t, r) => {
    "use strict";
    r.d(t, { Z: () => n });
    let a = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i, n = function(e2) {
      return "string" == typeof e2 && a.test(e2);
    };
  };
  __namedExportsObject["__chunk_2208"] = (e, t, r) => {
    "use strict";
    r.d(t, { Z: () => s });
    let a = { randomUUID: "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
    var n = r(5133), i = r(8762);
    let s = function(e2, t2, r2) {
      if (a.randomUUID && !t2 && !e2)
        return a.randomUUID();
      var s2 = (e2 = e2 || {}).random || (e2.rng || n.Z)();
      if (s2[6] = 15 & s2[6] | 64, s2[8] = 63 & s2[8] | 128, t2) {
        r2 = r2 || 0;
        for (var o = 0; o < 16; ++o)
          t2[r2 + o] = s2[o];
        return t2;
      }
      return (0, i.S)(s2);
    };
  };
  __namedExportsObject["__chunk_8762"] = (e, t, r) => {
    "use strict";
    r.d(t, { S: () => i });
    for (var a = [], n = 0; n < 256; ++n)
      a.push((n + 256).toString(16).slice(1));
    function i(e2, t2 = 0) {
      return (a[e2[t2 + 0]] + a[e2[t2 + 1]] + a[e2[t2 + 2]] + a[e2[t2 + 3]] + "-" + a[e2[t2 + 4]] + a[e2[t2 + 5]] + "-" + a[e2[t2 + 6]] + a[e2[t2 + 7]] + "-" + a[e2[t2 + 8]] + a[e2[t2 + 9]] + "-" + a[e2[t2 + 10]] + a[e2[t2 + 11]] + a[e2[t2 + 12]] + a[e2[t2 + 13]] + a[e2[t2 + 14]] + a[e2[t2 + 15]]).toLowerCase();
    }
  };
  __namedExportsObject["__chunk_5133"] = (e, t, r) => {
    "use strict";
    r.d(t, { Z: () => i });
    var a, n = new Uint8Array(16);
    function i() {
      if (!a && !(a = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)))
        throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return a(n);
    }
  };
  __namedExportsObject["__chunk_5245"] = (e, t, r) => {
    let a = r(4460);
    e.exports = (e2, t2) => {
      try {
        return new a(e2, t2).range || "*";
      } catch (e3) {
        return null;
      }
    };
  };
  __namedExportsObject["__chunk_6835"] = (e, t, r) => {
    let a = r(4460);
    e.exports = (e2, t2) => new a(e2, t2).set.map((e3) => e3.map((e4) => e4.value).join(" ").trim().split(" "));
  };
  __namedExportsObject["__chunk_2666"] = (e, t, r) => {
    let a = r(4460), n = r(7779), { ANY: i } = n, s = r(9884), o = r(7512), l = [new n(">=0.0.0-0")], u = [new n(">=0.0.0")], c = (e2, t2, r2) => {
      let a2, n2, c2, p, f, m, g;
      if (e2 === t2)
        return true;
      if (1 === e2.length && e2[0].semver === i) {
        if (1 === t2.length && t2[0].semver === i)
          return true;
        e2 = r2.includePrerelease ? l : u;
      }
      if (1 === t2.length && t2[0].semver === i) {
        if (r2.includePrerelease)
          return true;
        t2 = u;
      }
      let y = /* @__PURE__ */ new Set();
      for (let t3 of e2)
        ">" === t3.operator || ">=" === t3.operator ? a2 = d(a2, t3, r2) : "<" === t3.operator || "<=" === t3.operator ? n2 = h(n2, t3, r2) : y.add(t3.semver);
      if (y.size > 1 || a2 && n2 && ((c2 = o(a2.semver, n2.semver, r2)) > 0 || 0 === c2 && (">=" !== a2.operator || "<=" !== n2.operator)))
        return null;
      for (let e3 of y) {
        if (a2 && !s(e3, String(a2), r2) || n2 && !s(e3, String(n2), r2))
          return null;
        for (let a3 of t2)
          if (!s(e3, String(a3), r2))
            return false;
        return true;
      }
      let b = !!n2 && !r2.includePrerelease && !!n2.semver.prerelease.length && n2.semver, v = !!a2 && !r2.includePrerelease && !!a2.semver.prerelease.length && a2.semver;
      for (let e3 of (b && 1 === b.prerelease.length && "<" === n2.operator && 0 === b.prerelease[0] && (b = false), t2)) {
        if (g = g || ">" === e3.operator || ">=" === e3.operator, m = m || "<" === e3.operator || "<=" === e3.operator, a2) {
          if (v && e3.semver.prerelease && e3.semver.prerelease.length && e3.semver.major === v.major && e3.semver.minor === v.minor && e3.semver.patch === v.patch && (v = false), ">" === e3.operator || ">=" === e3.operator) {
            if ((p = d(a2, e3, r2)) === e3 && p !== a2)
              return false;
          } else if (">=" === a2.operator && !s(a2.semver, String(e3), r2))
            return false;
        }
        if (n2) {
          if (b && e3.semver.prerelease && e3.semver.prerelease.length && e3.semver.major === b.major && e3.semver.minor === b.minor && e3.semver.patch === b.patch && (b = false), "<" === e3.operator || "<=" === e3.operator) {
            if ((f = h(n2, e3, r2)) === e3 && f !== n2)
              return false;
          } else if ("<=" === n2.operator && !s(n2.semver, String(e3), r2))
            return false;
        }
        if (!e3.operator && (n2 || a2) && 0 !== c2)
          return false;
      }
      return (!a2 || !m || !!n2 || 0 === c2) && (!n2 || !g || !!a2 || 0 === c2) && !v && !b;
    }, d = (e2, t2, r2) => {
      if (!e2)
        return t2;
      let a2 = o(e2.semver, t2.semver, r2);
      return a2 > 0 ? e2 : a2 < 0 ? t2 : ">" === t2.operator && ">=" === e2.operator ? t2 : e2;
    }, h = (e2, t2, r2) => {
      if (!e2)
        return t2;
      let a2 = o(e2.semver, t2.semver, r2);
      return a2 < 0 ? e2 : a2 > 0 ? t2 : "<" === t2.operator && "<=" === e2.operator ? t2 : e2;
    };
    e.exports = (e2, t2, r2 = {}) => {
      if (e2 === t2)
        return true;
      e2 = new a(e2, r2), t2 = new a(t2, r2);
      let n2 = false;
      e:
        for (let a2 of e2.set) {
          for (let e3 of t2.set) {
            let t3 = c(a2, e3, r2);
            if (n2 = n2 || null !== t3, t3)
              continue e;
          }
          if (n2)
            return false;
        }
      return true;
    };
  };
  __namedExportsObject["__chunk_1734"] = (e, t, r) => {
    let a = r(9884), n = r(7512);
    e.exports = (e2, t2, r2) => {
      let i = [], s = null, o = null, l = e2.sort((e3, t3) => n(e3, t3, r2));
      for (let e3 of l)
        a(e3, t2, r2) ? (o = e3, s || (s = e3)) : (o && i.push([s, o]), o = null, s = null);
      s && i.push([s, null]);
      let u = [];
      for (let [e3, t3] of i)
        e3 === t3 ? u.push(e3) : t3 || e3 !== l[0] ? t3 ? e3 === l[0] ? u.push(`<=${t3}`) : u.push(`${e3} - ${t3}`) : u.push(`>=${e3}`) : u.push("*");
      let c = u.join(" || "), d = "string" == typeof t2.raw ? t2.raw : String(t2);
      return c.length < d.length ? c : t2;
    };
  };
  __namedExportsObject["__chunk_2412"] = (e, t, r) => {
    let a = r(4234), n = r(7779), { ANY: i } = n, s = r(4460), o = r(9884), l = r(5692), u = r(9853), c = r(6628), d = r(4420);
    e.exports = (e2, t2, r2, h) => {
      let p, f, m, g, y;
      switch (e2 = new a(e2, h), t2 = new s(t2, h), r2) {
        case ">":
          p = l, f = c, m = u, g = ">", y = ">=";
          break;
        case "<":
          p = u, f = d, m = l, g = "<", y = "<=";
          break;
        default:
          throw TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (o(e2, t2, h))
        return false;
      for (let r3 = 0; r3 < t2.set.length; ++r3) {
        let a2 = t2.set[r3], s2 = null, o2 = null;
        if (a2.forEach((e3) => {
          e3.semver === i && (e3 = new n(">=0.0.0")), s2 = s2 || e3, o2 = o2 || e3, p(e3.semver, s2.semver, h) ? s2 = e3 : m(e3.semver, o2.semver, h) && (o2 = e3);
        }), s2.operator === g || s2.operator === y || (!o2.operator || o2.operator === g) && f(e2, o2.semver) || o2.operator === y && m(e2, o2.semver))
          return false;
      }
      return true;
    };
  };
  __namedExportsObject["__chunk_111"] = (e, t, r) => {
    let a = r(4234), n = r(4460), i = r(5692);
    e.exports = (e2, t2) => {
      e2 = new n(e2, t2);
      let r2 = new a("0.0.0");
      if (e2.test(r2) || (r2 = new a("0.0.0-0"), e2.test(r2)))
        return r2;
      r2 = null;
      for (let t3 = 0; t3 < e2.set.length; ++t3) {
        let n2 = e2.set[t3], s = null;
        n2.forEach((e3) => {
          let t4 = new a(e3.semver.version);
          switch (e3.operator) {
            case ">":
              0 === t4.prerelease.length ? t4.patch++ : t4.prerelease.push(0), t4.raw = t4.format();
            case "":
            case ">=":
              (!s || i(t4, s)) && (s = t4);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw Error(`Unexpected operation: ${e3.operator}`);
          }
        }), s && (!r2 || i(r2, s)) && (r2 = s);
      }
      return r2 && e2.test(r2) ? r2 : null;
    };
  };
  __namedExportsObject["__chunk_1101"] = (e, t, r) => {
    let a = r(4234), n = r(4460);
    e.exports = (e2, t2, r2) => {
      let i = null, s = null, o = null;
      try {
        o = new n(t2, r2);
      } catch (e3) {
        return null;
      }
      return e2.forEach((e3) => {
        o.test(e3) && (!i || 1 === s.compare(e3)) && (s = new a(i = e3, r2));
      }), i;
    };
  };
  __namedExportsObject["__chunk_2118"] = (e, t, r) => {
    let a = r(4234), n = r(4460);
    e.exports = (e2, t2, r2) => {
      let i = null, s = null, o = null;
      try {
        o = new n(t2, r2);
      } catch (e3) {
        return null;
      }
      return e2.forEach((e3) => {
        o.test(e3) && (!i || -1 === s.compare(e3)) && (s = new a(i = e3, r2));
      }), i;
    };
  };
  __namedExportsObject["__chunk_81"] = (e, t, r) => {
    let a = r(2412);
    e.exports = (e2, t2, r2) => a(e2, t2, "<", r2);
  };
  __namedExportsObject["__chunk_9298"] = (e, t, r) => {
    let a = r(4460);
    e.exports = (e2, t2, r2) => (e2 = new a(e2, r2), t2 = new a(t2, r2), e2.intersects(t2, r2));
  };
  __namedExportsObject["__chunk_6608"] = (e, t, r) => {
    let a = r(2412);
    e.exports = (e2, t2, r2) => a(e2, t2, ">", r2);
  };
  __namedExportsObject["__chunk_2385"] = (e, t, r) => {
    let { MAX_SAFE_COMPONENT_LENGTH: a, MAX_SAFE_BUILD_LENGTH: n, MAX_LENGTH: i } = r(7803), s = r(2109), o = (t = e.exports = {}).re = [], l = t.safeRe = [], u = t.src = [], c = t.t = {}, d = 0, h = "[a-zA-Z0-9-]", p = [["\\s", 1], ["\\d", i], [h, n]], f = (e2) => {
      for (let [t2, r2] of p)
        e2 = e2.split(`${t2}*`).join(`${t2}{0,${r2}}`).split(`${t2}+`).join(`${t2}{1,${r2}}`);
      return e2;
    }, m = (e2, t2, r2) => {
      let a2 = f(t2), n2 = d++;
      s(e2, n2, t2), c[e2] = n2, u[n2] = t2, o[n2] = new RegExp(t2, r2 ? "g" : void 0), l[n2] = new RegExp(a2, r2 ? "g" : void 0);
    };
    m("NUMERICIDENTIFIER", "0|[1-9]\\d*"), m("NUMERICIDENTIFIERLOOSE", "\\d+"), m("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`), m("MAINVERSION", `(${u[c.NUMERICIDENTIFIER]})\\.(${u[c.NUMERICIDENTIFIER]})\\.(${u[c.NUMERICIDENTIFIER]})`), m("MAINVERSIONLOOSE", `(${u[c.NUMERICIDENTIFIERLOOSE]})\\.(${u[c.NUMERICIDENTIFIERLOOSE]})\\.(${u[c.NUMERICIDENTIFIERLOOSE]})`), m("PRERELEASEIDENTIFIER", `(?:${u[c.NUMERICIDENTIFIER]}|${u[c.NONNUMERICIDENTIFIER]})`), m("PRERELEASEIDENTIFIERLOOSE", `(?:${u[c.NUMERICIDENTIFIERLOOSE]}|${u[c.NONNUMERICIDENTIFIER]})`), m("PRERELEASE", `(?:-(${u[c.PRERELEASEIDENTIFIER]}(?:\\.${u[c.PRERELEASEIDENTIFIER]})*))`), m("PRERELEASELOOSE", `(?:-?(${u[c.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[c.PRERELEASEIDENTIFIERLOOSE]})*))`), m("BUILDIDENTIFIER", `${h}+`), m("BUILD", `(?:\\+(${u[c.BUILDIDENTIFIER]}(?:\\.${u[c.BUILDIDENTIFIER]})*))`), m("FULLPLAIN", `v?${u[c.MAINVERSION]}${u[c.PRERELEASE]}?${u[c.BUILD]}?`), m("FULL", `^${u[c.FULLPLAIN]}$`), m("LOOSEPLAIN", `[v=\\s]*${u[c.MAINVERSIONLOOSE]}${u[c.PRERELEASELOOSE]}?${u[c.BUILD]}?`), m("LOOSE", `^${u[c.LOOSEPLAIN]}$`), m("GTLT", "((?:<|>)?=?)"), m("XRANGEIDENTIFIERLOOSE", `${u[c.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), m("XRANGEIDENTIFIER", `${u[c.NUMERICIDENTIFIER]}|x|X|\\*`), m("XRANGEPLAIN", `[v=\\s]*(${u[c.XRANGEIDENTIFIER]})(?:\\.(${u[c.XRANGEIDENTIFIER]})(?:\\.(${u[c.XRANGEIDENTIFIER]})(?:${u[c.PRERELEASE]})?${u[c.BUILD]}?)?)?`), m("XRANGEPLAINLOOSE", `[v=\\s]*(${u[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[c.XRANGEIDENTIFIERLOOSE]})(?:${u[c.PRERELEASELOOSE]})?${u[c.BUILD]}?)?)?`), m("XRANGE", `^${u[c.GTLT]}\\s*${u[c.XRANGEPLAIN]}$`), m("XRANGELOOSE", `^${u[c.GTLT]}\\s*${u[c.XRANGEPLAINLOOSE]}$`), m("COERCEPLAIN", `(^|[^\\d])(\\d{1,${a}})(?:\\.(\\d{1,${a}}))?(?:\\.(\\d{1,${a}}))?`), m("COERCE", `${u[c.COERCEPLAIN]}(?:$|[^\\d])`), m("COERCEFULL", u[c.COERCEPLAIN] + `(?:${u[c.PRERELEASE]})?(?:${u[c.BUILD]})?(?:$|[^\\d])`), m("COERCERTL", u[c.COERCE], true), m("COERCERTLFULL", u[c.COERCEFULL], true), m("LONETILDE", "(?:~>?)"), m("TILDETRIM", `(\\s*)${u[c.LONETILDE]}\\s+`, true), t.tildeTrimReplace = "$1~", m("TILDE", `^${u[c.LONETILDE]}${u[c.XRANGEPLAIN]}$`), m("TILDELOOSE", `^${u[c.LONETILDE]}${u[c.XRANGEPLAINLOOSE]}$`), m("LONECARET", "(?:\\^)"), m("CARETTRIM", `(\\s*)${u[c.LONECARET]}\\s+`, true), t.caretTrimReplace = "$1^", m("CARET", `^${u[c.LONECARET]}${u[c.XRANGEPLAIN]}$`), m("CARETLOOSE", `^${u[c.LONECARET]}${u[c.XRANGEPLAINLOOSE]}$`), m("COMPARATORLOOSE", `^${u[c.GTLT]}\\s*(${u[c.LOOSEPLAIN]})$|^$`), m("COMPARATOR", `^${u[c.GTLT]}\\s*(${u[c.FULLPLAIN]})$|^$`), m("COMPARATORTRIM", `(\\s*)${u[c.GTLT]}\\s*(${u[c.LOOSEPLAIN]}|${u[c.XRANGEPLAIN]})`, true), t.comparatorTrimReplace = "$1$2$3", m("HYPHENRANGE", `^\\s*(${u[c.XRANGEPLAIN]})\\s+-\\s+(${u[c.XRANGEPLAIN]})\\s*$`), m("HYPHENRANGELOOSE", `^\\s*(${u[c.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[c.XRANGEPLAINLOOSE]})\\s*$`), m("STAR", "(<|>)?=?\\s*\\*"), m("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), m("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  };
  __namedExportsObject["__chunk_2409"] = (e) => {
    let t = Object.freeze({ loose: true }), r = Object.freeze({});
    e.exports = (e2) => e2 ? "object" != typeof e2 ? t : e2 : r;
  };
  __namedExportsObject["__chunk_5712"] = (e) => {
    class t {
      constructor() {
        this.max = 1e3, this.map = /* @__PURE__ */ new Map();
      }
      get(e2) {
        let t2 = this.map.get(e2);
        if (void 0 !== t2)
          return this.map.delete(e2), this.map.set(e2, t2), t2;
      }
      delete(e2) {
        return this.map.delete(e2);
      }
      set(e2, t2) {
        if (!this.delete(e2) && void 0 !== t2) {
          if (this.map.size >= this.max) {
            let e3 = this.map.keys().next().value;
            this.delete(e3);
          }
          this.map.set(e2, t2);
        }
        return this;
      }
    }
    e.exports = t;
  };
  __namedExportsObject["__chunk_8858"] = (e) => {
    let t = /^[0-9]+$/, r = (e2, r2) => {
      let a = t.test(e2), n = t.test(r2);
      return a && n && (e2 = +e2, r2 = +r2), e2 === r2 ? 0 : a && !n ? -1 : n && !a ? 1 : e2 < r2 ? -1 : 1;
    };
    e.exports = { compareIdentifiers: r, rcompareIdentifiers: (e2, t2) => r(t2, e2) };
  };
  __namedExportsObject["__chunk_2109"] = (e) => {
    let t = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e2) => console.error("SEMVER", ...e2) : () => {
    };
    e.exports = t;
  };
  __namedExportsObject["__chunk_7803"] = (e) => {
    let t = Number.MAX_SAFE_INTEGER || 9007199254740991;
    e.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: t, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
  };
  __namedExportsObject["__chunk_7420"] = (e, t, r) => {
    let a = r(2385), n = r(7803), i = r(4234), s = r(8858), o = r(4306), l = r(1017), u = r(3624), c = r(1049), d = r(5092), h = r(7066), p = r(1), f = r(4948), m = r(9772), g = r(7512), y = r(6123), b = r(3344), v = r(39), _ = r(5268), w = r(6096), E = r(5692), x = r(9853), O = r(4405), S = r(3371), A = r(4420), k = r(6628), T = r(4579), P = r(3167), C = r(7779), I = r(4460), R = r(9884), N = r(6835), $ = r(2118), j = r(1101), L = r(111), M = r(5245), D = r(2412), U = r(6608), F = r(81), z = r(9298), B = r(1734), q = r(2666);
    e.exports = { parse: o, valid: l, clean: u, inc: c, diff: d, major: h, minor: p, patch: f, prerelease: m, compare: g, rcompare: y, compareLoose: b, compareBuild: v, sort: _, rsort: w, gt: E, lt: x, eq: O, neq: S, gte: A, lte: k, cmp: T, coerce: P, Comparator: C, Range: I, satisfies: R, toComparators: N, maxSatisfying: $, minSatisfying: j, minVersion: L, validRange: M, outside: D, gtr: U, ltr: F, intersects: z, simplifyRange: B, subset: q, SemVer: i, re: a.re, src: a.src, tokens: a.t, SEMVER_SPEC_VERSION: n.SEMVER_SPEC_VERSION, RELEASE_TYPES: n.RELEASE_TYPES, compareIdentifiers: s.compareIdentifiers, rcompareIdentifiers: s.rcompareIdentifiers };
  };
  __namedExportsObject["__chunk_1017"] = (e, t, r) => {
    let a = r(4306);
    e.exports = (e2, t2) => {
      let r2 = a(e2, t2);
      return r2 ? r2.version : null;
    };
  };
  __namedExportsObject["__chunk_5268"] = (e, t, r) => {
    let a = r(39);
    e.exports = (e2, t2) => e2.sort((e3, r2) => a(e3, r2, t2));
  };
  __namedExportsObject["__chunk_9884"] = (e, t, r) => {
    let a = r(4460);
    e.exports = (e2, t2, r2) => {
      try {
        t2 = new a(t2, r2);
      } catch (e3) {
        return false;
      }
      return t2.test(e2);
    };
  };
  __namedExportsObject["__chunk_6096"] = (e, t, r) => {
    let a = r(39);
    e.exports = (e2, t2) => e2.sort((e3, r2) => a(r2, e3, t2));
  };
  __namedExportsObject["__chunk_6123"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => a(t2, e2, r2);
  };
  __namedExportsObject["__chunk_9772"] = (e, t, r) => {
    let a = r(4306);
    e.exports = (e2, t2) => {
      let r2 = a(e2, t2);
      return r2 && r2.prerelease.length ? r2.prerelease : null;
    };
  };
  __namedExportsObject["__chunk_4948"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2) => new a(e2, t2).patch;
  };
  __namedExportsObject["__chunk_4306"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2, r2 = false) => {
      if (e2 instanceof a)
        return e2;
      try {
        return new a(e2, t2);
      } catch (e3) {
        if (!r2)
          return null;
        throw e3;
      }
    };
  };
  __namedExportsObject["__chunk_3371"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => 0 !== a(e2, t2, r2);
  };
  __namedExportsObject["__chunk_1"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2) => new a(e2, t2).minor;
  };
  __namedExportsObject["__chunk_7066"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2) => new a(e2, t2).major;
  };
  __namedExportsObject["__chunk_6628"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => 0 >= a(e2, t2, r2);
  };
  __namedExportsObject["__chunk_9853"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => 0 > a(e2, t2, r2);
  };
  __namedExportsObject["__chunk_1049"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2, r2, n, i) => {
      "string" == typeof r2 && (i = n, n = r2, r2 = void 0);
      try {
        return new a(e2 instanceof a ? e2.version : e2, r2).inc(t2, n, i).version;
      } catch (e3) {
        return null;
      }
    };
  };
  __namedExportsObject["__chunk_4420"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => a(e2, t2, r2) >= 0;
  };
  __namedExportsObject["__chunk_5692"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => a(e2, t2, r2) > 0;
  };
  __namedExportsObject["__chunk_4405"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2, r2) => 0 === a(e2, t2, r2);
  };
  __namedExportsObject["__chunk_5092"] = (e, t, r) => {
    let a = r(4306);
    e.exports = (e2, t2) => {
      let r2 = a(e2, null, true), n = a(t2, null, true), i = r2.compare(n);
      if (0 === i)
        return null;
      let s = i > 0, o = s ? r2 : n, l = s ? n : r2, u = !!o.prerelease.length;
      if (l.prerelease.length && !u)
        return l.patch || l.minor ? o.patch ? "patch" : o.minor ? "minor" : "major" : "major";
      let c = u ? "pre" : "";
      return r2.major !== n.major ? c + "major" : r2.minor !== n.minor ? c + "minor" : r2.patch !== n.patch ? c + "patch" : "prerelease";
    };
  };
  __namedExportsObject["__chunk_7512"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2, r2) => new a(e2, r2).compare(new a(t2, r2));
  };
  __namedExportsObject["__chunk_3344"] = (e, t, r) => {
    let a = r(7512);
    e.exports = (e2, t2) => a(e2, t2, true);
  };
  __namedExportsObject["__chunk_39"] = (e, t, r) => {
    let a = r(4234);
    e.exports = (e2, t2, r2) => {
      let n = new a(e2, r2), i = new a(t2, r2);
      return n.compare(i) || n.compareBuild(i);
    };
  };
  __namedExportsObject["__chunk_3167"] = (e, t, r) => {
    let a = r(4234), n = r(4306), { safeRe: i, t: s } = r(2385);
    e.exports = (e2, t2) => {
      if (e2 instanceof a)
        return e2;
      if ("number" == typeof e2 && (e2 = String(e2)), "string" != typeof e2)
        return null;
      let r2 = null;
      if ((t2 = t2 || {}).rtl) {
        let a2;
        let n2 = t2.includePrerelease ? i[s.COERCERTLFULL] : i[s.COERCERTL];
        for (; (a2 = n2.exec(e2)) && (!r2 || r2.index + r2[0].length !== e2.length); )
          r2 && a2.index + a2[0].length === r2.index + r2[0].length || (r2 = a2), n2.lastIndex = a2.index + a2[1].length + a2[2].length;
        n2.lastIndex = -1;
      } else
        r2 = e2.match(t2.includePrerelease ? i[s.COERCEFULL] : i[s.COERCE]);
      if (null === r2)
        return null;
      let o = r2[2], l = r2[3] || "0", u = r2[4] || "0", c = t2.includePrerelease && r2[5] ? `-${r2[5]}` : "", d = t2.includePrerelease && r2[6] ? `+${r2[6]}` : "";
      return n(`${o}.${l}.${u}${c}${d}`, t2);
    };
  };
  __namedExportsObject["__chunk_4579"] = (e, t, r) => {
    let a = r(4405), n = r(3371), i = r(5692), s = r(4420), o = r(9853), l = r(6628);
    e.exports = (e2, t2, r2, u) => {
      switch (t2) {
        case "===":
          return "object" == typeof e2 && (e2 = e2.version), "object" == typeof r2 && (r2 = r2.version), e2 === r2;
        case "!==":
          return "object" == typeof e2 && (e2 = e2.version), "object" == typeof r2 && (r2 = r2.version), e2 !== r2;
        case "":
        case "=":
        case "==":
          return a(e2, r2, u);
        case "!=":
          return n(e2, r2, u);
        case ">":
          return i(e2, r2, u);
        case ">=":
          return s(e2, r2, u);
        case "<":
          return o(e2, r2, u);
        case "<=":
          return l(e2, r2, u);
        default:
          throw TypeError(`Invalid operator: ${t2}`);
      }
    };
  };
  __namedExportsObject["__chunk_3624"] = (e, t, r) => {
    let a = r(4306);
    e.exports = (e2, t2) => {
      let r2 = a(e2.trim().replace(/^[=v]+/, ""), t2);
      return r2 ? r2.version : null;
    };
  };
  __namedExportsObject["__chunk_4234"] = (e, t, r) => {
    let a = r(2109), { MAX_LENGTH: n, MAX_SAFE_INTEGER: i } = r(7803), { safeRe: s, t: o } = r(2385), l = r(2409), { compareIdentifiers: u } = r(8858);
    class c {
      constructor(e2, t2) {
        if (t2 = l(t2), e2 instanceof c) {
          if (!!t2.loose === e2.loose && !!t2.includePrerelease === e2.includePrerelease)
            return e2;
          e2 = e2.version;
        } else if ("string" != typeof e2)
          throw TypeError(`Invalid version. Must be a string. Got type "${typeof e2}".`);
        if (e2.length > n)
          throw TypeError(`version is longer than ${n} characters`);
        a("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
        let r2 = e2.trim().match(t2.loose ? s[o.LOOSE] : s[o.FULL]);
        if (!r2)
          throw TypeError(`Invalid Version: ${e2}`);
        if (this.raw = e2, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > i || this.major < 0)
          throw TypeError("Invalid major version");
        if (this.minor > i || this.minor < 0)
          throw TypeError("Invalid minor version");
        if (this.patch > i || this.patch < 0)
          throw TypeError("Invalid patch version");
        r2[4] ? this.prerelease = r2[4].split(".").map((e3) => {
          if (/^[0-9]+$/.test(e3)) {
            let t3 = +e3;
            if (t3 >= 0 && t3 < i)
              return t3;
          }
          return e3;
        }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e2) {
        if (a("SemVer.compare", this.version, this.options, e2), !(e2 instanceof c)) {
          if ("string" == typeof e2 && e2 === this.version)
            return 0;
          e2 = new c(e2, this.options);
        }
        return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
      }
      compareMain(e2) {
        return e2 instanceof c || (e2 = new c(e2, this.options)), u(this.major, e2.major) || u(this.minor, e2.minor) || u(this.patch, e2.patch);
      }
      comparePre(e2) {
        if (e2 instanceof c || (e2 = new c(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
          return -1;
        if (!this.prerelease.length && e2.prerelease.length)
          return 1;
        if (!this.prerelease.length && !e2.prerelease.length)
          return 0;
        let t2 = 0;
        do {
          let r2 = this.prerelease[t2], n2 = e2.prerelease[t2];
          if (a("prerelease compare", t2, r2, n2), void 0 === r2 && void 0 === n2)
            return 0;
          if (void 0 === n2)
            return 1;
          if (void 0 === r2)
            return -1;
          if (r2 === n2)
            continue;
          else
            return u(r2, n2);
        } while (++t2);
      }
      compareBuild(e2) {
        e2 instanceof c || (e2 = new c(e2, this.options));
        let t2 = 0;
        do {
          let r2 = this.build[t2], n2 = e2.build[t2];
          if (a("build compare", t2, r2, n2), void 0 === r2 && void 0 === n2)
            return 0;
          if (void 0 === n2)
            return 1;
          if (void 0 === r2)
            return -1;
          if (r2 === n2)
            continue;
          else
            return u(r2, n2);
        } while (++t2);
      }
      inc(e2, t2, r2) {
        switch (e2) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2, r2);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2, r2);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t2, r2), this.inc("pre", t2, r2);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", t2, r2), this.inc("pre", t2, r2);
            break;
          case "major":
            (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            (0 !== this.patch || 0 === this.prerelease.length) && this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre": {
            let e3 = Number(r2) ? 1 : 0;
            if (!t2 && false === r2)
              throw Error("invalid increment argument: identifier is empty");
            if (0 === this.prerelease.length)
              this.prerelease = [e3];
            else {
              let a2 = this.prerelease.length;
              for (; --a2 >= 0; )
                "number" == typeof this.prerelease[a2] && (this.prerelease[a2]++, a2 = -2);
              if (-1 === a2) {
                if (t2 === this.prerelease.join(".") && false === r2)
                  throw Error("invalid increment argument: identifier already exists");
                this.prerelease.push(e3);
              }
            }
            if (t2) {
              let a2 = [t2, e3];
              false === r2 && (a2 = [t2]), 0 === u(this.prerelease[0], t2) ? isNaN(this.prerelease[1]) && (this.prerelease = a2) : this.prerelease = a2;
            }
            break;
          }
          default:
            throw Error(`invalid increment argument: ${e2}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    }
    e.exports = c;
  };
  __namedExportsObject["__chunk_4460"] = (e, t, r) => {
    let a = /\s+/g;
    class n {
      constructor(e2, t2) {
        if (t2 = s(t2), e2 instanceof n) {
          if (!!t2.loose === e2.loose && !!t2.includePrerelease === e2.includePrerelease)
            return e2;
          return new n(e2.raw, t2);
        }
        if (e2 instanceof o)
          return this.raw = e2.value, this.set = [[e2]], this.formatted = void 0, this;
        if (this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease, this.raw = e2.trim().replace(a, " "), this.set = this.raw.split("||").map((e3) => this.parseRange(e3.trim())).filter((e3) => e3.length), !this.set.length)
          throw TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          let e3 = this.set[0];
          if (this.set = this.set.filter((e4) => !y(e4[0])), 0 === this.set.length)
            this.set = [e3];
          else if (this.set.length > 1) {
            for (let e4 of this.set)
              if (1 === e4.length && b(e4[0])) {
                this.set = [e4];
                break;
              }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (void 0 === this.formatted) {
          this.formatted = "";
          for (let e2 = 0; e2 < this.set.length; e2++) {
            e2 > 0 && (this.formatted += "||");
            let t2 = this.set[e2];
            for (let e3 = 0; e3 < t2.length; e3++)
              e3 > 0 && (this.formatted += " "), this.formatted += t2[e3].toString().trim();
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(e2) {
        let t2 = ((this.options.includePrerelease && m) | (this.options.loose && g)) + ":" + e2, r2 = i.get(t2);
        if (r2)
          return r2;
        let a2 = this.options.loose, n2 = a2 ? c[d.HYPHENRANGELOOSE] : c[d.HYPHENRANGE];
        l("hyphen replace", e2 = e2.replace(n2, C(this.options.includePrerelease))), l("comparator trim", e2 = e2.replace(c[d.COMPARATORTRIM], h)), l("tilde trim", e2 = e2.replace(c[d.TILDETRIM], p)), l("caret trim", e2 = e2.replace(c[d.CARETTRIM], f));
        let s2 = e2.split(" ").map((e3) => _(e3, this.options)).join(" ").split(/\s+/).map((e3) => P(e3, this.options));
        a2 && (s2 = s2.filter((e3) => (l("loose invalid filter", e3, this.options), !!e3.match(c[d.COMPARATORLOOSE])))), l("range list", s2);
        let u2 = /* @__PURE__ */ new Map();
        for (let e3 of s2.map((e4) => new o(e4, this.options))) {
          if (y(e3))
            return [e3];
          u2.set(e3.value, e3);
        }
        u2.size > 1 && u2.has("") && u2.delete("");
        let b2 = [...u2.values()];
        return i.set(t2, b2), b2;
      }
      intersects(e2, t2) {
        if (!(e2 instanceof n))
          throw TypeError("a Range is required");
        return this.set.some((r2) => v(r2, t2) && e2.set.some((e3) => v(e3, t2) && r2.every((r3) => e3.every((e4) => r3.intersects(e4, t2)))));
      }
      test(e2) {
        if (!e2)
          return false;
        if ("string" == typeof e2)
          try {
            e2 = new u(e2, this.options);
          } catch (e3) {
            return false;
          }
        for (let t2 = 0; t2 < this.set.length; t2++)
          if (I(this.set[t2], e2, this.options))
            return true;
        return false;
      }
    }
    e.exports = n;
    let i = new (r(5712))(), s = r(2409), o = r(7779), l = r(2109), u = r(4234), { safeRe: c, t: d, comparatorTrimReplace: h, tildeTrimReplace: p, caretTrimReplace: f } = r(2385), { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: g } = r(7803), y = (e2) => "<0.0.0-0" === e2.value, b = (e2) => "" === e2.value, v = (e2, t2) => {
      let r2 = true, a2 = e2.slice(), n2 = a2.pop();
      for (; r2 && a2.length; )
        r2 = a2.every((e3) => n2.intersects(e3, t2)), n2 = a2.pop();
      return r2;
    }, _ = (e2, t2) => (l("comp", e2, t2), l("caret", e2 = O(e2, t2)), l("tildes", e2 = E(e2, t2)), l("xrange", e2 = A(e2, t2)), l("stars", e2 = T(e2, t2)), e2), w = (e2) => !e2 || "x" === e2.toLowerCase() || "*" === e2, E = (e2, t2) => e2.trim().split(/\s+/).map((e3) => x(e3, t2)).join(" "), x = (e2, t2) => {
      let r2 = t2.loose ? c[d.TILDELOOSE] : c[d.TILDE];
      return e2.replace(r2, (t3, r3, a2, n2, i2) => {
        let s2;
        return l("tilde", e2, t3, r3, a2, n2, i2), w(r3) ? s2 = "" : w(a2) ? s2 = `>=${r3}.0.0 <${+r3 + 1}.0.0-0` : w(n2) ? s2 = `>=${r3}.${a2}.0 <${r3}.${+a2 + 1}.0-0` : i2 ? (l("replaceTilde pr", i2), s2 = `>=${r3}.${a2}.${n2}-${i2} <${r3}.${+a2 + 1}.0-0`) : s2 = `>=${r3}.${a2}.${n2} <${r3}.${+a2 + 1}.0-0`, l("tilde return", s2), s2;
      });
    }, O = (e2, t2) => e2.trim().split(/\s+/).map((e3) => S(e3, t2)).join(" "), S = (e2, t2) => {
      l("caret", e2, t2);
      let r2 = t2.loose ? c[d.CARETLOOSE] : c[d.CARET], a2 = t2.includePrerelease ? "-0" : "";
      return e2.replace(r2, (t3, r3, n2, i2, s2) => {
        let o2;
        return l("caret", e2, t3, r3, n2, i2, s2), w(r3) ? o2 = "" : w(n2) ? o2 = `>=${r3}.0.0${a2} <${+r3 + 1}.0.0-0` : w(i2) ? o2 = "0" === r3 ? `>=${r3}.${n2}.0${a2} <${r3}.${+n2 + 1}.0-0` : `>=${r3}.${n2}.0${a2} <${+r3 + 1}.0.0-0` : s2 ? (l("replaceCaret pr", s2), o2 = "0" === r3 ? "0" === n2 ? `>=${r3}.${n2}.${i2}-${s2} <${r3}.${n2}.${+i2 + 1}-0` : `>=${r3}.${n2}.${i2}-${s2} <${r3}.${+n2 + 1}.0-0` : `>=${r3}.${n2}.${i2}-${s2} <${+r3 + 1}.0.0-0`) : (l("no pr"), o2 = "0" === r3 ? "0" === n2 ? `>=${r3}.${n2}.${i2}${a2} <${r3}.${n2}.${+i2 + 1}-0` : `>=${r3}.${n2}.${i2}${a2} <${r3}.${+n2 + 1}.0-0` : `>=${r3}.${n2}.${i2} <${+r3 + 1}.0.0-0`), l("caret return", o2), o2;
      });
    }, A = (e2, t2) => (l("replaceXRanges", e2, t2), e2.split(/\s+/).map((e3) => k(e3, t2)).join(" ")), k = (e2, t2) => {
      e2 = e2.trim();
      let r2 = t2.loose ? c[d.XRANGELOOSE] : c[d.XRANGE];
      return e2.replace(r2, (r3, a2, n2, i2, s2, o2) => {
        l("xRange", e2, r3, a2, n2, i2, s2, o2);
        let u2 = w(n2), c2 = u2 || w(i2), d2 = c2 || w(s2);
        return "=" === a2 && d2 && (a2 = ""), o2 = t2.includePrerelease ? "-0" : "", u2 ? r3 = ">" === a2 || "<" === a2 ? "<0.0.0-0" : "*" : a2 && d2 ? (c2 && (i2 = 0), s2 = 0, ">" === a2 ? (a2 = ">=", c2 ? (n2 = +n2 + 1, i2 = 0) : i2 = +i2 + 1, s2 = 0) : "<=" === a2 && (a2 = "<", c2 ? n2 = +n2 + 1 : i2 = +i2 + 1), "<" === a2 && (o2 = "-0"), r3 = `${a2 + n2}.${i2}.${s2}${o2}`) : c2 ? r3 = `>=${n2}.0.0${o2} <${+n2 + 1}.0.0-0` : d2 && (r3 = `>=${n2}.${i2}.0${o2} <${n2}.${+i2 + 1}.0-0`), l("xRange return", r3), r3;
      });
    }, T = (e2, t2) => (l("replaceStars", e2, t2), e2.trim().replace(c[d.STAR], "")), P = (e2, t2) => (l("replaceGTE0", e2, t2), e2.trim().replace(c[t2.includePrerelease ? d.GTE0PRE : d.GTE0], "")), C = (e2) => (t2, r2, a2, n2, i2, s2, o2, l2, u2, c2, d2, h2) => (r2 = w(a2) ? "" : w(n2) ? `>=${a2}.0.0${e2 ? "-0" : ""}` : w(i2) ? `>=${a2}.${n2}.0${e2 ? "-0" : ""}` : s2 ? `>=${r2}` : `>=${r2}${e2 ? "-0" : ""}`, l2 = w(u2) ? "" : w(c2) ? `<${+u2 + 1}.0.0-0` : w(d2) ? `<${u2}.${+c2 + 1}.0-0` : h2 ? `<=${u2}.${c2}.${d2}-${h2}` : e2 ? `<${u2}.${c2}.${+d2 + 1}-0` : `<=${l2}`, `${r2} ${l2}`.trim()), I = (e2, t2, r2) => {
      for (let r3 = 0; r3 < e2.length; r3++)
        if (!e2[r3].test(t2))
          return false;
      if (t2.prerelease.length && !r2.includePrerelease) {
        for (let r3 = 0; r3 < e2.length; r3++)
          if (l(e2[r3].semver), e2[r3].semver !== o.ANY && e2[r3].semver.prerelease.length > 0) {
            let a2 = e2[r3].semver;
            if (a2.major === t2.major && a2.minor === t2.minor && a2.patch === t2.patch)
              return true;
          }
        return false;
      }
      return true;
    };
  };
  __namedExportsObject["__chunk_7779"] = (e, t, r) => {
    let a = Symbol("SemVer ANY");
    class n {
      static get ANY() {
        return a;
      }
      constructor(e2, t2) {
        if (t2 = i(t2), e2 instanceof n) {
          if (!!t2.loose === e2.loose)
            return e2;
          e2 = e2.value;
        }
        u("comparator", e2 = e2.trim().split(/\s+/).join(" "), t2), this.options = t2, this.loose = !!t2.loose, this.parse(e2), this.semver === a ? this.value = "" : this.value = this.operator + this.semver.version, u("comp", this);
      }
      parse(e2) {
        let t2 = this.options.loose ? s[o.COMPARATORLOOSE] : s[o.COMPARATOR], r2 = e2.match(t2);
        if (!r2)
          throw TypeError(`Invalid comparator: ${e2}`);
        this.operator = void 0 !== r2[1] ? r2[1] : "", "=" === this.operator && (this.operator = ""), r2[2] ? this.semver = new c(r2[2], this.options.loose) : this.semver = a;
      }
      toString() {
        return this.value;
      }
      test(e2) {
        if (u("Comparator.test", e2, this.options.loose), this.semver === a || e2 === a)
          return true;
        if ("string" == typeof e2)
          try {
            e2 = new c(e2, this.options);
          } catch (e3) {
            return false;
          }
        return l(e2, this.operator, this.semver, this.options);
      }
      intersects(e2, t2) {
        if (!(e2 instanceof n))
          throw TypeError("a Comparator is required");
        return "" === this.operator ? "" === this.value || new d(e2.value, t2).test(this.value) : "" === e2.operator ? "" === e2.value || new d(this.value, t2).test(e2.semver) : !((t2 = i(t2)).includePrerelease && ("<0.0.0-0" === this.value || "<0.0.0-0" === e2.value) || !t2.includePrerelease && (this.value.startsWith("<0.0.0") || e2.value.startsWith("<0.0.0"))) && !!(this.operator.startsWith(">") && e2.operator.startsWith(">") || this.operator.startsWith("<") && e2.operator.startsWith("<") || this.semver.version === e2.semver.version && this.operator.includes("=") && e2.operator.includes("=") || l(this.semver, "<", e2.semver, t2) && this.operator.startsWith(">") && e2.operator.startsWith("<") || l(this.semver, ">", e2.semver, t2) && this.operator.startsWith("<") && e2.operator.startsWith(">"));
      }
    }
    e.exports = n;
    let i = r(2409), { safeRe: s, t: o } = r(2385), l = r(4579), u = r(2109), c = r(4234), d = r(4460);
  };
  __namedExportsObject["__chunk_1621"] = (e) => {
    function t(e2, t2) {
      "boolean" == typeof t2 && (t2 = { forever: t2 }), this._originalTimeouts = JSON.parse(JSON.stringify(e2)), this._timeouts = e2, this._options = t2 || {}, this._maxRetryTime = t2 && t2.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
    }
    e.exports = t, t.prototype.reset = function() {
      this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
    }, t.prototype.stop = function() {
      this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
    }, t.prototype.retry = function(e2) {
      if (this._timeout && clearTimeout(this._timeout), !e2)
        return false;
      var t2 = new Date().getTime();
      if (e2 && t2 - this._operationStart >= this._maxRetryTime)
        return this._errors.push(e2), this._errors.unshift(Error("RetryOperation timeout occurred")), false;
      this._errors.push(e2);
      var r = this._timeouts.shift();
      if (void 0 === r) {
        if (!this._cachedTimeouts)
          return false;
        this._errors.splice(0, this._errors.length - 1), r = this._cachedTimeouts.slice(-1);
      }
      var a = this;
      return this._timer = setTimeout(function() {
        a._attempts++, a._operationTimeoutCb && (a._timeout = setTimeout(function() {
          a._operationTimeoutCb(a._attempts);
        }, a._operationTimeout), a._options.unref && a._timeout.unref()), a._fn(a._attempts);
      }, r), this._options.unref && this._timer.unref(), true;
    }, t.prototype.attempt = function(e2, t2) {
      this._fn = e2, t2 && (t2.timeout && (this._operationTimeout = t2.timeout), t2.cb && (this._operationTimeoutCb = t2.cb));
      var r = this;
      this._operationTimeoutCb && (this._timeout = setTimeout(function() {
        r._operationTimeoutCb();
      }, r._operationTimeout)), this._operationStart = new Date().getTime(), this._fn(this._attempts);
    }, t.prototype.try = function(e2) {
      console.log("Using RetryOperation.try() is deprecated"), this.attempt(e2);
    }, t.prototype.start = function(e2) {
      console.log("Using RetryOperation.start() is deprecated"), this.attempt(e2);
    }, t.prototype.start = t.prototype.try, t.prototype.errors = function() {
      return this._errors;
    }, t.prototype.attempts = function() {
      return this._attempts;
    }, t.prototype.mainError = function() {
      if (0 === this._errors.length)
        return null;
      for (var e2 = {}, t2 = null, r = 0, a = 0; a < this._errors.length; a++) {
        var n = this._errors[a], i = n.message, s = (e2[i] || 0) + 1;
        e2[i] = s, s >= r && (t2 = n, r = s);
      }
      return t2;
    };
  };
  __namedExportsObject["__chunk_526"] = (e, t, r) => {
    var a = r(1621);
    t.operation = function(e2) {
      return new a(t.timeouts(e2), { forever: e2 && (e2.forever || e2.retries === 1 / 0), unref: e2 && e2.unref, maxRetryTime: e2 && e2.maxRetryTime });
    }, t.timeouts = function(e2) {
      if (e2 instanceof Array)
        return [].concat(e2);
      var t2 = { retries: 10, factor: 2, minTimeout: 1e3, maxTimeout: 1 / 0, randomize: false };
      for (var r2 in e2)
        t2[r2] = e2[r2];
      if (t2.minTimeout > t2.maxTimeout)
        throw Error("minTimeout is greater than maxTimeout");
      for (var a2 = [], n = 0; n < t2.retries; n++)
        a2.push(this.createTimeout(n, t2));
      return e2 && e2.forever && !a2.length && a2.push(this.createTimeout(n, t2)), a2.sort(function(e3, t3) {
        return e3 - t3;
      }), a2;
    }, t.createTimeout = function(e2, t2) {
      return Math.min(Math.round((t2.randomize ? Math.random() + 1 : 1) * Math.max(t2.minTimeout, 1) * Math.pow(t2.factor, e2)), t2.maxTimeout);
    }, t.wrap = function(e2, r2, a2) {
      if (r2 instanceof Array && (a2 = r2, r2 = null), !a2)
        for (var n in a2 = [], e2)
          "function" == typeof e2[n] && a2.push(n);
      for (var i = 0; i < a2.length; i++) {
        var s = a2[i], o = e2[s];
        e2[s] = function(a3) {
          var n2 = t.operation(r2), i2 = Array.prototype.slice.call(arguments, 1), s2 = i2.pop();
          i2.push(function(e3) {
            n2.retry(e3) || (e3 && (arguments[0] = n2.mainError()), s2.apply(this, arguments));
          }), n2.attempt(function() {
            a3.apply(e2, i2);
          });
        }.bind(e2, o), e2[s].options = r2;
      }
    };
  };
  __namedExportsObject["__chunk_5661"] = (e, t, r) => {
    e.exports = r(526);
  };
  __namedExportsObject["__chunk_9011"] = (e, t, r) => {
    "use strict";
    let a = r(8050);
    class n extends Error {
      constructor(e2) {
        super(e2), this.name = "TimeoutError";
      }
    }
    let i = (e2, t2, r2) => new Promise((i2, s) => {
      if ("number" != typeof t2 || t2 < 0)
        throw TypeError("Expected `milliseconds` to be a positive number");
      if (t2 === 1 / 0) {
        i2(e2);
        return;
      }
      let o = setTimeout(() => {
        if ("function" == typeof r2) {
          try {
            i2(r2());
          } catch (e3) {
            s(e3);
          }
          return;
        }
        let a2 = "string" == typeof r2 ? r2 : `Promise timed out after ${t2} milliseconds`, o2 = r2 instanceof Error ? r2 : new n(a2);
        "function" == typeof e2.cancel && e2.cancel(), s(o2);
      }, t2);
      a(e2.then(i2, s), () => {
        clearTimeout(o);
      });
    });
    e.exports = i, e.exports.default = i, e.exports.TimeoutError = n;
  };
  __namedExportsObject["__chunk_4779"] = (e, t, r) => {
    "use strict";
    let a = r(5661), n = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"];
    class i extends Error {
      constructor(e2) {
        super(), e2 instanceof Error ? (this.originalError = e2, { message: e2 } = e2) : (this.originalError = Error(e2), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e2;
      }
    }
    let s = (e2, t2, r2) => {
      let a2 = r2.retries - (t2 - 1);
      return e2.attemptNumber = t2, e2.retriesLeft = a2, e2;
    }, o = (e2) => n.includes(e2), l = (e2, t2) => new Promise((r2, n2) => {
      t2 = { onFailedAttempt: () => {
      }, retries: 10, ...t2 };
      let l2 = a.operation(t2);
      l2.attempt(async (a2) => {
        try {
          r2(await e2(a2));
        } catch (e3) {
          if (!(e3 instanceof Error)) {
            n2(TypeError(`Non-error was thrown: "${e3}". You should only throw errors.`));
            return;
          }
          if (e3 instanceof i)
            l2.stop(), n2(e3.originalError);
          else if (e3 instanceof TypeError && !o(e3.message))
            l2.stop(), n2(e3);
          else {
            s(e3, a2, t2);
            try {
              await t2.onFailedAttempt(e3);
            } catch (e4) {
              n2(e4);
              return;
            }
            l2.retry(e3) || n2(l2.mainError());
          }
        }
      });
    });
    e.exports = l, e.exports.default = l, e.exports.AbortError = i;
  };
  __namedExportsObject["__chunk_4186"] = (e, t, r) => {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: true });
    let a = r(5208);
    class n {
      constructor() {
        this._queue = [];
      }
      enqueue(e2, t2) {
        let r2 = { priority: (t2 = Object.assign({ priority: 0 }, t2)).priority, run: e2 };
        if (this.size && this._queue[this.size - 1].priority >= t2.priority) {
          this._queue.push(r2);
          return;
        }
        let n2 = a.default(this._queue, r2, (e3, t3) => t3.priority - e3.priority);
        this._queue.splice(n2, 0, r2);
      }
      dequeue() {
        let e2 = this._queue.shift();
        return null == e2 ? void 0 : e2.run;
      }
      filter(e2) {
        return this._queue.filter((t2) => t2.priority === e2.priority).map((e3) => e3.run);
      }
      get size() {
        return this._queue.length;
      }
    }
    t.default = n;
  };
  __namedExportsObject["__chunk_5208"] = (e, t) => {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e2, t2, r) {
      let a = 0, n = e2.length;
      for (; n > 0; ) {
        let i = n / 2 | 0, s = a + i;
        0 >= r(e2[s], t2) ? (a = ++s, n -= i + 1) : n = i;
      }
      return a;
    };
  };
  __namedExportsObject["__chunk_7439"] = (e, t, r) => {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: true });
    let a = r(3030), n = r(9011), i = r(4186), s = () => {
    }, o = new n.TimeoutError();
    class l extends a {
      constructor(e2) {
        var t2, r2, a2, n2;
        if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = s, this._resolveIdle = s, !("number" == typeof (e2 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: true, queueClass: i.default }, e2)).intervalCap && e2.intervalCap >= 1))
          throw TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${null !== (r2 = null === (t2 = e2.intervalCap) || void 0 === t2 ? void 0 : t2.toString()) && void 0 !== r2 ? r2 : ""}\` (${typeof e2.intervalCap})`);
        if (void 0 === e2.interval || !(Number.isFinite(e2.interval) && e2.interval >= 0))
          throw TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${null !== (n2 = null === (a2 = e2.interval) || void 0 === a2 ? void 0 : a2.toString()) && void 0 !== n2 ? n2 : ""}\` (${typeof e2.interval})`);
        this._carryoverConcurrencyCount = e2.carryoverConcurrencyCount, this._isIntervalIgnored = e2.intervalCap === 1 / 0 || 0 === e2.interval, this._intervalCap = e2.intervalCap, this._interval = e2.interval, this._queue = new e2.queueClass(), this._queueClass = e2.queueClass, this.concurrency = e2.concurrency, this._timeout = e2.timeout, this._throwOnTimeout = true === e2.throwOnTimeout, this._isPaused = false === e2.autoStart;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--, this._tryToStartAnother(), this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty(), this._resolveEmpty = s, 0 === this._pendingCount && (this._resolveIdle(), this._resolveIdle = s, this.emit("idle"));
      }
      _onResumeInterval() {
        this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        let e2 = Date.now();
        if (void 0 === this._intervalId) {
          let t2 = this._intervalEnd - e2;
          if (!(t2 < 0))
            return void 0 === this._timeoutId && (this._timeoutId = setTimeout(() => {
              this._onResumeInterval();
            }, t2)), true;
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        }
        return false;
      }
      _tryToStartAnother() {
        if (0 === this._queue.size)
          return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), false;
        if (!this._isPaused) {
          let e2 = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            let t2 = this._queue.dequeue();
            return !!t2 && (this.emit("active"), t2(), e2 && this._initializeIntervalIfNeeded(), true);
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        this._isIntervalIgnored || void 0 !== this._intervalId || (this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval), this._intervalEnd = Date.now() + this._interval);
      }
      _onInterval() {
        0 === this._intervalCount && 0 === this._pendingCount && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
      }
      _processQueue() {
        for (; this._tryToStartAnother(); )
          ;
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(e2) {
        if (!("number" == typeof e2 && e2 >= 1))
          throw TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e2}\` (${typeof e2})`);
        this._concurrency = e2, this._processQueue();
      }
      async add(e2, t2 = {}) {
        return new Promise((r2, a2) => {
          let i2 = async () => {
            this._pendingCount++, this._intervalCount++;
            try {
              let i3 = void 0 === this._timeout && void 0 === t2.timeout ? e2() : n.default(Promise.resolve(e2()), void 0 === t2.timeout ? this._timeout : t2.timeout, () => {
                (void 0 === t2.throwOnTimeout ? this._throwOnTimeout : t2.throwOnTimeout) && a2(o);
              });
              r2(await i3);
            } catch (e3) {
              a2(e3);
            }
            this._next();
          };
          this._queue.enqueue(i2, t2), this._tryToStartAnother(), this.emit("add");
        });
      }
      async addAll(e2, t2) {
        return Promise.all(e2.map(async (e3) => this.add(e3, t2)));
      }
      start() {
        return this._isPaused && (this._isPaused = false, this._processQueue()), this;
      }
      pause() {
        this._isPaused = true;
      }
      clear() {
        this._queue = new this._queueClass();
      }
      async onEmpty() {
        if (0 !== this._queue.size)
          return new Promise((e2) => {
            let t2 = this._resolveEmpty;
            this._resolveEmpty = () => {
              t2(), e2();
            };
          });
      }
      async onIdle() {
        if (0 !== this._pendingCount || 0 !== this._queue.size)
          return new Promise((e2) => {
            let t2 = this._resolveIdle;
            this._resolveIdle = () => {
              t2(), e2();
            };
          });
      }
      get size() {
        return this._queue.size;
      }
      sizeBy(e2) {
        return this._queue.filter(e2).length;
      }
      get pending() {
        return this._pendingCount;
      }
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      set timeout(e2) {
        this._timeout = e2;
      }
    }
    t.default = l;
  };
  __namedExportsObject["__chunk_8050"] = (e) => {
    "use strict";
    e.exports = (e2, t) => (t = t || (() => {
    }), e2.then((e3) => new Promise((e4) => {
      e4(t());
    }).then(() => e3), (e3) => new Promise((e4) => {
      e4(t());
    }).then(() => {
      throw e3;
    })));
  };
  __namedExportsObject["__chunk_1730"] = (e, t, r) => {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: true }), function(e2, t2) {
      for (var r2 in t2)
        Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
    }(t, { interceptTestApis: function() {
      return i;
    }, wrapRequestHandler: function() {
      return s;
    } });
    let a = r(7037), n = r(3818);
    function i() {
      return (0, n.interceptFetch)(r.g.fetch);
    }
    function s(e2) {
      return (t2, r2) => (0, a.withRequest)(t2, n.reader, () => e2(t2, r2));
    }
  };
  __namedExportsObject["__chunk_3818"] = (e, t, r) => {
    "use strict";
    var a = r(6195).Buffer;
    Object.defineProperty(t, "__esModule", { value: true }), function(e2, t2) {
      for (var r2 in t2)
        Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
    }(t, { handleFetch: function() {
      return o;
    }, interceptFetch: function() {
      return l;
    }, reader: function() {
      return i;
    } });
    let n = r(7037), i = { url: (e2) => e2.url, header: (e2, t2) => e2.headers.get(t2) };
    async function s(e2, t2) {
      let { url: r2, method: n2, headers: i2, body: s2, cache: o2, credentials: l2, integrity: u, mode: c, redirect: d, referrer: h, referrerPolicy: p } = t2;
      return { testData: e2, api: "fetch", request: { url: r2, method: n2, headers: [...Array.from(i2), ["next-test-stack", function() {
        let e3 = (Error().stack ?? "").split("\n");
        for (let t3 = 1; t3 < e3.length; t3++)
          if (e3[t3].length > 0) {
            e3 = e3.slice(t3);
            break;
          }
        return (e3 = (e3 = (e3 = e3.filter((e4) => !e4.includes("/next/dist/"))).slice(0, 5)).map((e4) => e4.replace("webpack-internal:///(rsc)/", "").trim())).join("    ");
      }()]], body: s2 ? a.from(await t2.arrayBuffer()).toString("base64") : null, cache: o2, credentials: l2, integrity: u, mode: c, redirect: d, referrer: h, referrerPolicy: p } };
    }
    async function o(e2, t2) {
      let r2 = (0, n.getTestReqInfo)(t2, i);
      if (!r2)
        return e2(t2);
      let { testData: o2, proxyPort: l2 } = r2, u = await s(o2, t2), c = await e2(`http://localhost:${l2}`, { method: "POST", body: JSON.stringify(u), next: { internal: true } });
      if (!c.ok)
        throw Error(`Proxy request failed: ${c.status}`);
      let d = await c.json(), { api: h } = d;
      switch (h) {
        case "continue":
          return e2(t2);
        case "abort":
        case "unhandled":
          throw Error(`Proxy request aborted [${t2.method} ${t2.url}]`);
      }
      return function(e3) {
        let { status: t3, headers: r3, body: n2 } = e3.response;
        return new Response(n2 ? a.from(n2, "base64") : null, { status: t3, headers: new Headers(r3) });
      }(d);
    }
    function l(e2) {
      return r.g.fetch = function(t2, r2) {
        var a2;
        return (null == r2 ? void 0 : null == (a2 = r2.next) ? void 0 : a2.internal) ? e2(t2, r2) : o(e2, new Request(t2, r2));
      }, () => {
        r.g.fetch = e2;
      };
    }
  };
  __namedExportsObject["__chunk_7037"] = (e, t, r) => {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: true }), function(e2, t2) {
      for (var r2 in t2)
        Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
    }(t, { getTestReqInfo: function() {
      return s;
    }, withRequest: function() {
      return i;
    } });
    let a = new (r(2067)).AsyncLocalStorage();
    function n(e2, t2) {
      let r2 = t2.header(e2, "next-test-proxy-port");
      if (r2)
        return { url: t2.url(e2), proxyPort: Number(r2), testData: t2.header(e2, "next-test-data") || "" };
    }
    function i(e2, t2, r2) {
      let i2 = n(e2, t2);
      return i2 ? a.run(i2, r2) : r2();
    }
    function s(e2, t2) {
      return a.getStore() || (e2 && t2 ? n(e2, t2) : void 0);
    }
  };
  __namedExportsObject["__chunk_5577"] = (e, t, r) => {
    "use strict";
    function a(e2) {
      return e2.replace(/\/$/, "") || "/";
    }
    r.d(t, { Q: () => a });
  };
  __namedExportsObject["__chunk_1863"] = (e, t, r) => {
    "use strict";
    let a;
    a = r(6914), e.exports = a;
  };
  __namedExportsObject["__chunk_3039"] = (e, t, r) => {
    "use strict";
    function a(e2, t2) {
      let r2;
      let a2 = e2.split("/");
      return (t2 || []).some((t3) => !!a2[1] && a2[1].toLowerCase() === t3.toLowerCase() && (r2 = t3, a2.splice(1, 1), e2 = a2.join("/") || "/", true)), { pathname: e2, detectedLocale: r2 };
    }
    r.d(t, { h: () => a });
  };
  __namedExportsObject["__chunk_9573"] = (e, t, r) => {
    "use strict";
    function a(e2) {
      let t2 = new Headers();
      for (let [r2, a2] of Object.entries(e2))
        for (let e3 of Array.isArray(a2) ? a2 : [a2])
          void 0 !== e3 && ("number" == typeof e3 && (e3 = e3.toString()), t2.append(r2, e3));
      return t2;
    }
    function n(e2) {
      var t2, r2, a2, n2, i2, s2 = [], o = 0;
      function l() {
        for (; o < e2.length && /\s/.test(e2.charAt(o)); )
          o += 1;
        return o < e2.length;
      }
      for (; o < e2.length; ) {
        for (t2 = o, i2 = false; l(); )
          if ("," === (r2 = e2.charAt(o))) {
            for (a2 = o, o += 1, l(), n2 = o; o < e2.length && "=" !== (r2 = e2.charAt(o)) && ";" !== r2 && "," !== r2; )
              o += 1;
            o < e2.length && "=" === e2.charAt(o) ? (i2 = true, o = n2, s2.push(e2.substring(t2, a2)), t2 = o) : o = a2 + 1;
          } else
            o += 1;
        (!i2 || o >= e2.length) && s2.push(e2.substring(t2, e2.length));
      }
      return s2;
    }
    function i(e2) {
      let t2 = {}, r2 = [];
      if (e2)
        for (let [a2, i2] of e2.entries())
          "set-cookie" === a2.toLowerCase() ? (r2.push(...n(i2)), t2[a2] = 1 === r2.length ? r2[0] : r2) : t2[a2] = i2;
      return t2;
    }
    function s(e2) {
      try {
        return String(new URL(String(e2)));
      } catch (t2) {
        throw Error(`URL is malformed "${String(e2)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, { cause: t2 });
      }
    }
    r.d(t, { EK: () => a, l$: () => n, lb: () => i, r4: () => s });
  };
  __namedExportsObject["__chunk_7701"] = (e, t, r) => {
    "use strict";
    r.d(t, { x: () => c });
    var a = r(4101), n = r(7444), i = r(9573), s = r(8042);
    let o = Symbol("internal response"), l = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function u(e2, t2) {
      var r2;
      if (null == e2 ? void 0 : null == (r2 = e2.request) ? void 0 : r2.headers) {
        if (!(e2.request.headers instanceof Headers))
          throw Error("request.headers must be an instance of Headers");
        let r3 = [];
        for (let [a2, n2] of e2.request.headers)
          t2.set("x-middleware-request-" + a2, n2), r3.push(a2);
        t2.set("x-middleware-override-headers", r3.join(","));
      }
    }
    class c extends Response {
      constructor(e2, t2 = {}) {
        super(e2, t2);
        let r2 = this.headers, l2 = new Proxy(new a.nV(r2), { get(e3, n2, i2) {
          switch (n2) {
            case "delete":
            case "set":
              return (...i3) => {
                let s2 = Reflect.apply(e3[n2], e3, i3), o2 = new Headers(r2);
                return s2 instanceof a.nV && r2.set("x-middleware-set-cookie", s2.getAll().map((e4) => (0, a.Q7)(e4)).join(",")), u(t2, o2), s2;
              };
            default:
              return s.g.get(e3, n2, i2);
          }
        } });
        this[o] = { cookies: l2, url: t2.url ? new n.c(t2.url, { headers: (0, i.lb)(r2), nextConfig: t2.nextConfig }) : void 0 };
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return { cookies: this.cookies, url: this.url, body: this.body, bodyUsed: this.bodyUsed, headers: Object.fromEntries(this.headers), ok: this.ok, redirected: this.redirected, status: this.status, statusText: this.statusText, type: this.type };
      }
      get cookies() {
        return this[o].cookies;
      }
      static json(e2, t2) {
        let r2 = Response.json(e2, t2);
        return new c(r2.body, r2);
      }
      static redirect(e2, t2) {
        let r2 = "number" == typeof t2 ? t2 : (null == t2 ? void 0 : t2.status) ?? 307;
        if (!l.has(r2))
          throw RangeError('Failed to execute "redirect" on "response": Invalid status code');
        let a2 = "object" == typeof t2 ? t2 : {}, n2 = new Headers(null == a2 ? void 0 : a2.headers);
        return n2.set("Location", (0, i.r4)(e2)), new c(null, { ...a2, headers: n2, status: r2 });
      }
      static rewrite(e2, t2) {
        let r2 = new Headers(null == t2 ? void 0 : t2.headers);
        return r2.set("x-middleware-rewrite", (0, i.r4)(e2)), u(t2, r2), new c(null, { ...t2, headers: r2 });
      }
      static next(e2) {
        let t2 = new Headers(null == e2 ? void 0 : e2.headers);
        return t2.set("x-middleware-next", "1"), u(e2, t2), new c(null, { ...e2, headers: t2 });
      }
    }
  };
  __namedExportsObject["__chunk_662"] = (e, t, r) => {
    "use strict";
    r.d(t, { I: () => l });
    var a = r(7444), n = r(9573), i = r(4591), s = r(4101);
    let o = Symbol("internal request");
    class l extends Request {
      constructor(e2, t2 = {}) {
        let r2 = "string" != typeof e2 && "url" in e2 ? e2.url : String(e2);
        (0, n.r4)(r2), e2 instanceof Request ? super(e2, t2) : super(r2, t2);
        let i2 = new a.c(r2, { headers: (0, n.lb)(this.headers), nextConfig: t2.nextConfig });
        this[o] = { cookies: new s.qC(this.headers), geo: t2.geo || {}, ip: t2.ip, nextUrl: i2, url: i2.toString() };
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return { cookies: this.cookies, geo: this.geo, ip: this.ip, nextUrl: this.nextUrl, url: this.url, bodyUsed: this.bodyUsed, cache: this.cache, credentials: this.credentials, destination: this.destination, headers: Object.fromEntries(this.headers), integrity: this.integrity, keepalive: this.keepalive, method: this.method, mode: this.mode, redirect: this.redirect, referrer: this.referrer, referrerPolicy: this.referrerPolicy, signal: this.signal };
      }
      get cookies() {
        return this[o].cookies;
      }
      get geo() {
        return this[o].geo;
      }
      get ip() {
        return this[o].ip;
      }
      get nextUrl() {
        return this[o].nextUrl;
      }
      get page() {
        throw new i.cR();
      }
      get ua() {
        throw new i.Y5();
      }
      get url() {
        return this[o].url;
      }
    }
  };
  __namedExportsObject["__chunk_4101"] = (e, t, r) => {
    "use strict";
    r.d(t, { Q7: () => a.stringifyCookie, nV: () => a.ResponseCookies, qC: () => a.RequestCookies });
    var a = r(676);
  };
  __namedExportsObject["__chunk_6776"] = (e, t, r) => {
    "use strict";
    r.d(t, { Qb: () => o, _5: () => u, vr: () => c });
    var a = r(4101), n = r(8042), i = r(9182);
    class s extends Error {
      constructor() {
        super("Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#cookiessetname-value-options");
      }
      static callable() {
        throw new s();
      }
    }
    class o {
      static seal(e2) {
        return new Proxy(e2, { get(e3, t2, r2) {
          switch (t2) {
            case "clear":
            case "delete":
            case "set":
              return s.callable;
            default:
              return n.g.get(e3, t2, r2);
          }
        } });
      }
    }
    let l = Symbol.for("next.mutated.cookies");
    function u(e2, t2) {
      let r2 = function(e3) {
        let t3 = e3[l];
        return t3 && Array.isArray(t3) && 0 !== t3.length ? t3 : [];
      }(t2);
      if (0 === r2.length)
        return false;
      let n2 = new a.nV(e2), i2 = n2.getAll();
      for (let e3 of r2)
        n2.set(e3);
      for (let e3 of i2)
        n2.set(e3);
      return true;
    }
    class c {
      static wrap(e2, t2) {
        let r2 = new a.nV(new Headers());
        for (let t3 of e2.getAll())
          r2.set(t3);
        let s2 = [], o2 = /* @__PURE__ */ new Set(), u2 = () => {
          let e3 = i.A.getStore();
          if (e3 && (e3.pathWasRevalidated = true), s2 = r2.getAll().filter((e4) => o2.has(e4.name)), t2) {
            let e4 = [];
            for (let t3 of s2) {
              let r3 = new a.nV(new Headers());
              r3.set(t3), e4.push(r3.toString());
            }
            t2(e4);
          }
        };
        return new Proxy(r2, { get(e3, t3, r3) {
          switch (t3) {
            case l:
              return s2;
            case "delete":
              return function(...t4) {
                o2.add("string" == typeof t4[0] ? t4[0] : t4[0].name);
                try {
                  e3.delete(...t4);
                } finally {
                  u2();
                }
              };
            case "set":
              return function(...t4) {
                o2.add("string" == typeof t4[0] ? t4[0] : t4[0].name);
                try {
                  return e3.set(...t4);
                } finally {
                  u2();
                }
              };
            default:
              return n.g.get(e3, t3, r3);
          }
        } });
      }
    }
  };
  __namedExportsObject["__chunk_8042"] = (e, t, r) => {
    "use strict";
    r.d(t, { g: () => a });
    class a {
      static get(e2, t2, r2) {
        let a2 = Reflect.get(e2, t2, r2);
        return "function" == typeof a2 ? a2.bind(e2) : a2;
      }
      static set(e2, t2, r2, a2) {
        return Reflect.set(e2, t2, r2, a2);
      }
      static has(e2, t2) {
        return Reflect.has(e2, t2);
      }
      static deleteProperty(e2, t2) {
        return Reflect.deleteProperty(e2, t2);
      }
    }
  };
  __namedExportsObject["__chunk_3665"] = (e, t, r) => {
    "use strict";
    r.d(t, { h: () => i });
    var a = r(8042);
    class n extends Error {
      constructor() {
        super("Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers");
      }
      static callable() {
        throw new n();
      }
    }
    class i extends Headers {
      constructor(e2) {
        super(), this.headers = new Proxy(e2, { get(t2, r2, n2) {
          if ("symbol" == typeof r2)
            return a.g.get(t2, r2, n2);
          let i2 = r2.toLowerCase(), s = Object.keys(e2).find((e3) => e3.toLowerCase() === i2);
          if (void 0 !== s)
            return a.g.get(t2, s, n2);
        }, set(t2, r2, n2, i2) {
          if ("symbol" == typeof r2)
            return a.g.set(t2, r2, n2, i2);
          let s = r2.toLowerCase(), o = Object.keys(e2).find((e3) => e3.toLowerCase() === s);
          return a.g.set(t2, o ?? r2, n2, i2);
        }, has(t2, r2) {
          if ("symbol" == typeof r2)
            return a.g.has(t2, r2);
          let n2 = r2.toLowerCase(), i2 = Object.keys(e2).find((e3) => e3.toLowerCase() === n2);
          return void 0 !== i2 && a.g.has(t2, i2);
        }, deleteProperty(t2, r2) {
          if ("symbol" == typeof r2)
            return a.g.deleteProperty(t2, r2);
          let n2 = r2.toLowerCase(), i2 = Object.keys(e2).find((e3) => e3.toLowerCase() === n2);
          return void 0 === i2 || a.g.deleteProperty(t2, i2);
        } });
      }
      static seal(e2) {
        return new Proxy(e2, { get(e3, t2, r2) {
          switch (t2) {
            case "append":
            case "delete":
            case "set":
              return n.callable;
            default:
              return a.g.get(e3, t2, r2);
          }
        } });
      }
      merge(e2) {
        return Array.isArray(e2) ? e2.join(", ") : e2;
      }
      static from(e2) {
        return e2 instanceof Headers ? e2 : new i(e2);
      }
      append(e2, t2) {
        let r2 = this.headers[e2];
        "string" == typeof r2 ? this.headers[e2] = [r2, t2] : Array.isArray(r2) ? r2.push(t2) : this.headers[e2] = t2;
      }
      delete(e2) {
        delete this.headers[e2];
      }
      get(e2) {
        let t2 = this.headers[e2];
        return void 0 !== t2 ? this.merge(t2) : null;
      }
      has(e2) {
        return void 0 !== this.headers[e2];
      }
      set(e2, t2) {
        this.headers[e2] = t2;
      }
      forEach(e2, t2) {
        for (let [r2, a2] of this.entries())
          e2.call(t2, a2, r2, this);
      }
      *entries() {
        for (let e2 of Object.keys(this.headers)) {
          let t2 = e2.toLowerCase(), r2 = this.get(t2);
          yield [t2, r2];
        }
      }
      *keys() {
        for (let e2 of Object.keys(this.headers)) {
          let t2 = e2.toLowerCase();
          yield t2;
        }
      }
      *values() {
        for (let e2 of Object.keys(this.headers)) {
          let t2 = this.get(e2);
          yield t2;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    }
  };
  __namedExportsObject["__chunk_7444"] = (e, t, r) => {
    "use strict";
    r.d(t, { c: () => h });
    var a = r(5577);
    function n(e2) {
      let t2 = e2.indexOf("#"), r2 = e2.indexOf("?"), a2 = r2 > -1 && (t2 < 0 || r2 < t2);
      return a2 || t2 > -1 ? { pathname: e2.substring(0, a2 ? r2 : t2), query: a2 ? e2.substring(r2, t2 > -1 ? t2 : void 0) : "", hash: t2 > -1 ? e2.slice(t2) : "" } : { pathname: e2, query: "", hash: "" };
    }
    function i(e2, t2) {
      if (!e2.startsWith("/") || !t2)
        return e2;
      let { pathname: r2, query: a2, hash: i2 } = n(e2);
      return "" + t2 + r2 + a2 + i2;
    }
    function s(e2, t2) {
      if (!e2.startsWith("/") || !t2)
        return e2;
      let { pathname: r2, query: a2, hash: i2 } = n(e2);
      return "" + r2 + t2 + a2 + i2;
    }
    function o(e2, t2) {
      if ("string" != typeof e2)
        return false;
      let { pathname: r2 } = n(e2);
      return r2 === t2 || r2.startsWith(t2 + "/");
    }
    var l = r(3039);
    let u = /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function c(e2, t2) {
      return new URL(String(e2).replace(u, "localhost"), t2 && String(t2).replace(u, "localhost"));
    }
    let d = Symbol("NextURLInternal");
    class h {
      constructor(e2, t2, r2) {
        let a2, n2;
        "object" == typeof t2 && "pathname" in t2 || "string" == typeof t2 ? (a2 = t2, n2 = r2 || {}) : n2 = r2 || t2 || {}, this[d] = { url: c(e2, a2 ?? n2.base), options: n2, basePath: "" }, this.analyze();
      }
      analyze() {
        var e2, t2, r2, a2, n2;
        let i2 = function(e3, t3) {
          var r3, a3;
          let { basePath: n3, i18n: i3, trailingSlash: s3 } = null != (r3 = t3.nextConfig) ? r3 : {}, u3 = { pathname: e3, trailingSlash: "/" !== e3 ? e3.endsWith("/") : s3 };
          n3 && o(u3.pathname, n3) && (u3.pathname = function(e4, t4) {
            if (!o(e4, t4))
              return e4;
            let r4 = e4.slice(t4.length);
            return r4.startsWith("/") ? r4 : "/" + r4;
          }(u3.pathname, n3), u3.basePath = n3);
          let c2 = u3.pathname;
          if (u3.pathname.startsWith("/_next/data/") && u3.pathname.endsWith(".json")) {
            let e4 = u3.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/"), r4 = e4[0];
            u3.buildId = r4, c2 = "index" !== e4[1] ? "/" + e4.slice(1).join("/") : "/", true === t3.parseData && (u3.pathname = c2);
          }
          if (i3) {
            let e4 = t3.i18nProvider ? t3.i18nProvider.analyze(u3.pathname) : (0, l.h)(u3.pathname, i3.locales);
            u3.locale = e4.detectedLocale, u3.pathname = null != (a3 = e4.pathname) ? a3 : u3.pathname, !e4.detectedLocale && u3.buildId && (e4 = t3.i18nProvider ? t3.i18nProvider.analyze(c2) : (0, l.h)(c2, i3.locales)).detectedLocale && (u3.locale = e4.detectedLocale);
          }
          return u3;
        }(this[d].url.pathname, { nextConfig: this[d].options.nextConfig, parseData: true, i18nProvider: this[d].options.i18nProvider }), s2 = function(e3, t3) {
          let r3;
          if ((null == t3 ? void 0 : t3.host) && !Array.isArray(t3.host))
            r3 = t3.host.toString().split(":", 1)[0];
          else {
            if (!e3.hostname)
              return;
            r3 = e3.hostname;
          }
          return r3.toLowerCase();
        }(this[d].url, this[d].options.headers);
        this[d].domainLocale = this[d].options.i18nProvider ? this[d].options.i18nProvider.detectDomainLocale(s2) : function(e3, t3, r3) {
          if (e3)
            for (let i3 of (r3 && (r3 = r3.toLowerCase()), e3)) {
              var a3, n3;
              if (t3 === (null == (a3 = i3.domain) ? void 0 : a3.split(":", 1)[0].toLowerCase()) || r3 === i3.defaultLocale.toLowerCase() || (null == (n3 = i3.locales) ? void 0 : n3.some((e4) => e4.toLowerCase() === r3)))
                return i3;
            }
        }(null == (t2 = this[d].options.nextConfig) ? void 0 : null == (e2 = t2.i18n) ? void 0 : e2.domains, s2);
        let u2 = (null == (r2 = this[d].domainLocale) ? void 0 : r2.defaultLocale) || (null == (n2 = this[d].options.nextConfig) ? void 0 : null == (a2 = n2.i18n) ? void 0 : a2.defaultLocale);
        this[d].url.pathname = i2.pathname, this[d].defaultLocale = u2, this[d].basePath = i2.basePath ?? "", this[d].buildId = i2.buildId, this[d].locale = i2.locale ?? u2, this[d].trailingSlash = i2.trailingSlash;
      }
      formatPathname() {
        var e2;
        let t2;
        return t2 = function(e3, t3, r2, a2) {
          if (!t3 || t3 === r2)
            return e3;
          let n2 = e3.toLowerCase();
          return !a2 && (o(n2, "/api") || o(n2, "/" + t3.toLowerCase())) ? e3 : i(e3, "/" + t3);
        }((e2 = { basePath: this[d].basePath, buildId: this[d].buildId, defaultLocale: this[d].options.forceLocale ? void 0 : this[d].defaultLocale, locale: this[d].locale, pathname: this[d].url.pathname, trailingSlash: this[d].trailingSlash }).pathname, e2.locale, e2.buildId ? void 0 : e2.defaultLocale, e2.ignorePrefix), (e2.buildId || !e2.trailingSlash) && (t2 = (0, a.Q)(t2)), e2.buildId && (t2 = s(i(t2, "/_next/data/" + e2.buildId), "/" === e2.pathname ? "index.json" : ".json")), t2 = i(t2, e2.basePath), !e2.buildId && e2.trailingSlash ? t2.endsWith("/") ? t2 : s(t2, "/") : (0, a.Q)(t2);
      }
      formatSearch() {
        return this[d].url.search;
      }
      get buildId() {
        return this[d].buildId;
      }
      set buildId(e2) {
        this[d].buildId = e2;
      }
      get locale() {
        return this[d].locale ?? "";
      }
      set locale(e2) {
        var t2, r2;
        if (!this[d].locale || !(null == (r2 = this[d].options.nextConfig) ? void 0 : null == (t2 = r2.i18n) ? void 0 : t2.locales.includes(e2)))
          throw TypeError(`The NextURL configuration includes no locale "${e2}"`);
        this[d].locale = e2;
      }
      get defaultLocale() {
        return this[d].defaultLocale;
      }
      get domainLocale() {
        return this[d].domainLocale;
      }
      get searchParams() {
        return this[d].url.searchParams;
      }
      get host() {
        return this[d].url.host;
      }
      set host(e2) {
        this[d].url.host = e2;
      }
      get hostname() {
        return this[d].url.hostname;
      }
      set hostname(e2) {
        this[d].url.hostname = e2;
      }
      get port() {
        return this[d].url.port;
      }
      set port(e2) {
        this[d].url.port = e2;
      }
      get protocol() {
        return this[d].url.protocol;
      }
      set protocol(e2) {
        this[d].url.protocol = e2;
      }
      get href() {
        let e2 = this.formatPathname(), t2 = this.formatSearch();
        return `${this.protocol}//${this.host}${e2}${t2}${this.hash}`;
      }
      set href(e2) {
        this[d].url = c(e2), this.analyze();
      }
      get origin() {
        return this[d].url.origin;
      }
      get pathname() {
        return this[d].url.pathname;
      }
      set pathname(e2) {
        this[d].url.pathname = e2;
      }
      get hash() {
        return this[d].url.hash;
      }
      set hash(e2) {
        this[d].url.hash = e2;
      }
      get search() {
        return this[d].url.search;
      }
      set search(e2) {
        this[d].url.search = e2;
      }
      get password() {
        return this[d].url.password;
      }
      set password(e2) {
        this[d].url.password = e2;
      }
      get username() {
        return this[d].url.username;
      }
      set username(e2) {
        this[d].url.username = e2;
      }
      get basePath() {
        return this[d].basePath;
      }
      set basePath(e2) {
        this[d].basePath = e2.startsWith("/") ? e2 : `/${e2}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return { href: this.href, origin: this.origin, protocol: this.protocol, username: this.username, password: this.password, host: this.host, hostname: this.hostname, port: this.port, pathname: this.pathname, search: this.search, searchParams: this.searchParams, hash: this.hash };
      }
      clone() {
        return new h(String(this), this[d].options);
      }
    }
  };
  __namedExportsObject["__chunk_4591"] = (e, t, r) => {
    "use strict";
    r.d(t, { Y5: () => i, cR: () => n, qJ: () => a });
    class a extends Error {
      constructor({ page: e2 }) {
        super(`The middleware "${e2}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
      }
    }
    class n extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    }
    class i extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    }
  };
  __namedExportsObject["__chunk_932"] = (e, t, r) => {
    "use strict";
    let a, n, i;
    async function s() {
      let e2 = "_ENTRIES" in globalThis && _ENTRIES.middleware_instrumentation && (await _ENTRIES.middleware_instrumentation).register;
      if (e2)
        try {
          await e2();
        } catch (e3) {
          throw e3.message = `An error occurred while loading instrumentation hook: ${e3.message}`, e3;
        }
    }
    r.d(t, { a: () => ew });
    let o = null;
    function l() {
      return o || (o = s()), o;
    }
    function u(e2) {
      return `The edge runtime does not support Node.js '${e2}' module.
Learn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime`;
    }
    process !== r.g.process && (process.env = r.g.process.env, r.g.process = process), Object.defineProperty(globalThis, "__import_unsupported", { value: function(e2) {
      let t2 = new Proxy(function() {
      }, { get(t3, r2) {
        if ("then" === r2)
          return {};
        throw Error(u(e2));
      }, construct() {
        throw Error(u(e2));
      }, apply(r2, a2, n2) {
        if ("function" == typeof n2[0])
          return n2[0](t2);
        throw Error(u(e2));
      } });
      return new Proxy({}, { get: () => t2 });
    }, enumerable: false, configurable: true }), l();
    var c = r(4591), d = r(9573);
    let h = Symbol("response"), p = Symbol("passThrough"), f = Symbol("waitUntil");
    class m {
      constructor(e2) {
        this[f] = [], this[p] = false;
      }
      respondWith(e2) {
        this[h] || (this[h] = Promise.resolve(e2));
      }
      passThroughOnException() {
        this[p] = true;
      }
      waitUntil(e2) {
        this[f].push(e2);
      }
    }
    class g extends m {
      constructor(e2) {
        super(e2.request), this.sourcePage = e2.page;
      }
      get request() {
        throw new c.qJ({ page: this.sourcePage });
      }
      respondWith() {
        throw new c.qJ({ page: this.sourcePage });
      }
    }
    var y = r(662), b = r(7701);
    function v(e2, t2) {
      let r2 = "string" == typeof t2 ? new URL(t2) : t2, a2 = new URL(e2, t2), n2 = r2.protocol + "//" + r2.host;
      return a2.protocol + "//" + a2.host === n2 ? a2.toString().replace(n2, "") : a2.toString();
    }
    var _ = r(7444), w = r(2039);
    let E = ["__nextFallback", "__nextLocale", "__nextInferredLocaleFromDefault", "__nextDefaultLocale", "__nextIsNotFound", w.H4], x = ["__nextDataReq"];
    function O(e2) {
      return e2.startsWith("/") ? e2 : "/" + e2;
    }
    function S(e2) {
      return e2.replace(/\.rsc($|\?)/, "$1");
    }
    var A = r(5927), k = r(2988), T = r(8983), P = r(6991), C = r(8816);
    function I() {
      return { previewModeId: process.env.__NEXT_PREVIEW_MODE_ID, previewModeSigningKey: process.env.__NEXT_PREVIEW_MODE_SIGNING_KEY || "", previewModeEncryptionKey: process.env.__NEXT_PREVIEW_MODE_ENCRYPTION_KEY || "" };
    }
    class R extends y.I {
      constructor(e2) {
        super(e2.input, e2.init), this.sourcePage = e2.page;
      }
      get request() {
        throw new c.qJ({ page: this.sourcePage });
      }
      respondWith() {
        throw new c.qJ({ page: this.sourcePage });
      }
      waitUntil() {
        throw new c.qJ({ page: this.sourcePage });
      }
    }
    let N = { keys: (e2) => Array.from(e2.keys()), get: (e2, t2) => e2.get(t2) ?? void 0 }, $ = (e2, t2) => (0, P.Yz)().withPropagatedContext(e2.headers, t2, N), j = false;
    async function L(e2) {
      let t2, a2;
      !function() {
        if (!j && (j = true, "true" === process.env.NEXT_PRIVATE_TEST_PROXY)) {
          let { interceptTestApis: e3, wrapRequestHandler: t3 } = r(1730);
          e3(), $ = t3($);
        }
      }(), await l();
      let n2 = void 0 !== self.__BUILD_MANIFEST;
      e2.request.url = S(e2.request.url);
      let i2 = new _.c(e2.request.url, { headers: e2.request.headers, nextConfig: e2.request.nextConfig });
      for (let e3 of [...i2.searchParams.keys()]) {
        let t3 = i2.searchParams.getAll(e3);
        if (e3 !== A.dN && e3.startsWith(A.dN)) {
          let r2 = e3.substring(A.dN.length);
          for (let e4 of (i2.searchParams.delete(r2), t3))
            i2.searchParams.append(r2, e4);
          i2.searchParams.delete(e3);
        }
      }
      let s2 = i2.buildId;
      i2.buildId = "";
      let o2 = e2.request.headers["x-nextjs-data"];
      o2 && "/index" === i2.pathname && (i2.pathname = "/");
      let u2 = (0, d.EK)(e2.request.headers), c2 = /* @__PURE__ */ new Map();
      if (!n2)
        for (let e3 of w.vu) {
          let t3 = e3.toString().toLowerCase();
          u2.get(t3) && (c2.set(t3, u2.get(t3)), u2.delete(t3));
        }
      let h2 = new R({ page: e2.page, input: function(e3, t3) {
        let r2 = "string" == typeof e3, a3 = r2 ? new URL(e3) : e3;
        for (let e4 of E)
          a3.searchParams.delete(e4);
        if (t3)
          for (let e4 of x)
            a3.searchParams.delete(e4);
        return r2 ? a3.toString() : a3;
      }(i2, true).toString(), init: { body: e2.request.body, geo: e2.request.geo, headers: u2, ip: e2.request.ip, method: e2.request.method, nextConfig: e2.request.nextConfig, signal: e2.request.signal } });
      o2 && Object.defineProperty(h2, "__isData", { enumerable: false, value: true }), !globalThis.__incrementalCache && e2.IncrementalCache && (globalThis.__incrementalCache = new e2.IncrementalCache({ appDir: true, fetchCache: true, minimalMode: true, fetchCacheKeyPrefix: "", dev: false, requestHeaders: e2.request.headers, requestProtocol: "https", getPrerenderManifest: () => ({ version: -1, routes: {}, dynamicRoutes: {}, notFoundRoutes: [], preview: I() }) }));
      let p2 = new g({ request: h2, page: e2.page });
      if ((t2 = await $(h2, () => "/middleware" === e2.page || "/src/middleware" === e2.page ? (0, P.Yz)().trace(C.dI.execute, { spanName: `middleware ${h2.method} ${h2.nextUrl.pathname}`, attributes: { "http.target": h2.nextUrl.pathname, "http.method": h2.method } }, () => k.B.wrap(T.O, { req: h2, renderOpts: { onUpdateCookies: (e3) => {
        a2 = e3;
      }, previewProps: I() } }, () => e2.handler(h2, p2))) : e2.handler(h2, p2))) && !(t2 instanceof Response))
        throw TypeError("Expected an instance of Response to be returned");
      t2 && a2 && t2.headers.set("set-cookie", a2);
      let m2 = null == t2 ? void 0 : t2.headers.get("x-middleware-rewrite");
      if (t2 && m2 && !n2) {
        let r2 = new _.c(m2, { forceLocale: true, headers: e2.request.headers, nextConfig: e2.request.nextConfig });
        r2.host === h2.nextUrl.host && (r2.buildId = s2 || r2.buildId, t2.headers.set("x-middleware-rewrite", String(r2)));
        let a3 = v(String(r2), String(i2));
        o2 && t2.headers.set("x-nextjs-rewrite", a3);
      }
      let y2 = null == t2 ? void 0 : t2.headers.get("Location");
      if (t2 && y2 && !n2) {
        let r2 = new _.c(y2, { forceLocale: false, headers: e2.request.headers, nextConfig: e2.request.nextConfig });
        t2 = new Response(t2.body, t2), r2.host === h2.nextUrl.host && (r2.buildId = s2 || r2.buildId, t2.headers.set("Location", String(r2))), o2 && (t2.headers.delete("Location"), t2.headers.set("x-nextjs-redirect", v(String(r2), String(i2))));
      }
      let O2 = t2 || b.x.next(), N2 = O2.headers.get("x-middleware-override-headers"), L2 = [];
      if (N2) {
        for (let [e3, t3] of c2)
          O2.headers.set(`x-middleware-request-${e3}`, t3), L2.push(e3);
        L2.length > 0 && O2.headers.set("x-middleware-override-headers", N2 + "," + L2.join(","));
      }
      return { response: O2, waitUntil: Promise.all(p2[f]), fetchMetrics: h2.fetchMetrics };
    }
    var M = r(5996), D = r.n(M);
    let U = 0, F = "x-vercel-cache-tags", z = "x-vercel-sc-headers", B = "x-vercel-revalidate", q = "x-vercel-cache-item-name", H = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;
    async function Z(e2, t2, r2 = 0) {
      let a2 = new AbortController(), n2 = setTimeout(() => {
        a2.abort();
      }, 500);
      return fetch(e2, { ...t2 || {}, signal: a2.signal }).catch((a3) => {
        if (3 !== r2)
          return H && console.log(`Fetch failed for ${e2} retry ${r2}`), Z(e2, t2, r2 + 1);
        throw a3;
      }).finally(() => {
        clearTimeout(n2);
      });
    }
    class G {
      hasMatchingTags(e2, t2) {
        if (e2.length !== t2.length)
          return false;
        let r2 = new Set(e2), a2 = new Set(t2);
        if (r2.size !== a2.size)
          return false;
        for (let e3 of r2)
          if (!a2.has(e3))
            return false;
        return true;
      }
      static isAvailable(e2) {
        return !!(e2._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
      }
      constructor(e2) {
        if (this.headers = {}, this.headers["Content-Type"] = "application/json", z in e2._requestHeaders) {
          let t3 = JSON.parse(e2._requestHeaders[z]);
          for (let e3 in t3)
            this.headers[e3] = t3[e3];
          delete e2._requestHeaders[z];
        }
        let t2 = e2._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL, r2 = e2._requestHeaders["x-vercel-sc-basepath"] || process.env.SUSPENSE_CACHE_BASEPATH;
        if (process.env.SUSPENSE_CACHE_AUTH_TOKEN && (this.headers.Authorization = `Bearer ${process.env.SUSPENSE_CACHE_AUTH_TOKEN}`), t2) {
          let e3 = process.env.SUSPENSE_CACHE_PROTO || "https";
          this.cacheEndpoint = `${e3}://${t2}${r2 || ""}`, H && console.log("using cache endpoint", this.cacheEndpoint);
        } else
          H && console.log("no cache endpoint available");
        e2.maxMemoryCacheSize ? a || (H && console.log("using memory store for fetch cache"), a = new (D())({ max: e2.maxMemoryCacheSize, length({ value: e3 }) {
          var t3;
          if (!e3)
            return 25;
          if ("REDIRECT" === e3.kind)
            return JSON.stringify(e3.props).length;
          if ("IMAGE" === e3.kind)
            throw Error("invariant image should not be incremental-cache");
          return "FETCH" === e3.kind ? JSON.stringify(e3.data || "").length : "ROUTE" === e3.kind ? e3.body.length : e3.html.length + ((null == (t3 = JSON.stringify("PAGE" === e3.kind && e3.pageData)) ? void 0 : t3.length) || 0);
        } })) : H && console.log("not using memory store for fetch cache");
      }
      resetRequestCache() {
        null == a || a.reset();
      }
      async revalidateTag(...e2) {
        let [t2] = e2;
        if (t2 = "string" == typeof t2 ? [t2] : t2, H && console.log("revalidateTag", t2), t2.length) {
          if (Date.now() < U) {
            H && console.log("rate limited ", U);
            return;
          }
          for (let e3 = 0; e3 < Math.ceil(t2.length / 64); e3++) {
            let r2 = t2.slice(64 * e3, 64 * e3 + 64);
            try {
              let e4 = await Z(`${this.cacheEndpoint}/v1/suspense-cache/revalidate?tags=${r2.map((e5) => encodeURIComponent(e5)).join(",")}`, { method: "POST", headers: this.headers, next: { internal: true } });
              if (429 === e4.status) {
                let t3 = e4.headers.get("retry-after") || "60000";
                U = Date.now() + parseInt(t3);
              }
              if (!e4.ok)
                throw Error(`Request failed with status ${e4.status}.`);
            } catch (e4) {
              console.warn("Failed to revalidate tag", r2, e4);
            }
          }
        }
      }
      async get(...e2) {
        var t2;
        let [r2, n2 = {}] = e2, { tags: i2, softTags: s2, kindHint: o2, fetchIdx: l2, fetchUrl: u2 } = n2;
        if ("fetch" !== o2)
          return null;
        if (Date.now() < U)
          return H && console.log("rate limited"), null;
        let c2 = null == a ? void 0 : a.get(r2), d2 = (null == c2 ? void 0 : null == (t2 = c2.value) ? void 0 : t2.kind) === "FETCH" && this.hasMatchingTags(i2 ?? [], c2.value.tags ?? []);
        if (this.cacheEndpoint && (!c2 || !d2))
          try {
            let e3 = Date.now(), t3 = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${r2}`, { method: "GET", headers: { ...this.headers, [q]: u2, [F]: (null == i2 ? void 0 : i2.join(",")) || "", [A.Ar]: (null == s2 ? void 0 : s2.join(",")) || "" }, next: { internal: true, fetchType: "cache-get", fetchUrl: u2, fetchIdx: l2 } });
            if (429 === t3.status) {
              let e4 = t3.headers.get("retry-after") || "60000";
              U = Date.now() + parseInt(e4);
            }
            if (404 === t3.status)
              return H && console.log(`no fetch cache entry for ${r2}, duration: ${Date.now() - e3}ms`), null;
            if (!t3.ok)
              throw console.error(await t3.text()), Error(`invalid response from cache ${t3.status}`);
            let n3 = await t3.json();
            if (!n3 || "FETCH" !== n3.kind)
              throw H && console.log({ cached: n3 }), Error("invalid cache value");
            if ("FETCH" === n3.kind)
              for (let e4 of (n3.tags ??= [], i2 ?? []))
                n3.tags.includes(e4) || n3.tags.push(e4);
            let o3 = t3.headers.get("x-vercel-cache-state"), d3 = t3.headers.get("age");
            c2 = { value: n3, lastModified: "fresh" !== o3 ? Date.now() - A.BR : Date.now() - 1e3 * parseInt(d3 || "0", 10) }, H && console.log(`got fetch cache entry for ${r2}, duration: ${Date.now() - e3}ms, size: ${Object.keys(n3).length}, cache-state: ${o3} tags: ${null == i2 ? void 0 : i2.join(",")} softTags: ${null == s2 ? void 0 : s2.join(",")}`), c2 && (null == a || a.set(r2, c2));
          } catch (e3) {
            H && console.error("Failed to get from fetch-cache", e3);
          }
        return c2 || null;
      }
      async set(...e2) {
        let [t2, r2, n2] = e2, { fetchCache: i2, fetchIdx: s2, fetchUrl: o2, tags: l2 } = n2;
        if (i2) {
          if (Date.now() < U) {
            H && console.log("rate limited");
            return;
          }
          if (null == a || a.set(t2, { value: r2, lastModified: Date.now() }), this.cacheEndpoint)
            try {
              let e3 = Date.now();
              null !== r2 && "revalidate" in r2 && (this.headers[B] = r2.revalidate.toString()), !this.headers[B] && null !== r2 && "data" in r2 && (this.headers["x-vercel-cache-control"] = r2.data.headers["cache-control"]);
              let a2 = JSON.stringify({ ...r2, tags: void 0 });
              H && console.log("set cache", t2);
              let n3 = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${t2}`, { method: "POST", headers: { ...this.headers, [q]: o2 || "", [F]: (null == l2 ? void 0 : l2.join(",")) || "" }, body: a2, next: { internal: true, fetchType: "cache-set", fetchUrl: o2, fetchIdx: s2 } });
              if (429 === n3.status) {
                let e4 = n3.headers.get("retry-after") || "60000";
                U = Date.now() + parseInt(e4);
              }
              if (!n3.ok)
                throw H && console.log(await n3.text()), Error(`invalid response ${n3.status}`);
              H && console.log(`successfully set to fetch-cache for ${t2}, duration: ${Date.now() - e3}ms, size: ${a2.length}`);
            } catch (e3) {
              H && console.error("Failed to update fetch cache", e3);
            }
        }
      }
    }
    var V = r(1863), W = r.n(V);
    class J {
      constructor(e2) {
        this.fs = e2.fs, this.flushToDisk = e2.flushToDisk, this.serverDistDir = e2.serverDistDir, this.appDir = !!e2._appDir, this.pagesDir = !!e2._pagesDir, this.revalidatedTags = e2.revalidatedTags, this.experimental = e2.experimental, this.debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE, e2.maxMemoryCacheSize && !n ? (this.debug && console.log("using memory store for fetch cache"), n = new (D())({ max: e2.maxMemoryCacheSize, length({ value: e3 }) {
          var t2;
          if (!e3)
            return 25;
          if ("REDIRECT" === e3.kind)
            return JSON.stringify(e3.props).length;
          if ("IMAGE" === e3.kind)
            throw Error("invariant image should not be incremental-cache");
          return "FETCH" === e3.kind ? JSON.stringify(e3.data || "").length : "ROUTE" === e3.kind ? e3.body.length : e3.html.length + ((null == (t2 = JSON.stringify(e3.pageData)) ? void 0 : t2.length) || 0);
        } })) : this.debug && console.log("not using memory store for fetch cache"), this.serverDistDir && this.fs && (this.tagsManifestPath = W().join(this.serverDistDir, "..", "cache", "fetch-cache", "tags-manifest.json"), this.loadTagsManifest());
      }
      resetRequestCache() {
      }
      loadTagsManifest() {
        if (this.tagsManifestPath && this.fs && !i) {
          try {
            i = JSON.parse(this.fs.readFileSync(this.tagsManifestPath, "utf8"));
          } catch (e2) {
            i = { version: 1, items: {} };
          }
          this.debug && console.log("loadTagsManifest", i);
        }
      }
      async revalidateTag(...e2) {
        let [t2] = e2;
        if (t2 = "string" == typeof t2 ? [t2] : t2, this.debug && console.log("revalidateTag", t2), 0 !== t2.length && (await this.loadTagsManifest(), i && this.tagsManifestPath)) {
          for (let e3 of t2) {
            let t3 = i.items[e3] || {};
            t3.revalidatedAt = Date.now(), i.items[e3] = t3;
          }
          try {
            await this.fs.mkdir(W().dirname(this.tagsManifestPath)), await this.fs.writeFile(this.tagsManifestPath, JSON.stringify(i || {})), this.debug && console.log("Updated tags manifest", i);
          } catch (e3) {
            console.warn("Failed to update tags manifest.", e3);
          }
        }
      }
      async get(...e2) {
        var t2, r2, a2;
        let [s2, o2 = {}] = e2, { tags: l2, softTags: u2, kindHint: c2 } = o2, d2 = null == n ? void 0 : n.get(s2);
        if (this.debug && console.log("get", s2, l2, c2, !!d2), (null == d2 ? void 0 : null == (t2 = d2.value) ? void 0 : t2.kind) === "PAGE") {
          let e3;
          let t3 = null == (a2 = d2.value.headers) ? void 0 : a2[A.Et];
          "string" == typeof t3 && (e3 = t3.split(",")), (null == e3 ? void 0 : e3.length) && (this.loadTagsManifest(), e3.some((e4) => {
            var t4;
            return (null == i ? void 0 : null == (t4 = i.items[e4]) ? void 0 : t4.revalidatedAt) && (null == i ? void 0 : i.items[e4].revalidatedAt) >= ((null == d2 ? void 0 : d2.lastModified) || Date.now());
          }) && (d2 = void 0));
        }
        return d2 && (null == d2 ? void 0 : null == (r2 = d2.value) ? void 0 : r2.kind) === "FETCH" && (this.loadTagsManifest(), [...l2 || [], ...u2 || []].some((e3) => {
          var t3;
          return !!this.revalidatedTags.includes(e3) || (null == i ? void 0 : null == (t3 = i.items[e3]) ? void 0 : t3.revalidatedAt) && (null == i ? void 0 : i.items[e3].revalidatedAt) >= ((null == d2 ? void 0 : d2.lastModified) || Date.now());
        }) && (d2 = void 0)), d2 ?? null;
      }
      async set(...e2) {
        let [t2, r2, a2] = e2;
        if (null == n || n.set(t2, { value: r2, lastModified: Date.now() }), this.debug && console.log("set", t2), this.flushToDisk) {
          if ((null == r2 ? void 0 : r2.kind) === "ROUTE") {
            let e3 = this.getFilePath(`${t2}.body`, "app");
            await this.fs.mkdir(W().dirname(e3)), await this.fs.writeFile(e3, r2.body);
            let a3 = { headers: r2.headers, status: r2.status, postponed: void 0 };
            await this.fs.writeFile(e3.replace(/\.body$/, A.EX), JSON.stringify(a3, null, 2));
            return;
          }
          if ((null == r2 ? void 0 : r2.kind) === "PAGE") {
            let e3 = "string" == typeof r2.pageData, a3 = this.getFilePath(`${t2}.html`, e3 ? "app" : "pages");
            if (await this.fs.mkdir(W().dirname(a3)), await this.fs.writeFile(a3, r2.html), await this.fs.writeFile(this.getFilePath(`${t2}${e3 ? this.experimental.ppr ? A.Sx : A.hd : A.JT}`, e3 ? "app" : "pages"), e3 ? r2.pageData : JSON.stringify(r2.pageData)), r2.headers || r2.status) {
              let e4 = { headers: r2.headers, status: r2.status, postponed: r2.postponed };
              await this.fs.writeFile(a3.replace(/\.html$/, A.EX), JSON.stringify(e4));
            }
          } else if ((null == r2 ? void 0 : r2.kind) === "FETCH") {
            let e3 = this.getFilePath(t2, "fetch");
            await this.fs.mkdir(W().dirname(e3)), await this.fs.writeFile(e3, JSON.stringify({ ...r2, tags: a2.tags }));
          }
        }
      }
      detectFileKind(e2) {
        if (!this.appDir && !this.pagesDir)
          throw Error("Invariant: Can't determine file path kind, no page directory enabled");
        if (!this.appDir && this.pagesDir)
          return "pages";
        if (this.appDir && !this.pagesDir)
          return "app";
        let t2 = this.getFilePath(e2, "pages");
        if (this.fs.existsSync(t2))
          return "pages";
        if (t2 = this.getFilePath(e2, "app"), this.fs.existsSync(t2))
          return "app";
        throw Error(`Invariant: Unable to determine file path kind for ${e2}`);
      }
      getFilePath(e2, t2) {
        switch (t2) {
          case "fetch":
            return W().join(this.serverDistDir, "..", "cache", "fetch-cache", e2);
          case "pages":
            return W().join(this.serverDistDir, "pages", e2);
          case "app":
            return W().join(this.serverDistDir, "app", e2);
          default:
            throw Error("Invariant: Can't determine file path kind");
        }
      }
    }
    let K = ["(..)(..)", "(.)", "(..)", "(...)"];
    function X(e2) {
      return void 0 !== e2.split("/").find((e3) => K.find((t2) => e3.startsWith(t2)));
    }
    let Y = /\/\[[^/]+?\](?=\/|$)/;
    function Q(e2) {
      return X(e2) && (e2 = function(e3) {
        let t2, r2, a2;
        for (let n2 of e3.split("/"))
          if (r2 = K.find((e4) => n2.startsWith(e4))) {
            [t2, a2] = e3.split(r2, 2);
            break;
          }
        if (!t2 || !r2 || !a2)
          throw Error(`Invalid interception route: ${e3}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);
        switch (t2 = O(t2.split("/").reduce((e4, t3, r3, a3) => t3 ? "(" === t3[0] && t3.endsWith(")") || "@" === t3[0] || ("page" === t3 || "route" === t3) && r3 === a3.length - 1 ? e4 : e4 + "/" + t3 : e4, "")), r2) {
          case "(.)":
            a2 = "/" === t2 ? `/${a2}` : t2 + "/" + a2;
            break;
          case "(..)":
            if ("/" === t2)
              throw Error(`Invalid interception route: ${e3}. Cannot use (..) marker at the root level, use (.) instead.`);
            a2 = t2.split("/").slice(0, -1).concat(a2).join("/");
            break;
          case "(...)":
            a2 = "/" + a2;
            break;
          case "(..)(..)":
            let n2 = t2.split("/");
            if (n2.length <= 2)
              throw Error(`Invalid interception route: ${e3}. Cannot use (..)(..) marker at the root level or one level up.`);
            a2 = n2.slice(0, -2).concat(a2).join("/");
            break;
          default:
            throw Error("Invariant: unexpected marker");
        }
        return { interceptingRoute: t2, interceptedRoute: a2 };
      }(e2).interceptedRoute), Y.test(e2);
    }
    "undefined" != typeof performance && ["mark", "measure", "getEntriesByName"].every((e2) => "function" == typeof performance[e2]);
    class ee extends Error {
    }
    function et(e2) {
      return e2.replace(/(?:\/index)?\/?$/, "") || "/";
    }
    class er {
      static #e = this.timings = /* @__PURE__ */ new Map();
      constructor(e2) {
        this.prerenderManifest = e2;
      }
      get(e2) {
        var t2;
        let r2 = er.timings.get(e2);
        if (void 0 !== r2 || void 0 !== (r2 = null == (t2 = this.prerenderManifest.routes[e2]) ? void 0 : t2.initialRevalidateSeconds))
          return r2;
      }
      set(e2, t2) {
        er.timings.set(e2, t2);
      }
      clear() {
        er.timings.clear();
      }
    }
    class ea {
      constructor({ fs: e2, dev: t2, appDir: r2, pagesDir: a2, flushToDisk: n2, fetchCache: i2, minimalMode: s2, serverDistDir: o2, requestHeaders: l2, requestProtocol: u2, maxMemoryCacheSize: c2, getPrerenderManifest: d2, fetchCacheKeyPrefix: h2, CurCacheHandler: p2, allowedRevalidateHeaderKeys: f2, experimental: m2 }) {
        var g2, y2, b2, v2;
        this.locks = /* @__PURE__ */ new Map(), this.unlocks = /* @__PURE__ */ new Map();
        let _2 = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;
        this.hasCustomCacheHandler = !!p2, p2 ? _2 && console.log("using custom cache handler", p2.name) : (e2 && o2 && (_2 && console.log("using filesystem cache handler"), p2 = J), G.isAvailable({ _requestHeaders: l2 }) && s2 && i2 && (_2 && console.log("using fetch cache handler"), p2 = G)), process.env.__NEXT_TEST_MAX_ISR_CACHE && (c2 = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)), this.dev = t2, this.disableForTestmode = "true" === process.env.NEXT_PRIVATE_TEST_PROXY, this.minimalMode = s2, this.requestHeaders = l2, this.requestProtocol = u2, this.allowedRevalidateHeaderKeys = f2, this.prerenderManifest = d2(), this.revalidateTimings = new er(this.prerenderManifest), this.fetchCacheKeyPrefix = h2;
        let w2 = [];
        l2[A.y3] === (null == (y2 = this.prerenderManifest) ? void 0 : null == (g2 = y2.preview) ? void 0 : g2.previewModeId) && (this.isOnDemandRevalidate = true), s2 && "string" == typeof l2[A.of] && l2[A.X_] === (null == (v2 = this.prerenderManifest) ? void 0 : null == (b2 = v2.preview) ? void 0 : b2.previewModeId) && (w2 = l2[A.of].split(",")), p2 && (this.cacheHandler = new p2({ dev: t2, fs: e2, flushToDisk: n2, serverDistDir: o2, revalidatedTags: w2, maxMemoryCacheSize: c2, _pagesDir: !!a2, _appDir: !!r2, _requestHeaders: l2, fetchCacheKeyPrefix: h2, experimental: m2 }));
      }
      calculateRevalidate(e2, t2, r2) {
        if (r2)
          return new Date().getTime() - 1e3;
        let a2 = this.revalidateTimings.get(et(e2)) ?? 1;
        return "number" == typeof a2 ? 1e3 * a2 + t2 : a2;
      }
      _getPathname(e2, t2) {
        return t2 ? e2 : /^\/index(\/|$)/.test(e2) && !Q(e2) ? "/index" + e2 : "/" === e2 ? "/index" : O(e2);
      }
      resetRequestCache() {
        var e2, t2;
        null == (t2 = this.cacheHandler) || null == (e2 = t2.resetRequestCache) || e2.call(t2);
      }
      async unlock(e2) {
        let t2 = this.unlocks.get(e2);
        t2 && (t2(), this.locks.delete(e2), this.unlocks.delete(e2));
      }
      async lock(e2) {
        process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY;
        let t2 = () => Promise.resolve(), r2 = this.locks.get(e2);
        if (r2)
          await r2;
        else {
          let r3 = new Promise((e3) => {
            t2 = async () => {
              e3();
            };
          });
          this.locks.set(e2, r3), this.unlocks.set(e2, t2);
        }
        return t2;
      }
      async revalidateTag(e2) {
        var t2, r2;
        return process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY, null == (r2 = this.cacheHandler) ? void 0 : null == (t2 = r2.revalidateTag) ? void 0 : t2.call(r2, e2);
      }
      async fetchCacheKey(e2, t2 = {}) {
        let r2 = [], a2 = new TextEncoder(), n2 = new TextDecoder();
        if (t2.body) {
          if ("function" == typeof t2.body.getReader) {
            let e3 = t2.body, i3 = [];
            try {
              await e3.pipeTo(new WritableStream({ write(e4) {
                "string" == typeof e4 ? (i3.push(a2.encode(e4)), r2.push(e4)) : (i3.push(e4), r2.push(n2.decode(e4, { stream: true })));
              } })), r2.push(n2.decode());
              let s3 = i3.reduce((e4, t3) => e4 + t3.length, 0), o3 = new Uint8Array(s3), l2 = 0;
              for (let e4 of i3)
                o3.set(e4, l2), l2 += e4.length;
              t2._ogBody = o3;
            } catch (e4) {
              console.error("Problem reading body", e4);
            }
          } else if ("function" == typeof t2.body.keys) {
            let e3 = t2.body;
            for (let a3 of (t2._ogBody = t2.body, /* @__PURE__ */ new Set([...e3.keys()]))) {
              let t3 = e3.getAll(a3);
              r2.push(`${a3}=${(await Promise.all(t3.map(async (e4) => "string" == typeof e4 ? e4 : await e4.text()))).join(",")}`);
            }
          } else if ("function" == typeof t2.body.arrayBuffer) {
            let e3 = t2.body, a3 = await e3.arrayBuffer();
            r2.push(await e3.text()), t2._ogBody = new Blob([a3], { type: e3.type });
          } else
            "string" == typeof t2.body && (r2.push(t2.body), t2._ogBody = t2.body);
        }
        let i2 = "function" == typeof (t2.headers || {}).keys ? Object.fromEntries(t2.headers) : Object.assign({}, t2.headers);
        "traceparent" in i2 && delete i2.traceparent;
        let s2 = JSON.stringify(["v3", this.fetchCacheKeyPrefix || "", e2, t2.method, i2, t2.mode, t2.redirect, t2.credentials, t2.referrer, t2.referrerPolicy, t2.integrity, t2.cache, r2]);
        {
          var o2;
          let e3 = a2.encode(s2);
          return o2 = await crypto.subtle.digest("SHA-256", e3), Array.prototype.map.call(new Uint8Array(o2), (e4) => e4.toString(16).padStart(2, "0")).join("");
        }
      }
      async get(e2, t2 = {}) {
        var r2, a2;
        let n2, i2;
        if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY, this.disableForTestmode || this.dev && ("fetch" !== t2.kindHint || "no-cache" === this.requestHeaders["cache-control"]))
          return null;
        e2 = this._getPathname(e2, "fetch" === t2.kindHint);
        let s2 = null, o2 = t2.revalidate, l2 = await (null == (r2 = this.cacheHandler) ? void 0 : r2.get(e2, t2));
        if ((null == l2 ? void 0 : null == (a2 = l2.value) ? void 0 : a2.kind) === "FETCH")
          return [...t2.tags || [], ...t2.softTags || []].some((e3) => {
            var t3;
            return null == (t3 = this.revalidatedTags) ? void 0 : t3.includes(e3);
          }) ? null : (o2 = o2 || l2.value.revalidate, { isStale: (Date.now() - (l2.lastModified || 0)) / 1e3 > o2, value: { kind: "FETCH", data: l2.value.data, revalidate: o2 }, revalidateAfter: Date.now() + 1e3 * o2 });
        let u2 = this.revalidateTimings.get(et(e2));
        return (null == l2 ? void 0 : l2.lastModified) === -1 ? (n2 = -1, i2 = -1 * A.BR) : n2 = !!(false !== (i2 = this.calculateRevalidate(e2, (null == l2 ? void 0 : l2.lastModified) || Date.now(), this.dev && "fetch" !== t2.kindHint)) && i2 < Date.now()) || void 0, l2 && (s2 = { isStale: n2, curRevalidate: u2, revalidateAfter: i2, value: l2.value }), !l2 && this.prerenderManifest.notFoundRoutes.includes(e2) && (s2 = { isStale: n2, value: null, curRevalidate: u2, revalidateAfter: i2 }, this.set(e2, s2.value, t2)), s2;
      }
      async set(e2, t2, r2) {
        if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY, this.disableForTestmode || this.dev && !r2.fetchCache)
          return;
        let a2 = JSON.stringify(t2).length;
        if (r2.fetchCache && !this.hasCustomCacheHandler && a2 > 2097152) {
          if (this.dev)
            throw Error(`Failed to set Next.js data cache, items over 2MB can not be cached (${a2} bytes)`);
          return;
        }
        e2 = this._getPathname(e2, r2.fetchCache);
        try {
          var n2;
          void 0 === r2.revalidate || r2.fetchCache || this.revalidateTimings.set(e2, r2.revalidate), await (null == (n2 = this.cacheHandler) ? void 0 : n2.set(e2, t2, r2));
        } catch (t3) {
          console.warn("Failed to update prerender cache for", e2, t3);
        }
      }
    }
    function en(e2) {
      let { re: t2, groups: r2 } = e2;
      return (e3) => {
        let a2 = t2.exec(e3);
        if (!a2)
          return false;
        let n2 = (e4) => {
          try {
            return decodeURIComponent(e4);
          } catch (e5) {
            throw new ee("failed to decode param");
          }
        }, i2 = {};
        return Object.keys(r2).forEach((e4) => {
          let t3 = r2[e4], s2 = a2[t3.pos];
          void 0 !== s2 && (i2[e4] = ~s2.indexOf("/") ? s2.split("/").map((e5) => n2(e5)) : t3.repeat ? [n2(s2)] : n2(s2));
        }), i2;
      };
    }
    let ei = /[|\\{}()[\]^$+*?.-]/, es = /[|\\{}()[\]^$+*?.-]/g;
    function eo(e2) {
      return ei.test(e2) ? e2.replace(es, "\\$&") : e2;
    }
    var el = r(5577);
    function eu(e2) {
      let t2 = e2.startsWith("[") && e2.endsWith("]");
      t2 && (e2 = e2.slice(1, -1));
      let r2 = e2.startsWith("...");
      return r2 && (e2 = e2.slice(3)), { key: e2, repeat: r2, optional: t2 };
    }
    function ec(e2) {
      let { parameterizedRoute: t2, groups: r2 } = function(e3) {
        let t3 = (0, el.Q)(e3).slice(1).split("/"), r3 = {}, a2 = 1;
        return { parameterizedRoute: t3.map((e4) => {
          let t4 = K.find((t5) => e4.startsWith(t5)), n2 = e4.match(/\[((?:\[.*\])|.+)\]/);
          if (t4 && n2) {
            let { key: e5, optional: i2, repeat: s2 } = eu(n2[1]);
            return r3[e5] = { pos: a2++, repeat: s2, optional: i2 }, "/" + eo(t4) + "([^/]+?)";
          }
          if (!n2)
            return "/" + eo(e4);
          {
            let { key: e5, repeat: t5, optional: i2 } = eu(n2[1]);
            return r3[e5] = { pos: a2++, repeat: t5, optional: i2 }, t5 ? i2 ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
          }
        }).join(""), groups: r3 };
      }(e2);
      return { re: RegExp("^" + t2 + "(?:/)?$"), groups: r2 };
    }
    function ed(e2) {
      let { interceptionMarker: t2, getSafeRouteKey: r2, segment: a2, routeKeys: n2, keyPrefix: i2 } = e2, { key: s2, optional: o2, repeat: l2 } = eu(a2), u2 = s2.replace(/\W/g, "");
      i2 && (u2 = "" + i2 + u2);
      let c2 = false;
      (0 === u2.length || u2.length > 30) && (c2 = true), isNaN(parseInt(u2.slice(0, 1))) || (c2 = true), c2 && (u2 = r2()), i2 ? n2[u2] = "" + i2 + s2 : n2[u2] = s2;
      let d2 = t2 ? eo(t2) : "";
      return l2 ? o2 ? "(?:/" + d2 + "(?<" + u2 + ">.+?))?" : "/" + d2 + "(?<" + u2 + ">.+?)" : "/" + d2 + "(?<" + u2 + ">[^/]+?)";
    }
    class eh {
      constructor(e2) {
        this.definition = e2, Q(e2.pathname) && (this.dynamic = en(ec(e2.pathname)));
      }
      get identity() {
        return this.definition.pathname;
      }
      get isDynamic() {
        return void 0 !== this.dynamic;
      }
      match(e2) {
        let t2 = this.test(e2);
        return t2 ? { definition: this.definition, params: t2.params } : null;
      }
      test(e2) {
        if (this.dynamic) {
          let t2 = this.dynamic(e2);
          return t2 ? { params: t2 } : null;
        }
        return e2 === this.definition.pathname ? {} : null;
      }
    }
    let ep = Symbol.for("__next_internal_waitUntil__"), ef = globalThis[ep] || (globalThis[ep] = { waitUntilCounter: 0, waitUntilResolve: void 0, waitUntilPromise: null });
    var em = r(7960), eg = r(3039), ey = r(9548);
    function eb(e2) {
      let t2 = {};
      return e2.forEach((e3, r2) => {
        void 0 === t2[r2] ? t2[r2] = e3 : Array.isArray(t2[r2]) ? t2[r2].push(e3) : t2[r2] = [t2[r2], e3];
      }), t2;
    }
    function ev(e2) {
      return e2.replace(/__ESC_COLON_/gi, ":");
    }
    function e_(e2, t2) {
      if (!e2.includes(":"))
        return e2;
      for (let r2 of Object.keys(t2))
        e2.includes(":" + r2) && (e2 = e2.replace(RegExp(":" + r2 + "\\*", "g"), ":" + r2 + "--ESCAPED_PARAM_ASTERISKS").replace(RegExp(":" + r2 + "\\?", "g"), ":" + r2 + "--ESCAPED_PARAM_QUESTION").replace(RegExp(":" + r2 + "\\+", "g"), ":" + r2 + "--ESCAPED_PARAM_PLUS").replace(RegExp(":" + r2 + "(?!\\w)", "g"), "--ESCAPED_PARAM_COLON" + r2));
      return e2 = e2.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISKS/g, "*"), (0, ey.MY)("/" + e2, { validate: false })(t2).slice(1);
    }
    class ew {
      constructor(e2) {
        this.routeModule = e2, this.matcher = new eh(e2.definition);
      }
      static wrap(e2, t2 = {}) {
        let r2 = new ew(e2);
        return (e3) => L({ ...e3, ...t2, IncrementalCache: ea, handler: r2.handler.bind(r2) });
      }
      async handler(e2, t2) {
        let { params: a2 } = function({ page: e3, i18n: t3, basePath: a3, rewrites: n3, pageIsDynamic: i3, trailingSlash: s3, caseSensitive: o2 }) {
          let l2, u2, c2;
          return i3 && (c2 = (u2 = en(l2 = function(e4, t4) {
            let r2 = function(e5, t5) {
              let r3;
              let a4 = (0, el.Q)(e5).slice(1).split("/"), n4 = (r3 = 0, () => {
                let e6 = "", t6 = ++r3;
                for (; t6 > 0; )
                  e6 += String.fromCharCode(97 + (t6 - 1) % 26), t6 = Math.floor((t6 - 1) / 26);
                return e6;
              }), i4 = {};
              return { namedParameterizedRoute: a4.map((e6) => {
                let r4 = K.some((t6) => e6.startsWith(t6)), a5 = e6.match(/\[((?:\[.*\])|.+)\]/);
                if (r4 && a5) {
                  let [r5] = e6.split(a5[0]);
                  return ed({ getSafeRouteKey: n4, interceptionMarker: r5, segment: a5[1], routeKeys: i4, keyPrefix: t5 ? "nxtI" : void 0 });
                }
                return a5 ? ed({ getSafeRouteKey: n4, segment: a5[1], routeKeys: i4, keyPrefix: t5 ? "nxtP" : void 0 }) : "/" + eo(e6);
              }).join(""), routeKeys: i4 };
            }(e4, t4);
            return { ...ec(e4), namedRegex: "^" + r2.namedParameterizedRoute + "(?:/)?$", routeKeys: r2.routeKeys };
          }(e3, false)))(e3)), { handleRewrites: function(l3, c3) {
            let d2 = {}, h2 = c3.pathname, p2 = (n4) => {
              let p3 = function(e4, t4) {
                let r2 = [], a4 = (0, ey.Bo)(e4, r2, { delimiter: "/", sensitive: "boolean" == typeof (null == t4 ? void 0 : t4.sensitive) && t4.sensitive, strict: null == t4 ? void 0 : t4.strict }), n5 = (0, ey.WS)((null == t4 ? void 0 : t4.regexModifier) ? new RegExp(t4.regexModifier(a4.source), a4.flags) : a4, r2);
                return (e5, a5) => {
                  if ("string" != typeof e5)
                    return false;
                  let i4 = n5(e5);
                  if (!i4)
                    return false;
                  if (null == t4 ? void 0 : t4.removeUnnamedParams)
                    for (let e6 of r2)
                      "number" == typeof e6.name && delete i4.params[e6.name];
                  return { ...a5, ...i4.params };
                };
              }(n4.source + (s3 ? "(/)?" : ""), { removeUnnamedParams: true, strict: true, sensitive: !!o2 })(c3.pathname);
              if ((n4.has || n4.missing) && p3) {
                let e4 = function(e5, t4, a4, n5) {
                  void 0 === a4 && (a4 = []), void 0 === n5 && (n5 = []);
                  let i4 = {}, s4 = (a5) => {
                    let n6;
                    let s5 = a5.key;
                    switch (a5.type) {
                      case "header":
                        s5 = s5.toLowerCase(), n6 = e5.headers[s5];
                        break;
                      case "cookie":
                        if ("cookies" in e5)
                          n6 = e5.cookies[a5.key];
                        else {
                          var o3;
                          n6 = (o3 = e5.headers, function() {
                            let { cookie: e6 } = o3;
                            if (!e6)
                              return {};
                            let { parse: t5 } = r(4337);
                            return t5(Array.isArray(e6) ? e6.join("; ") : e6);
                          })()[a5.key];
                        }
                        break;
                      case "query":
                        n6 = t4[s5];
                        break;
                      case "host": {
                        let { host: t5 } = (null == e5 ? void 0 : e5.headers) || {};
                        n6 = null == t5 ? void 0 : t5.split(":", 1)[0].toLowerCase();
                      }
                    }
                    if (!a5.value && n6)
                      return i4[function(e6) {
                        let t5 = "";
                        for (let r2 = 0; r2 < e6.length; r2++) {
                          let a6 = e6.charCodeAt(r2);
                          (a6 > 64 && a6 < 91 || a6 > 96 && a6 < 123) && (t5 += e6[r2]);
                        }
                        return t5;
                      }(s5)] = n6, true;
                    if (n6) {
                      let e6 = RegExp("^" + a5.value + "$"), t5 = Array.isArray(n6) ? n6.slice(-1)[0].match(e6) : n6.match(e6);
                      if (t5)
                        return Array.isArray(t5) && (t5.groups ? Object.keys(t5.groups).forEach((e7) => {
                          i4[e7] = t5.groups[e7];
                        }) : "host" === a5.type && t5[0] && (i4.host = t5[0])), true;
                    }
                    return false;
                  };
                  return !!a4.every((e6) => s4(e6)) && !n5.some((e6) => s4(e6)) && i4;
                }(l3, c3.query, n4.has, n4.missing);
                e4 ? Object.assign(p3, e4) : p3 = false;
              }
              if (p3) {
                let { parsedDestination: r2, destQuery: s4 } = function(e4) {
                  let t4;
                  let r3 = Object.assign({}, e4.query);
                  delete r3.__nextLocale, delete r3.__nextDefaultLocale, delete r3.__nextDataReq, delete r3.__nextInferredLocaleFromDefault, delete r3[w.H4];
                  let a4 = e4.destination;
                  for (let t5 of Object.keys({ ...e4.params, ...r3 }))
                    a4 = a4.replace(RegExp(":" + eo(t5), "g"), "__ESC_COLON_" + t5);
                  let n5 = function(e5) {
                    if (e5.startsWith("/"))
                      return function(e6, t6) {
                        let r4 = new URL("http://n"), a5 = e6.startsWith(".") ? new URL("http://n") : r4, { pathname: n6, searchParams: i5, search: s6, hash: o4, href: l5, origin: u4 } = new URL(e6, a5);
                        if (u4 !== r4.origin)
                          throw Error("invariant: invalid relative URL, router received " + e6);
                        return { pathname: n6, query: eb(i5), search: s6, hash: o4, href: l5.slice(r4.origin.length) };
                      }(e5);
                    let t5 = new URL(e5);
                    return { hash: t5.hash, hostname: t5.hostname, href: t5.href, pathname: t5.pathname, port: t5.port, protocol: t5.protocol, query: eb(t5.searchParams), search: t5.search };
                  }(a4), i4 = n5.query, s5 = ev("" + n5.pathname + (n5.hash || "")), o3 = ev(n5.hostname || ""), l4 = [], u3 = [];
                  (0, ey.Bo)(s5, l4), (0, ey.Bo)(o3, u3);
                  let c4 = [];
                  l4.forEach((e5) => c4.push(e5.name)), u3.forEach((e5) => c4.push(e5.name));
                  let d3 = (0, ey.MY)(s5, { validate: false }), h3 = (0, ey.MY)(o3, { validate: false });
                  for (let [t5, r4] of Object.entries(i4))
                    Array.isArray(r4) ? i4[t5] = r4.map((t6) => e_(ev(t6), e4.params)) : "string" == typeof r4 && (i4[t5] = e_(ev(r4), e4.params));
                  let p4 = Object.keys(e4.params).filter((e5) => "nextInternalLocale" !== e5);
                  if (e4.appendParamsToQuery && !p4.some((e5) => c4.includes(e5)))
                    for (let t5 of p4)
                      t5 in i4 || (i4[t5] = e4.params[t5]);
                  if (X(s5))
                    for (let t5 of s5.split("/")) {
                      let r4 = K.find((e5) => t5.startsWith(e5));
                      if (r4) {
                        e4.params["0"] = r4;
                        break;
                      }
                    }
                  try {
                    let [r4, a5] = (t4 = d3(e4.params)).split("#", 2);
                    n5.hostname = h3(e4.params), n5.pathname = r4, n5.hash = (a5 ? "#" : "") + (a5 || ""), delete n5.search;
                  } catch (e5) {
                    if (e5.message.match(/Expected .*? to not repeat, but got an array/))
                      throw Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match");
                    throw e5;
                  }
                  return n5.query = { ...r3, ...n5.query }, { newUrl: t4, destQuery: i4, parsedDestination: n5 };
                }({ appendParamsToQuery: true, destination: n4.destination, params: p3, query: c3.query });
                if (r2.protocol)
                  return true;
                if (Object.assign(d2, s4, p3), Object.assign(c3.query, r2.query), delete r2.query, Object.assign(c3, r2), h2 = c3.pathname, a3 && (h2 = h2.replace(RegExp(`^${a3}`), "") || "/"), t3) {
                  let e4 = (0, eg.h)(h2, t3.locales);
                  h2 = e4.pathname, c3.query.nextInternalLocale = e4.detectedLocale || p3.nextInternalLocale;
                }
                if (h2 === e3)
                  return true;
                if (i3 && u2) {
                  let e4 = u2(h2);
                  if (e4)
                    return c3.query = { ...c3.query, ...e4 }, true;
                }
              }
              return false;
            };
            for (let e4 of n3.beforeFiles || [])
              p2(e4);
            if (h2 !== e3) {
              let t4 = false;
              for (let e4 of n3.afterFiles || [])
                if (t4 = p2(e4))
                  break;
              if (!t4 && !(() => {
                let t5 = (0, el.Q)(h2 || "");
                return t5 === (0, el.Q)(e3) || (null == u2 ? void 0 : u2(t5));
              })()) {
                for (let e4 of n3.fallback || [])
                  if (t4 = p2(e4))
                    break;
              }
            }
            return d2;
          }, defaultRouteRegex: l2, dynamicRouteMatcher: u2, defaultRouteMatches: c2, getParamsFromRouteMatches: function(e4, r2, a4) {
            return en(function() {
              let { groups: e5, routeKeys: n4 } = l2;
              return { re: { exec: (i4) => {
                let s4 = Object.fromEntries(new URLSearchParams(i4)), o3 = t3 && a4 && s4["1"] === a4;
                for (let e6 of Object.keys(s4)) {
                  let t4 = s4[e6];
                  e6 !== A.dN && e6.startsWith(A.dN) && (s4[e6.substring(A.dN.length)] = t4, delete s4[e6]);
                }
                let l3 = Object.keys(n4 || {}), u3 = (e6) => {
                  if (t3) {
                    let n5 = Array.isArray(e6), i5 = n5 ? e6[0] : e6;
                    if ("string" == typeof i5 && t3.locales.some((e7) => e7.toLowerCase() === i5.toLowerCase() && (a4 = e7, r2.locale = a4, true)))
                      return n5 && e6.splice(0, 1), !n5 || 0 === e6.length;
                  }
                  return false;
                };
                return l3.every((e6) => s4[e6]) ? l3.reduce((t4, r3) => {
                  let a5 = null == n4 ? void 0 : n4[r3];
                  return a5 && !u3(s4[r3]) && (t4[e5[a5].pos] = s4[r3]), t4;
                }, {}) : Object.keys(s4).reduce((e6, t4) => {
                  if (!u3(s4[t4])) {
                    let r3 = t4;
                    return o3 && (r3 = parseInt(t4, 10) - 1 + ""), Object.assign(e6, { [r3]: s4[t4] });
                  }
                  return e6;
                }, {});
              } }, groups: e5 };
            }())(e4.headers["x-now-route-matches"]);
          }, normalizeDynamicRouteParams: (e4, t4) => {
            var r2, a4, n4;
            let i4;
            return r2 = e4, a4 = l2, n4 = c2, i4 = true, a4 ? { params: r2 = Object.keys(a4.groups).reduce((e5, s4) => {
              let o3 = r2[s4];
              "string" == typeof o3 && (o3 = S(o3)), Array.isArray(o3) && (o3 = o3.map((e6) => ("string" == typeof e6 && (e6 = S(e6)), e6)));
              let l3 = n4[s4], u3 = a4.groups[s4].optional;
              return ((Array.isArray(l3) ? l3.some((e6) => Array.isArray(o3) ? o3.some((t5) => t5.includes(e6)) : null == o3 ? void 0 : o3.includes(e6)) : null == o3 ? void 0 : o3.includes(l3)) || void 0 === o3 && !(u3 && t4)) && (i4 = false), u3 && (!o3 || Array.isArray(o3) && 1 === o3.length && ("index" === o3[0] || o3[0] === `[[...${s4}]]`)) && (o3 = void 0, delete r2[s4]), o3 && "string" == typeof o3 && a4.groups[s4].repeat && (o3 = o3.split("/")), o3 && (e5[s4] = o3), e5;
            }, {}), hasValidParams: i4 } : { params: r2, hasValidParams: false };
          }, normalizeVercelUrl: (e4, t4, r2) => function(e5, t5, r3, a4, n4) {
            if (a4 && t5 && n4) {
              let t6 = (0, em.parse)(e5.url, true);
              for (let e6 of (delete t6.search, Object.keys(t6.query)))
                (e6 !== A.dN && e6.startsWith(A.dN) || (r3 || Object.keys(n4.groups)).includes(e6)) && delete t6.query[e6];
              e5.url = (0, em.format)(t6);
            }
          }(e4, t4, r2, i3, l2), interpolateDynamicPath: (e4, t4) => function(e5, t5, r2) {
            if (!r2)
              return e5;
            for (let a4 of Object.keys(r2.groups)) {
              let { optional: n4, repeat: i4 } = r2.groups[a4], s4 = `[${i4 ? "..." : ""}${a4}]`;
              n4 && (s4 = `[${s4}]`);
              let o3 = e5.indexOf(s4);
              if (o3 > -1) {
                let r3;
                let n5 = t5[a4];
                r3 = Array.isArray(n5) ? n5.map((e6) => e6 && encodeURIComponent(e6)).join("/") : n5 ? encodeURIComponent(n5) : "", e5 = e5.slice(0, o3) + r3 + e5.slice(o3 + s4.length);
              }
            }
            return e5;
          }(e4, t4, l2) };
        }({ pageIsDynamic: this.matcher.isDynamic, page: this.matcher.definition.pathname, basePath: e2.nextUrl.basePath, rewrites: {}, caseSensitive: false }).normalizeDynamicRouteParams(eb(e2.nextUrl.searchParams)), n2 = { params: a2, prerenderManifest: { version: 4, routes: {}, dynamicRoutes: {}, preview: I(), notFoundRoutes: [] }, renderOpts: { supportsDynamicResponse: true, experimental: { ppr: false } } }, i2 = await this.routeModule.handle(e2, n2), s2 = [ef.waitUntilPromise];
        return n2.renderOpts.waitUntil && s2.push(n2.renderOpts.waitUntil), t2.waitUntil(Promise.all(s2)), i2;
      }
    }
  };
  __namedExportsObject["__chunk_6991"] = (e, t, r) => {
    "use strict";
    let a;
    r.d(t, { MU: () => u, Yz: () => b });
    var n = r(8816);
    let { context: i, propagation: s, trace: o, SpanStatusCode: l, SpanKind: u, ROOT_CONTEXT: c } = a = r(7723), d = (e2) => null !== e2 && "object" == typeof e2 && "function" == typeof e2.then, h = (e2, t2) => {
      (null == t2 ? void 0 : t2.bubble) === true ? e2.setAttribute("next.bubble", true) : (t2 && e2.recordException(t2), e2.setStatus({ code: l.ERROR, message: null == t2 ? void 0 : t2.message })), e2.end();
    }, p = /* @__PURE__ */ new Map(), f = a.createContextKey("next.rootSpanId"), m = 0, g = () => m++;
    class y {
      getTracerInstance() {
        return o.getTracer("next.js", "0.0.1");
      }
      getContext() {
        return i;
      }
      getActiveScopeSpan() {
        return o.getSpan(null == i ? void 0 : i.active());
      }
      withPropagatedContext(e2, t2, r2) {
        let a2 = i.active();
        if (o.getSpanContext(a2))
          return t2();
        let n2 = s.extract(a2, e2, r2);
        return i.with(n2, t2);
      }
      trace(...e2) {
        var t2;
        let [r2, a2, s2] = e2, { fn: l2, options: u2 } = "function" == typeof a2 ? { fn: a2, options: {} } : { fn: s2, options: { ...a2 } }, m2 = u2.spanName ?? r2;
        if (!n.lw.includes(r2) && "1" !== process.env.NEXT_OTEL_VERBOSE || u2.hideSpan)
          return l2();
        let y2 = this.getSpanContext((null == u2 ? void 0 : u2.parentSpan) ?? this.getActiveScopeSpan()), b2 = false;
        y2 ? (null == (t2 = o.getSpanContext(y2)) ? void 0 : t2.isRemote) && (b2 = true) : (y2 = (null == i ? void 0 : i.active()) ?? c, b2 = true);
        let v = g();
        return u2.attributes = { "next.span_name": m2, "next.span_type": r2, ...u2.attributes }, i.with(y2.setValue(f, v), () => this.getTracerInstance().startActiveSpan(m2, u2, (e3) => {
          let t3 = "performance" in globalThis ? globalThis.performance.now() : void 0, a3 = () => {
            p.delete(v), t3 && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && n.hT.includes(r2 || "") && performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(r2.split(".").pop() || "").replace(/[A-Z]/g, (e4) => "-" + e4.toLowerCase())}`, { start: t3, end: performance.now() });
          };
          b2 && p.set(v, new Map(Object.entries(u2.attributes ?? {})));
          try {
            if (l2.length > 1)
              return l2(e3, (t5) => h(e3, t5));
            let t4 = l2(e3);
            if (d(t4))
              return t4.then((t5) => (e3.end(), t5)).catch((t5) => {
                throw h(e3, t5), t5;
              }).finally(a3);
            return e3.end(), a3(), t4;
          } catch (t4) {
            throw h(e3, t4), a3(), t4;
          }
        }));
      }
      wrap(...e2) {
        let t2 = this, [r2, a2, s2] = 3 === e2.length ? e2 : [e2[0], {}, e2[1]];
        return n.lw.includes(r2) || "1" === process.env.NEXT_OTEL_VERBOSE ? function() {
          let e3 = a2;
          "function" == typeof e3 && "function" == typeof s2 && (e3 = e3.apply(this, arguments));
          let n2 = arguments.length - 1, o2 = arguments[n2];
          if ("function" != typeof o2)
            return t2.trace(r2, e3, () => s2.apply(this, arguments));
          {
            let a3 = t2.getContext().bind(i.active(), o2);
            return t2.trace(r2, e3, (e4, t3) => (arguments[n2] = function(e5) {
              return null == t3 || t3(e5), a3.apply(this, arguments);
            }, s2.apply(this, arguments)));
          }
        } : s2;
      }
      startSpan(...e2) {
        let [t2, r2] = e2, a2 = this.getSpanContext((null == r2 ? void 0 : r2.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(t2, r2, a2);
      }
      getSpanContext(e2) {
        return e2 ? o.setSpan(i.active(), e2) : void 0;
      }
      getRootSpanAttributes() {
        let e2 = i.active().getValue(f);
        return p.get(e2);
      }
    }
    let b = (() => {
      let e2 = new y();
      return () => e2;
    })();
  };
  __namedExportsObject["__chunk_8816"] = (e, t, r) => {
    "use strict";
    var a, n, i, s, o, l, u, c, d, h, p, f;
    r.d(t, { PB: () => h, Xy: () => s, dI: () => f, hT: () => g, k0: () => u, lw: () => m }), function(e2) {
      e2.handleRequest = "BaseServer.handleRequest", e2.run = "BaseServer.run", e2.pipe = "BaseServer.pipe", e2.getStaticHTML = "BaseServer.getStaticHTML", e2.render = "BaseServer.render", e2.renderToResponseWithComponents = "BaseServer.renderToResponseWithComponents", e2.renderToResponse = "BaseServer.renderToResponse", e2.renderToHTML = "BaseServer.renderToHTML", e2.renderError = "BaseServer.renderError", e2.renderErrorToResponse = "BaseServer.renderErrorToResponse", e2.renderErrorToHTML = "BaseServer.renderErrorToHTML", e2.render404 = "BaseServer.render404";
    }(a || (a = {})), function(e2) {
      e2.loadDefaultErrorComponents = "LoadComponents.loadDefaultErrorComponents", e2.loadComponents = "LoadComponents.loadComponents";
    }(n || (n = {})), function(e2) {
      e2.getRequestHandler = "NextServer.getRequestHandler", e2.getServer = "NextServer.getServer", e2.getServerRequestHandler = "NextServer.getServerRequestHandler", e2.createServer = "createServer.createServer";
    }(i || (i = {})), function(e2) {
      e2.compression = "NextNodeServer.compression", e2.getBuildId = "NextNodeServer.getBuildId", e2.createComponentTree = "NextNodeServer.createComponentTree", e2.clientComponentLoading = "NextNodeServer.clientComponentLoading", e2.getLayoutOrPageModule = "NextNodeServer.getLayoutOrPageModule", e2.generateStaticRoutes = "NextNodeServer.generateStaticRoutes", e2.generateFsStaticRoutes = "NextNodeServer.generateFsStaticRoutes", e2.generatePublicRoutes = "NextNodeServer.generatePublicRoutes", e2.generateImageRoutes = "NextNodeServer.generateImageRoutes.route", e2.sendRenderResult = "NextNodeServer.sendRenderResult", e2.proxyRequest = "NextNodeServer.proxyRequest", e2.runApi = "NextNodeServer.runApi", e2.render = "NextNodeServer.render", e2.renderHTML = "NextNodeServer.renderHTML", e2.imageOptimizer = "NextNodeServer.imageOptimizer", e2.getPagePath = "NextNodeServer.getPagePath", e2.getRoutesManifest = "NextNodeServer.getRoutesManifest", e2.findPageComponents = "NextNodeServer.findPageComponents", e2.getFontManifest = "NextNodeServer.getFontManifest", e2.getServerComponentManifest = "NextNodeServer.getServerComponentManifest", e2.getRequestHandler = "NextNodeServer.getRequestHandler", e2.renderToHTML = "NextNodeServer.renderToHTML", e2.renderError = "NextNodeServer.renderError", e2.renderErrorToHTML = "NextNodeServer.renderErrorToHTML", e2.render404 = "NextNodeServer.render404", e2.startResponse = "NextNodeServer.startResponse", e2.route = "route", e2.onProxyReq = "onProxyReq", e2.apiResolver = "apiResolver", e2.internalFetch = "internalFetch";
    }(s || (s = {})), (o || (o = {})).startServer = "startServer.startServer", function(e2) {
      e2.getServerSideProps = "Render.getServerSideProps", e2.getStaticProps = "Render.getStaticProps", e2.renderToString = "Render.renderToString", e2.renderDocument = "Render.renderDocument", e2.createBodyResult = "Render.createBodyResult";
    }(l || (l = {})), function(e2) {
      e2.renderToString = "AppRender.renderToString", e2.renderToReadableStream = "AppRender.renderToReadableStream", e2.getBodyResult = "AppRender.getBodyResult", e2.fetch = "AppRender.fetch";
    }(u || (u = {})), (c || (c = {})).executeRoute = "Router.executeRoute", (d || (d = {})).runHandler = "Node.runHandler", (h || (h = {})).runHandler = "AppRouteRouteHandlers.runHandler", function(e2) {
      e2.generateMetadata = "ResolveMetadata.generateMetadata", e2.generateViewport = "ResolveMetadata.generateViewport";
    }(p || (p = {})), (f || (f = {})).execute = "Middleware.execute";
    let m = ["Middleware.execute", "BaseServer.handleRequest", "Render.getServerSideProps", "Render.getStaticProps", "AppRender.fetch", "AppRender.getBodyResult", "Render.renderDocument", "Node.runHandler", "AppRouteRouteHandlers.runHandler", "ResolveMetadata.generateMetadata", "ResolveMetadata.generateViewport", "NextNodeServer.createComponentTree", "NextNodeServer.findPageComponents", "NextNodeServer.getLayoutOrPageModule", "NextNodeServer.startResponse", "NextNodeServer.clientComponentLoading"], g = ["NextNodeServer.findPageComponents", "NextNodeServer.createComponentTree", "NextNodeServer.clientComponentLoading"];
  };
  __namedExportsObject["__chunk_6631"] = (e, t, r) => {
    "use strict";
    r.d(t, { RQ: () => h, XH: () => f });
    var a = r(8816), n = r(6991), i = r(5927), s = r(1583), o = r(828), l = r(7908);
    function u(e2) {
      if (!e2.body)
        return [e2, e2];
      let [t2, r2] = e2.body.tee(), a2 = new Response(t2, { status: e2.status, statusText: e2.statusText, headers: e2.headers });
      Object.defineProperty(a2, "url", { value: e2.url });
      let n2 = new Response(r2, { status: e2.status, statusText: e2.statusText, headers: e2.headers });
      return Object.defineProperty(n2, "url", { value: e2.url }), [a2, n2];
    }
    var c = r(6195).Buffer;
    let d = (e2) => {
      let t2 = ["/layout"];
      if (e2.startsWith("/")) {
        let r2 = e2.split("/");
        for (let e3 = 1; e3 < r2.length + 1; e3++) {
          let a2 = r2.slice(0, e3).join("/");
          a2 && (a2.endsWith("/page") || a2.endsWith("/route") || (a2 = `${a2}${a2.endsWith("/") ? "" : "/"}layout`), t2.push(a2));
        }
      }
      return t2;
    };
    function h(e2) {
      var t2, r2;
      let a2 = [], { pagePath: n2, urlPathname: s2 } = e2;
      if (Array.isArray(e2.tags) || (e2.tags = []), n2)
        for (let r3 of d(n2))
          r3 = `${i.zt}${r3}`, (null == (t2 = e2.tags) ? void 0 : t2.includes(r3)) || e2.tags.push(r3), a2.push(r3);
      if (s2) {
        let t3 = new URL(s2, "http://n").pathname, n3 = `${i.zt}${t3}`;
        (null == (r2 = e2.tags) ? void 0 : r2.includes(n3)) || e2.tags.push(n3), a2.push(n3);
      }
      return a2;
    }
    function p(e2, t2) {
      var r2;
      e2 && (null == (r2 = e2.requestEndedState) || r2.ended);
    }
    function f(e2) {
      var t2;
      if ("__nextPatched" in (t2 = globalThis.fetch) && true === t2.__nextPatched)
        return;
      let r2 = function(e3) {
        let t3 = l.cache((e4) => []);
        return function(r3, a2) {
          let n2, i2;
          if (a2 && a2.signal)
            return e3(r3, a2);
          if ("string" != typeof r3 || a2) {
            let t4 = "string" == typeof r3 || r3 instanceof URL ? new Request(r3, a2) : r3;
            if ("GET" !== t4.method && "HEAD" !== t4.method || t4.keepalive)
              return e3(r3, a2);
            i2 = JSON.stringify([t4.method, Array.from(t4.headers.entries()), null, t4.redirect, null, t4.referrer, t4.referrerPolicy, null]), n2 = t4.url;
          } else
            i2 = '["GET",[],null,"follow",null,null,null,null]', n2 = r3;
          let s2 = t3(n2);
          for (let e4 = 0, t4 = s2.length; e4 < t4; e4 += 1) {
            let [t5, r4] = s2[e4];
            if (t5 === i2)
              return r4.then(() => {
                let t6 = s2[e4][2];
                if (!t6)
                  throw Error("No cached response");
                let [r5, a3] = u(t6);
                return s2[e4][2] = a3, r5;
              });
          }
          let o2 = new AbortController(), l2 = e3(r3, { ...a2, signal: o2.signal }), c2 = [i2, l2, null];
          return s2.push(c2), l2.then((e4) => {
            let [t4, r4] = u(e4);
            return c2[2] = r4, t4;
          });
        };
      }(globalThis.fetch);
      globalThis.fetch = function(e3, { serverHooks: { DynamicServerError: t3 }, staticGenerationAsyncStorage: r3 }) {
        let l2 = async (l3, d2) => {
          var f2, m;
          let g;
          try {
            (g = new URL(l3 instanceof Request ? l3.url : l3)).username = "", g.password = "";
          } catch {
            g = void 0;
          }
          let y = (null == g ? void 0 : g.href) ?? "", b = Date.now(), v = (null == d2 ? void 0 : null == (f2 = d2.method) ? void 0 : f2.toUpperCase()) || "GET", _ = (null == d2 ? void 0 : null == (m = d2.next) ? void 0 : m.internal) === true, w = "1" === process.env.NEXT_OTEL_FETCH_DISABLED;
          return (0, n.Yz)().trace(_ ? a.Xy.internalFetch : a.k0.fetch, { hideSpan: w, kind: n.MU.CLIENT, spanName: ["fetch", v, y].filter(Boolean).join(" "), attributes: { "http.url": y, "http.method": v, "net.peer.name": null == g ? void 0 : g.hostname, "net.peer.port": (null == g ? void 0 : g.port) || void 0 } }, async () => {
            var a2;
            let n2, f3, m2;
            if (_)
              return e3(l3, d2);
            let g2 = r3.getStore();
            if (!g2 || g2.isDraftMode)
              return e3(l3, d2);
            let v2 = l3 && "object" == typeof l3 && "string" == typeof l3.method, w2 = (e4) => (null == d2 ? void 0 : d2[e4]) || (v2 ? l3[e4] : null), E = (e4) => {
              var t4, r4, a3;
              return void 0 !== (null == d2 ? void 0 : null == (t4 = d2.next) ? void 0 : t4[e4]) ? null == d2 ? void 0 : null == (r4 = d2.next) ? void 0 : r4[e4] : v2 ? null == (a3 = l3.next) ? void 0 : a3[e4] : void 0;
            }, x = E("revalidate"), O = function(e4, t4) {
              let r4 = [], a3 = [];
              for (let n3 = 0; n3 < e4.length; n3++) {
                let s2 = e4[n3];
                if ("string" != typeof s2 ? a3.push({ tag: s2, reason: "invalid type, must be a string" }) : s2.length > i.Ho ? a3.push({ tag: s2, reason: `exceeded max length of ${i.Ho}` }) : r4.push(s2), r4.length > i.cv) {
                  console.warn(`Warning: exceeded max tag count for ${t4}, dropped tags:`, e4.slice(n3).join(", "));
                  break;
                }
              }
              if (a3.length > 0)
                for (let { tag: e5, reason: r5 } of (console.warn(`Warning: invalid tags passed to ${t4}: `), a3))
                  console.log(`tag: "${e5}" ${r5}`);
              return r4;
            }(E("tags") || [], `fetch ${l3.toString()}`);
            if (Array.isArray(O))
              for (let e4 of (g2.tags || (g2.tags = []), O))
                g2.tags.includes(e4) || g2.tags.push(e4);
            let S = h(g2), A = g2.fetchCache, k = !!g2.isUnstableNoStore, T = w2("cache"), P = "";
            "string" == typeof T && void 0 !== x && (v2 && "default" === T || s.ZK(`fetch for ${y} on ${g2.urlPathname} specified "cache: ${T}" and "revalidate: ${x}", only one should be specified.`), T = void 0), "force-cache" === T ? x = false : ("no-cache" === T || "no-store" === T || "force-no-store" === A || "only-no-store" === A) && (x = 0), ("no-cache" === T || "no-store" === T) && (P = `cache: ${T}`), m2 = function(e4, t4) {
              try {
                let r4;
                if (false === e4)
                  r4 = e4;
                else if ("number" == typeof e4 && !isNaN(e4) && e4 > -1)
                  r4 = e4;
                else if (void 0 !== e4)
                  throw Error(`Invalid revalidate value "${e4}" on "${t4}", must be a non-negative number or "false"`);
                return r4;
              } catch (e5) {
                if (e5 instanceof Error && e5.message.includes("Invalid revalidate"))
                  throw e5;
                return;
              }
            }(x, g2.urlPathname);
            let C = w2("headers"), I = "function" == typeof (null == C ? void 0 : C.get) ? C : new Headers(C || {}), R = I.get("authorization") || I.get("cookie"), N = !["get", "head"].includes((null == (a2 = w2("method")) ? void 0 : a2.toLowerCase()) || "get"), $ = (R || N) && 0 === g2.revalidate;
            switch (A) {
              case "force-no-store":
                P = "fetchCache = force-no-store";
                break;
              case "only-no-store":
                if ("force-cache" === T || void 0 !== m2 && (false === m2 || m2 > 0))
                  throw Error(`cache: 'force-cache' used on fetch for ${y} with 'export const fetchCache = 'only-no-store'`);
                P = "fetchCache = only-no-store";
                break;
              case "only-cache":
                if ("no-store" === T)
                  throw Error(`cache: 'no-store' used on fetch for ${y} with 'export const fetchCache = 'only-cache'`);
                break;
              case "force-cache":
                (void 0 === x || 0 === x) && (P = "fetchCache = force-cache", m2 = false);
            }
            void 0 === m2 ? "default-cache" === A ? (m2 = false, P = "fetchCache = default-cache") : $ ? (m2 = 0, P = "auto no cache") : "default-no-store" === A ? (m2 = 0, P = "fetchCache = default-no-store") : k ? (m2 = 0, P = "noStore call") : (P = "auto cache", m2 = "boolean" != typeof g2.revalidate && void 0 !== g2.revalidate && g2.revalidate) : P || (P = `revalidate: ${m2}`), g2.forceStatic && 0 === m2 || $ || void 0 !== g2.revalidate && ("number" != typeof m2 || false !== g2.revalidate && ("number" != typeof g2.revalidate || !(m2 < g2.revalidate))) || (0 === m2 && (0, o.fl)(g2, "revalidate: 0"), g2.revalidate = m2);
            let j = "number" == typeof m2 && m2 > 0 || false === m2;
            if (g2.incrementalCache && j)
              try {
                n2 = await g2.incrementalCache.fetchCacheKey(y, v2 ? l3 : d2);
              } catch (e4) {
                console.error("Failed to generate cache key for", l3);
              }
            let L = g2.nextFetchId ?? 1;
            g2.nextFetchId = L + 1;
            let M = "number" != typeof m2 ? i.BR : m2, D = async (t4, r4) => {
              let a3 = ["credentials", "headers", "integrity", "keepalive", "method", "mode", "redirect", "referrer", "referrerPolicy", "window", "duplex", ...t4 ? [] : ["signal"]];
              if (v2) {
                let e4 = l3, t5 = { body: e4._ogBody || e4.body };
                for (let r5 of a3)
                  t5[r5] = e4[r5];
                l3 = new Request(e4.url, t5);
              } else if (d2) {
                let { _ogBody: e4, body: r5, signal: a4, ...n3 } = d2;
                d2 = { ...n3, body: e4 || r5, signal: t4 ? void 0 : a4 };
              }
              let i2 = { ...d2, next: { ...null == d2 ? void 0 : d2.next, fetchType: "origin", fetchIdx: L } };
              return e3(l3, i2).then(async (e4) => {
                if (t4 || p(g2, { start: b, url: y, cacheReason: r4 || P, cacheStatus: 0 === m2 || r4 ? "skip" : "miss", status: e4.status, method: i2.method || "GET" }), 200 === e4.status && g2.incrementalCache && n2 && j) {
                  let t5 = c.from(await e4.arrayBuffer());
                  try {
                    await g2.incrementalCache.set(n2, { kind: "FETCH", data: { headers: Object.fromEntries(e4.headers.entries()), body: t5.toString("base64"), status: e4.status, url: e4.url }, revalidate: M }, { fetchCache: true, revalidate: m2, fetchUrl: y, fetchIdx: L, tags: O });
                  } catch (e5) {
                    console.warn("Failed to set fetch cache", l3, e5);
                  }
                  let r5 = new Response(t5, { headers: new Headers(e4.headers), status: e4.status });
                  return Object.defineProperty(r5, "url", { value: e4.url }), r5;
                }
                return e4;
              });
            }, U = () => Promise.resolve(), F = false;
            if (n2 && g2.incrementalCache) {
              U = await g2.incrementalCache.lock(n2);
              let e4 = g2.isOnDemandRevalidate ? null : await g2.incrementalCache.get(n2, { kindHint: "fetch", revalidate: m2, fetchUrl: y, fetchIdx: L, tags: O, softTags: S });
              if (e4 ? await U() : f3 = "cache-control: no-cache (hard refresh)", (null == e4 ? void 0 : e4.value) && "FETCH" === e4.value.kind) {
                if (g2.isRevalidate && e4.isStale)
                  F = true;
                else {
                  if (e4.isStale && (g2.pendingRevalidates ??= {}, !g2.pendingRevalidates[n2])) {
                    let e5 = D(true).then(async (e6) => ({ body: await e6.arrayBuffer(), headers: e6.headers, status: e6.status, statusText: e6.statusText })).finally(() => {
                      g2.pendingRevalidates ??= {}, delete g2.pendingRevalidates[n2 || ""];
                    });
                    e5.catch(console.error), g2.pendingRevalidates[n2] = e5;
                  }
                  let t4 = e4.value.data;
                  p(g2, { start: b, url: y, cacheReason: P, cacheStatus: "hit", status: t4.status || 200, method: (null == d2 ? void 0 : d2.method) || "GET" });
                  let r4 = new Response(c.from(t4.body, "base64"), { headers: t4.headers, status: t4.status });
                  return Object.defineProperty(r4, "url", { value: e4.value.data.url }), r4;
                }
              }
            }
            if (g2.isStaticGeneration && d2 && "object" == typeof d2) {
              let { cache: e4 } = d2;
              if (delete d2.cache, !g2.forceStatic && "no-store" === e4) {
                let e5 = `no-store fetch ${l3}${g2.urlPathname ? ` ${g2.urlPathname}` : ""}`;
                (0, o.fl)(g2, e5), g2.revalidate = 0;
                let r5 = new t3(e5);
                throw g2.dynamicUsageErr = r5, g2.dynamicUsageDescription = e5, r5;
              }
              let r4 = "next" in d2, { next: a3 = {} } = d2;
              if ("number" == typeof a3.revalidate && (void 0 === g2.revalidate || "number" == typeof g2.revalidate && a3.revalidate < g2.revalidate)) {
                if (!g2.forceDynamic && !g2.forceStatic && 0 === a3.revalidate) {
                  let e5 = `revalidate: 0 fetch ${l3}${g2.urlPathname ? ` ${g2.urlPathname}` : ""}`;
                  (0, o.fl)(g2, e5);
                  let r5 = new t3(e5);
                  throw g2.dynamicUsageErr = r5, g2.dynamicUsageDescription = e5, r5;
                }
                g2.forceStatic && 0 === a3.revalidate || (g2.revalidate = a3.revalidate);
              }
              r4 && delete d2.next;
            }
            if (!n2 || !F)
              return D(false, f3).finally(U);
            {
              g2.pendingRevalidates ??= {};
              let e4 = g2.pendingRevalidates[n2];
              if (e4) {
                let t5 = await e4;
                return new Response(t5.body, { headers: t5.headers, status: t5.status, statusText: t5.statusText });
              }
              let t4 = D(true, f3).then(u);
              return (e4 = t4.then(async (e5) => {
                let t5 = e5[0];
                return { body: await t5.arrayBuffer(), headers: t5.headers, status: t5.status, statusText: t5.statusText };
              }).finally(() => {
                if (n2) {
                  var e5;
                  (null == (e5 = g2.pendingRevalidates) ? void 0 : e5[n2]) && delete g2.pendingRevalidates[n2];
                }
              })).catch(() => {
              }), g2.pendingRevalidates[n2] = e4, t4.then((e5) => e5[1]);
            }
          });
        };
        return l2.__nextPatched = true, l2.__nextGetStaticStore = () => r3, l2._nextOriginalFetch = e3, l2;
      }(r2, e2);
    }
  };
  __namedExportsObject["__chunk_8403"] = (e, t, r) => {
    "use strict";
    r.d(t, { AppRouteRouteModule: () => j });
    var a, n, i = {};
    r.r(i), r.d(i, { AppRouterContext: () => A, GlobalLayoutRouterContext: () => T, LayoutRouterContext: () => k, MissingSlotContext: () => C, TemplateContext: () => P });
    var s = {};
    r.r(s), r.d(s, { appRouterContext: () => i });
    class o {
      constructor({ userland: e2, definition: t2 }) {
        this.userland = e2, this.definition = t2;
      }
    }
    var l = r(2988), u = r(828);
    let c = { wrap(e2, { urlPathname: t2, renderOpts: r2, requestEndedState: a2 }, n2) {
      let i2 = !r2.supportsDynamicResponse && !r2.isDraftMode && !r2.isServerAction, s2 = i2 && r2.experimental.ppr ? (0, u.FI)(r2.isDebugPPRSkeleton) : null, o2 = { isStaticGeneration: i2, urlPathname: t2, pagePath: r2.originalPathname, incrementalCache: r2.incrementalCache || globalThis.__incrementalCache, isRevalidate: r2.isRevalidate, isPrerendering: r2.nextExport, fetchCache: r2.fetchCache, isOnDemandRevalidate: r2.isOnDemandRevalidate, isDraftMode: r2.isDraftMode, prerenderState: s2, requestEndedState: a2 };
      return r2.store = o2, e2.run(o2, n2, o2);
    } };
    var d = r(6776);
    function h() {
      return new Response(null, { status: 400 });
    }
    function p() {
      return new Response(null, { status: 405 });
    }
    let f = ["GET", "HEAD", "OPTIONS", "POST", "PUT", "DELETE", "PATCH"];
    var m = r(6631), g = r(6991), y = r(8816), b = r(8983);
    let v = (0, r(5228).P)();
    !function(e2) {
      e2[e2.SeeOther = 303] = "SeeOther", e2[e2.TemporaryRedirect = 307] = "TemporaryRedirect", e2[e2.PermanentRedirect = 308] = "PermanentRedirect";
    }(a || (a = {}));
    function _(e2) {
      if ("object" != typeof e2 || null === e2 || !("digest" in e2) || "string" != typeof e2.digest)
        return false;
      let [t2, r2, n2, i2] = e2.digest.split(";", 4), s2 = Number(i2);
      return "NEXT_REDIRECT" === t2 && ("replace" === r2 || "push" === r2) && "string" == typeof n2 && !isNaN(s2) && s2 in a;
    }
    !function(e2) {
      e2.push = "push", e2.replace = "replace";
    }(n || (n = {})), r(1583);
    let w = ["HEAD", "OPTIONS"];
    var E = r(3665), x = r(4363), O = r(9182);
    let S = r(796).createClientModuleProxy, A = S(String.raw`/Users/mac/Desktop/langchain-nextjs-fleek/node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js#AppRouterContext`), k = S(String.raw`/Users/mac/Desktop/langchain-nextjs-fleek/node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js#LayoutRouterContext`), T = S(String.raw`/Users/mac/Desktop/langchain-nextjs-fleek/node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js#GlobalLayoutRouterContext`), P = S(String.raw`/Users/mac/Desktop/langchain-nextjs-fleek/node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js#TemplateContext`), C = S(String.raw`/Users/mac/Desktop/langchain-nextjs-fleek/node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js#MissingSlotContext`);
    var I = r(2039), R = r(676), N = r(8439), $ = r(8042);
    class j extends o {
      static #e = this.sharedModules = s;
      constructor({ userland: e2, definition: t2, resolvedPagePath: r2, nextConfigOutput: a2 }) {
        if (super({ userland: e2, definition: t2 }), this.requestAsyncStorage = b.O, this.staticGenerationAsyncStorage = O.A, this.serverHooks = x, this.actionAsyncStorage = v, this.resolvedPagePath = r2, this.nextConfigOutput = a2, this.methods = function(e3) {
          let t3 = f.reduce((t4, r4) => ({ ...t4, [r4]: e3[r4] ?? p }), {}), r3 = new Set(f.filter((t4) => e3[t4]));
          for (let a3 of w.filter((e4) => !r3.has(e4))) {
            if ("HEAD" === a3) {
              e3.GET && (t3.HEAD = e3.GET, r3.add("HEAD"));
              continue;
            }
            if ("OPTIONS" === a3) {
              let e4 = ["OPTIONS", ...r3];
              !r3.has("HEAD") && r3.has("GET") && e4.push("HEAD");
              let a4 = { Allow: e4.sort().join(", ") };
              t3.OPTIONS = () => new Response(null, { status: 204, headers: a4 }), r3.add("OPTIONS");
              continue;
            }
            throw Error(`Invariant: should handle all automatic implementable methods, got method: ${a3}`);
          }
          return t3;
        }(e2), this.hasNonStaticMethods = function(e3) {
          return !!e3.POST || !!e3.POST || !!e3.DELETE || !!e3.PATCH || !!e3.OPTIONS;
        }(e2), this.dynamic = this.userland.dynamic, "export" === this.nextConfigOutput) {
          if (this.dynamic && "auto" !== this.dynamic) {
            if ("force-dynamic" === this.dynamic)
              throw Error(`export const dynamic = "force-dynamic" on page "${t2.pathname}" cannot be used with "output: export". See more info here: https://nextjs.org/docs/advanced-features/static-html-export`);
          } else
            this.dynamic = "error";
        }
      }
      resolve(e2) {
        return f.includes(e2) ? this.methods[e2] : h;
      }
      async execute(e2, t2) {
        let r2 = this.resolve(e2.method), a2 = { req: e2 };
        a2.renderOpts = { previewProps: t2.prerenderManifest.preview };
        let n2 = { urlPathname: e2.nextUrl.pathname, renderOpts: t2.renderOpts };
        n2.renderOpts.fetchCache = this.userland.fetchCache;
        let i2 = await this.actionAsyncStorage.run({ isAppRoute: true, isAction: function(e3) {
          let t3, r3;
          e3.headers instanceof Headers ? (t3 = e3.headers.get(I.om.toLowerCase()) ?? null, r3 = e3.headers.get("content-type")) : (t3 = e3.headers[I.om.toLowerCase()] ?? null, r3 = e3.headers["content-type"] ?? null);
          let a3 = !!("POST" === e3.method && "application/x-www-form-urlencoded" === r3), n3 = !!("POST" === e3.method && (null == r3 ? void 0 : r3.startsWith("multipart/form-data"))), i3 = !!(void 0 !== t3 && "string" == typeof t3 && "POST" === e3.method);
          return { actionId: t3, isURLEncodedAction: a3, isMultipartAction: n3, isFetchAction: i3, isServerAction: !!(i3 || a3 || n3) };
        }(e2).isServerAction }, () => l.B.wrap(this.requestAsyncStorage, a2, () => c.wrap(this.staticGenerationAsyncStorage, n2, (a3) => {
          var n3;
          let i3 = a3.isStaticGeneration;
          if (this.hasNonStaticMethods) {
            if (i3) {
              let e3 = new x.DynamicServerError("Route is configured with methods that cannot be statically generated.");
              throw a3.dynamicUsageDescription = e3.message, a3.dynamicUsageStack = e3.stack, e3;
            }
            a3.revalidate = 0;
          }
          let s2 = e2;
          switch (this.dynamic) {
            case "force-dynamic":
              a3.forceDynamic = true;
              break;
            case "force-static":
              a3.forceStatic = true, s2 = new Proxy(e2, H);
              break;
            case "error":
              a3.dynamicShouldError = true, i3 && (s2 = new Proxy(e2, G));
              break;
            default:
              s2 = function(e3, t3) {
                let r3 = { get(e4, a5, n4) {
                  switch (a5) {
                    case "search":
                    case "searchParams":
                    case "url":
                    case "href":
                    case "toJSON":
                    case "toString":
                    case "origin":
                      return (0, u.TP)(t3, `nextUrl.${a5}`), $.g.get(e4, a5, n4);
                    case "clone":
                      return e4[D] || (e4[D] = () => new Proxy(e4.clone(), r3));
                    default:
                      return $.g.get(e4, a5, n4);
                  }
                } }, a4 = { get(e4, n4) {
                  switch (n4) {
                    case "nextUrl":
                      return e4[L] || (e4[L] = new Proxy(e4.nextUrl, r3));
                    case "headers":
                    case "cookies":
                    case "url":
                    case "body":
                    case "blob":
                    case "json":
                    case "text":
                    case "arrayBuffer":
                    case "formData":
                      return (0, u.TP)(t3, `request.${n4}`), $.g.get(e4, n4, e4);
                    case "clone":
                      return e4[M] || (e4[M] = () => new Proxy(e4.clone(), a4));
                    default:
                      return $.g.get(e4, n4, e4);
                  }
                } };
                return new Proxy(e3, a4);
              }(e2, a3);
          }
          a3.revalidate ??= this.userland.revalidate ?? false;
          let o2 = function(e3) {
            let t3 = "/app/";
            e3.includes(t3) || (t3 = "\\app\\");
            let [, ...r3] = e3.split(t3);
            return (t3[0] + r3.join(t3)).split(".").slice(0, -1).join(".");
          }(this.resolvedPagePath);
          return null == (n3 = (0, g.Yz)().getRootSpanAttributes()) || n3.set("next.route", o2), (0, g.Yz)().trace(y.PB.runHandler, { spanName: `executing api route (app) ${o2}`, attributes: { "next.route": o2 } }, async () => {
            var e3, n4;
            (0, m.XH)({ serverHooks: this.serverHooks, staticGenerationAsyncStorage: this.staticGenerationAsyncStorage });
            let i4 = await r2(s2, { params: t2.params ? function(e4) {
              let t3 = {};
              for (let [r3, a4] of Object.entries(e4))
                void 0 !== a4 && (t3[r3] = a4);
              return t3;
            }(t2.params) : void 0 });
            if (!(i4 instanceof Response))
              throw Error(`No response is returned from route handler '${this.resolvedPagePath}'. Ensure you return a \`Response\` or a \`NextResponse\` in all branches of your handler.`);
            t2.renderOpts.fetchMetrics = a3.fetchMetrics, t2.renderOpts.waitUntil = Promise.all([null == (e3 = a3.incrementalCache) ? void 0 : e3.revalidateTag(a3.revalidatedTags || []), ...Object.values(a3.pendingRevalidates || {})]), (0, m.RQ)(a3), t2.renderOpts.fetchTags = null == (n4 = a3.tags) ? void 0 : n4.join(",");
            let o3 = this.requestAsyncStorage.getStore();
            if (o3 && o3.mutableCookies) {
              let e4 = new Headers(i4.headers);
              if ((0, d._5)(e4, o3.mutableCookies))
                return new Response(i4.body, { status: i4.status, statusText: i4.statusText, headers: e4 });
            }
            return i4;
          });
        })));
        if (!(i2 instanceof Response))
          return new Response(null, { status: 500 });
        if (i2.headers.has("x-middleware-rewrite"))
          throw Error("NextResponse.rewrite() was used in a app route handler, this is not currently supported. Please remove the invocation to continue.");
        if ("1" === i2.headers.get("x-middleware-next"))
          throw Error("NextResponse.next() was used in a app route handler, this is not supported. See here for more info: https://nextjs.org/docs/messages/next-response-next-in-app-route-handler");
        return i2;
      }
      async handle(e2, t2) {
        try {
          return await this.execute(e2, t2);
        } catch (t3) {
          let e3 = function(e4) {
            if (_(e4)) {
              let t4 = _(e4) ? e4.digest.split(";", 3)[2] : null;
              if (!t4)
                throw Error("Invariant: Unexpected redirect url format");
              let r2 = function(e5) {
                if (!_(e5))
                  throw Error("Not a redirect error");
                return Number(e5.digest.split(";", 4)[3]);
              }(e4);
              return function(e5, t5, r3) {
                let a2 = new Headers({ location: e5 });
                return (0, d._5)(a2, t5), new Response(null, { status: r3, headers: a2 });
              }(t4, e4.mutableCookies, r2);
            }
            return "object" == typeof e4 && null !== e4 && "digest" in e4 && "NEXT_NOT_FOUND" === e4.digest && new Response(null, { status: 404 });
          }(t3);
          if (!e3)
            throw t3;
          return e3;
        }
      }
    }
    let L = Symbol("nextUrl"), M = Symbol("clone"), D = Symbol("clone"), U = Symbol("searchParams"), F = Symbol("href"), z = Symbol("toString"), B = Symbol("headers"), q = Symbol("cookies"), H = { get(e2, t2, r2) {
      switch (t2) {
        case "headers":
          return e2[B] || (e2[B] = E.h.seal(new Headers({})));
        case "cookies":
          return e2[q] || (e2[q] = d.Qb.seal(new R.RequestCookies(new Headers({}))));
        case "nextUrl":
          return e2[L] || (e2[L] = new Proxy(e2.nextUrl, Z));
        case "url":
          return r2.nextUrl.href;
        case "geo":
        case "ip":
          return;
        case "clone":
          return e2[M] || (e2[M] = () => new Proxy(e2.clone(), H));
        default:
          return $.g.get(e2, t2, r2);
      }
    } }, Z = { get(e2, t2, r2) {
      switch (t2) {
        case "search":
          return "";
        case "searchParams":
          return e2[U] || (e2[U] = new URLSearchParams());
        case "href":
          return e2[F] || (e2[F] = function(e3) {
            let t3 = new URL(e3);
            return t3.host = "localhost:3000", t3.search = "", t3.protocol = "http", t3;
          }(e2.href).href);
        case "toJSON":
        case "toString":
          return e2[z] || (e2[z] = () => r2.href);
        case "url":
          return;
        case "clone":
          return e2[D] || (e2[D] = () => new Proxy(e2.clone(), Z));
        default:
          return $.g.get(e2, t2, r2);
      }
    } }, G = { get(e2, t2, r2) {
      switch (t2) {
        case "nextUrl":
          return e2[L] || (e2[L] = new Proxy(e2.nextUrl, V));
        case "headers":
        case "cookies":
        case "url":
        case "body":
        case "blob":
        case "json":
        case "text":
        case "arrayBuffer":
        case "formData":
          throw new N.G(`Route ${e2.nextUrl.pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`request.${t2}\`.`);
        case "clone":
          return e2[M] || (e2[M] = () => new Proxy(e2.clone(), G));
        default:
          return $.g.get(e2, t2, r2);
      }
    } }, V = { get(e2, t2, r2) {
      switch (t2) {
        case "search":
        case "searchParams":
        case "url":
        case "href":
        case "toJSON":
        case "toString":
        case "origin":
          throw new N.G(`Route ${e2.pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`nextUrl.${t2}\`.`);
        case "clone":
          return e2[D] || (e2[D] = () => new Proxy(e2.clone(), V));
        default:
          return $.g.get(e2, t2, r2);
      }
    } };
  };
  __namedExportsObject["__chunk_2561"] = (e, t, r) => {
    e.exports = r(8403);
  };
  __namedExportsObject["__chunk_4828"] = (e, t, r) => {
    "use strict";
    var a;
    r.d(t, { x: () => a }), function(e2) {
      e2.PAGES = "PAGES", e2.PAGES_API = "PAGES_API", e2.APP_PAGE = "APP_PAGE", e2.APP_ROUTE = "APP_ROUTE";
    }(a || (a = {}));
  };
  __namedExportsObject["__chunk_2988"] = (e, t, r) => {
    "use strict";
    r.d(t, { B: () => h });
    var a = r(2039), n = r(3665), i = r(6776), s = r(4101), o = r(5927);
    r(6991), r(8816);
    let l = "__prerender_bypass";
    Symbol("__next_preview_data"), Symbol(l);
    class u {
      constructor(e2, t2, r2, a2) {
        var i2;
        let s2 = e2 && function(e3, t3) {
          let r3 = n.h.from(e3.headers);
          return { isOnDemandRevalidate: r3.get(o.y3) === t3.previewModeId, revalidateOnlyGenerated: r3.has(o.Qq) };
        }(t2, e2).isOnDemandRevalidate, u2 = null == (i2 = r2.get(l)) ? void 0 : i2.value;
        this.isEnabled = !!(!s2 && u2 && e2 && u2 === e2.previewModeId), this._previewModeId = null == e2 ? void 0 : e2.previewModeId, this._mutableCookies = a2;
      }
      enable() {
        if (!this._previewModeId)
          throw Error("Invariant: previewProps missing previewModeId this should never happen");
        this._mutableCookies.set({ name: l, value: this._previewModeId, httpOnly: true, sameSite: "none", secure: true, path: "/" });
      }
      disable() {
        this._mutableCookies.set({ name: l, value: "", httpOnly: true, sameSite: "none", secure: true, path: "/", expires: new Date(0) });
      }
    }
    var c = r(9573);
    function d(e2, t2) {
      if ("x-middleware-set-cookie" in e2.headers && "string" == typeof e2.headers["x-middleware-set-cookie"]) {
        let r2 = e2.headers["x-middleware-set-cookie"], a2 = new Headers();
        for (let e3 of (0, c.l$)(r2))
          a2.append("set-cookie", e3);
        for (let e3 of new s.nV(a2).getAll())
          t2.set(e3);
      }
    }
    let h = { wrap(e2, { req: t2, res: r2, renderOpts: o2 }, l2) {
      let c2;
      function h2(e3) {
        r2 && r2.setHeader("Set-Cookie", e3);
      }
      o2 && "previewProps" in o2 && (c2 = o2.previewProps);
      let p = {}, f = { get headers() {
        return p.headers || (p.headers = function(e3) {
          let t3 = n.h.from(e3);
          for (let e4 of a.vu)
            t3.delete(e4.toString().toLowerCase());
          return n.h.seal(t3);
        }(t2.headers)), p.headers;
      }, get cookies() {
        if (!p.cookies) {
          let e3 = new s.qC(n.h.from(t2.headers));
          d(t2, e3), p.cookies = i.Qb.seal(e3);
        }
        return p.cookies;
      }, get mutableCookies() {
        if (!p.mutableCookies) {
          let e3 = function(e4, t3) {
            let r3 = new s.qC(n.h.from(e4));
            return i.vr.wrap(r3, t3);
          }(t2.headers, (null == o2 ? void 0 : o2.onUpdateCookies) || (r2 ? h2 : void 0));
          d(t2, e3), p.mutableCookies = e3;
        }
        return p.mutableCookies;
      }, get draftMode() {
        return p.draftMode || (p.draftMode = new u(c2, t2, this.cookies, this.mutableCookies)), p.draftMode;
      }, reactLoadableManifest: (null == o2 ? void 0 : o2.reactLoadableManifest) || {}, assetPrefix: (null == o2 ? void 0 : o2.assetPrefix) || "" };
      return e2.run(f, l2, f);
    } };
  };
  __namedExportsObject["__chunk_828"] = (e, t, r) => {
    "use strict";
    r.d(t, { FI: () => o, TP: () => l, fl: () => u });
    var a = r(7908), n = r(4363), i = r(8439);
    let s = "function" == typeof a.unstable_postpone;
    function o(e2) {
      return { isDebugSkeleton: e2, dynamicAccesses: [] };
    }
    function l(e2, t2) {
      let r2 = new URL(e2.urlPathname, "http://n").pathname;
      if (e2.isUnstableCacheCallback)
        throw Error(`Route ${r2} used "${t2}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${t2}" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
      if (e2.dynamicShouldError)
        throw new i.G(`Route ${r2} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${t2}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
      if (e2.prerenderState)
        c(e2.prerenderState, t2, r2);
      else if (e2.revalidate = 0, e2.isStaticGeneration) {
        let a2 = new n.DynamicServerError(`Route ${r2} couldn't be rendered statically because it used \`${t2}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
        throw e2.dynamicUsageDescription = t2, e2.dynamicUsageStack = a2.stack, a2;
      }
    }
    function u(e2, t2) {
      e2.prerenderState && c(e2.prerenderState, t2, e2.urlPathname);
    }
    function c(e2, t2, r2) {
      !function() {
        if (!s)
          throw Error("Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js");
      }();
      let n2 = `Route ${r2} needs to bail out of prerendering at this point because it used ${t2}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
      e2.dynamicAccesses.push({ stack: e2.isDebugSkeleton ? Error().stack : void 0, expression: t2 }), a.unstable_postpone(n2);
    }
  };
  __namedExportsObject["__chunk_5927"] = (e, t, r) => {
    "use strict";
    r.d(t, { Ar: () => d, BR: () => y, EX: () => u, Et: () => c, Ho: () => m, JT: () => l, Qq: () => i, Sx: () => s, X_: () => p, cv: () => f, dN: () => a, hd: () => o, of: () => h, y3: () => n, zt: () => g });
    let a = "nxtP", n = "x-prerender-revalidate", i = "x-prerender-revalidate-if-generated", s = ".prefetch.rsc", o = ".rsc", l = ".json", u = ".meta", c = "x-next-cache-tags", d = "x-next-cache-soft-tags", h = "x-next-revalidated-tags", p = "x-next-revalidate-tag-token", f = 128, m = 256, g = "_N_T_", y = 31536e3, b = { shared: "shared", reactServerComponents: "rsc", serverSideRendering: "ssr", actionBrowser: "action-browser", api: "api", middleware: "middleware", instrument: "instrument", edgeAsset: "edge-asset", appPagesBrowser: "app-pages-browser", appMetadataRoute: "app-metadata-route", appRouteHandler: "app-route-handler" };
    ({ ...b, GROUP: { serverOnly: [b.reactServerComponents, b.actionBrowser, b.appMetadataRoute, b.appRouteHandler, b.instrument], clientOnly: [b.serverSideRendering, b.appPagesBrowser], nonClientServerTarget: [b.middleware, b.api], app: [b.reactServerComponents, b.actionBrowser, b.appMetadataRoute, b.appRouteHandler, b.serverSideRendering, b.appPagesBrowser, b.shared, b.instrument] } });
  };
  __namedExportsObject["__chunk_8439"] = (e, t, r) => {
    "use strict";
    r.d(t, { G: () => a });
    class a extends Error {
      constructor(...e2) {
        super(...e2), this.code = "NEXT_STATIC_GEN_BAILOUT";
      }
    }
  };
  __namedExportsObject["__chunk_4363"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { DynamicServerError: () => n, isDynamicServerError: () => i });
    let a = "DYNAMIC_SERVER_USAGE";
    class n extends Error {
      constructor(e2) {
        super("Dynamic server usage: " + e2), this.description = e2, this.digest = a;
      }
    }
    function i(e2) {
      return "object" == typeof e2 && null !== e2 && "digest" in e2 && "string" == typeof e2.digest && e2.digest === a;
    }
  };
  __namedExportsObject["__chunk_2039"] = (e, t, r) => {
    "use strict";
    r.d(t, { H4: () => i, om: () => a, vu: () => n });
    let a = "Next-Action", n = [["RSC"], ["Next-Router-State-Tree"], ["Next-Router-Prefetch"]], i = "_rsc";
  };
  __namedExportsObject["__chunk_1583"] = (e, t, r) => {
    "use strict";
    var a;
    r.d(t, { ZK: () => y });
    let { env: n, stdout: i } = (null == (a = globalThis) ? void 0 : a.process) ?? {}, s = n && !n.NO_COLOR && (n.FORCE_COLOR || (null == i ? void 0 : i.isTTY) && !n.CI && "dumb" !== n.TERM), o = (e2, t2, r2, a2) => {
      let n2 = e2.substring(0, a2) + r2, i2 = e2.substring(a2 + t2.length), s2 = i2.indexOf(t2);
      return ~s2 ? n2 + o(i2, t2, r2, s2) : n2 + i2;
    }, l = (e2, t2, r2 = e2) => s ? (a2) => {
      let n2 = "" + a2, i2 = n2.indexOf(t2, e2.length);
      return ~i2 ? e2 + o(n2, t2, r2, i2) + t2 : e2 + n2 + t2;
    } : String, u = l("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m");
    l("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"), l("\x1B[3m", "\x1B[23m"), l("\x1B[4m", "\x1B[24m"), l("\x1B[7m", "\x1B[27m"), l("\x1B[8m", "\x1B[28m"), l("\x1B[9m", "\x1B[29m"), l("\x1B[30m", "\x1B[39m");
    let c = l("\x1B[31m", "\x1B[39m"), d = l("\x1B[32m", "\x1B[39m"), h = l("\x1B[33m", "\x1B[39m");
    l("\x1B[34m", "\x1B[39m");
    let p = l("\x1B[35m", "\x1B[39m");
    l("\x1B[38;2;173;127;168m", "\x1B[39m"), l("\x1B[36m", "\x1B[39m");
    let f = l("\x1B[37m", "\x1B[39m");
    l("\x1B[90m", "\x1B[39m"), l("\x1B[40m", "\x1B[49m"), l("\x1B[41m", "\x1B[49m"), l("\x1B[42m", "\x1B[49m"), l("\x1B[43m", "\x1B[49m"), l("\x1B[44m", "\x1B[49m"), l("\x1B[45m", "\x1B[49m"), l("\x1B[46m", "\x1B[49m"), l("\x1B[47m", "\x1B[49m");
    let m = { wait: f(u("\u25CB")), error: c(u("\u2A2F")), warn: h(u("\u26A0")), ready: "\u25B2", info: f(u(" ")), event: d(u("\u2713")), trace: p(u("\xBB")) }, g = { log: "log", warn: "warn", error: "error" };
    function y(...e2) {
      !function(e3, ...t2) {
        ("" === t2[0] || void 0 === t2[0]) && 1 === t2.length && t2.shift();
        let r2 = e3 in g ? g[e3] : "log", a2 = m[e3];
        0 === t2.length ? console[r2]("") : console[r2](" " + a2, ...t2);
      }("warn", ...e2);
    }
  };
  __namedExportsObject["__chunk_9985"] = (e, t, r) => {
    "use strict";
    r.d(t, { xk: () => a.x }), r(662);
    var a = r(7701);
    r(4155), "undefined" == typeof URLPattern || URLPattern;
  };
  __namedExportsObject["__chunk_4155"] = (e, t, r) => {
    var a;
    (() => {
      var n = { 226: function(n2, i2) {
        !function(s2, o2) {
          "use strict";
          var l = "function", u = "undefined", c = "object", d = "string", h = "major", p = "model", f = "name", m = "type", g = "vendor", y = "version", b = "architecture", v = "console", _ = "mobile", w = "tablet", E = "smarttv", x = "wearable", O = "embedded", S = "Amazon", A = "Apple", k = "ASUS", T = "BlackBerry", P = "Browser", C = "Chrome", I = "Firefox", R = "Google", N = "Huawei", $ = "Microsoft", j = "Motorola", L = "Opera", M = "Samsung", D = "Sharp", U = "Sony", F = "Xiaomi", z = "Zebra", B = "Facebook", q = "Chromium OS", H = "Mac OS", Z = function(e2, t2) {
            var r2 = {};
            for (var a2 in e2)
              t2[a2] && t2[a2].length % 2 == 0 ? r2[a2] = t2[a2].concat(e2[a2]) : r2[a2] = e2[a2];
            return r2;
          }, G = function(e2) {
            for (var t2 = {}, r2 = 0; r2 < e2.length; r2++)
              t2[e2[r2].toUpperCase()] = e2[r2];
            return t2;
          }, V = function(e2, t2) {
            return typeof e2 === d && -1 !== W(t2).indexOf(W(e2));
          }, W = function(e2) {
            return e2.toLowerCase();
          }, J = function(e2, t2) {
            if (typeof e2 === d)
              return e2 = e2.replace(/^\s\s*/, ""), typeof t2 === u ? e2 : e2.substring(0, 350);
          }, K = function(e2, t2) {
            for (var r2, a2, n3, i3, s3, u2, d2 = 0; d2 < t2.length && !s3; ) {
              var h2 = t2[d2], p2 = t2[d2 + 1];
              for (r2 = a2 = 0; r2 < h2.length && !s3 && h2[r2]; )
                if (s3 = h2[r2++].exec(e2))
                  for (n3 = 0; n3 < p2.length; n3++)
                    u2 = s3[++a2], typeof (i3 = p2[n3]) === c && i3.length > 0 ? 2 === i3.length ? typeof i3[1] == l ? this[i3[0]] = i3[1].call(this, u2) : this[i3[0]] = i3[1] : 3 === i3.length ? typeof i3[1] !== l || i3[1].exec && i3[1].test ? this[i3[0]] = u2 ? u2.replace(i3[1], i3[2]) : void 0 : this[i3[0]] = u2 ? i3[1].call(this, u2, i3[2]) : void 0 : 4 === i3.length && (this[i3[0]] = u2 ? i3[3].call(this, u2.replace(i3[1], i3[2])) : void 0) : this[i3] = u2 || o2;
              d2 += 2;
            }
          }, X = function(e2, t2) {
            for (var r2 in t2)
              if (typeof t2[r2] === c && t2[r2].length > 0) {
                for (var a2 = 0; a2 < t2[r2].length; a2++)
                  if (V(t2[r2][a2], e2))
                    return "?" === r2 ? o2 : r2;
              } else if (V(t2[r2], e2))
                return "?" === r2 ? o2 : r2;
            return e2;
          }, Y = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, Q = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [y, [f, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [y, [f, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [f, y], [/opios[\/ ]+([\w\.]+)/i], [y, [f, L + " Mini"]], [/\bopr\/([\w\.]+)/i], [y, [f, L]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [f, y], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [y, [f, "UC" + P]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [y, [f, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [y, [f, "WeChat"]], [/konqueror\/([\w\.]+)/i], [y, [f, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [y, [f, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [y, [f, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[f, /(.+)/, "$1 Secure " + P], y], [/\bfocus\/([\w\.]+)/i], [y, [f, I + " Focus"]], [/\bopt\/([\w\.]+)/i], [y, [f, L + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [y, [f, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [y, [f, "Dolphin"]], [/coast\/([\w\.]+)/i], [y, [f, L + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [y, [f, "MIUI " + P]], [/fxios\/([-\w\.]+)/i], [y, [f, I]], [/\bqihu|(qi?ho?o?|360)browser/i], [[f, "360 " + P]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[f, /(.+)/, "$1 " + P], y], [/(comodo_dragon)\/([\w\.]+)/i], [[f, /_/g, " "], y], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [f, y], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [f], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[f, B], y], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [f, y], [/\bgsa\/([\w\.]+) .*safari\//i], [y, [f, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [y, [f, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [y, [f, C + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[f, C + " WebView"], y], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [y, [f, "Android " + P]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [f, y], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [y, [f, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [y, f], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [f, [y, X, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [f, y], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[f, "Netscape"], y], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [y, [f, I + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [f, y], [/(cobalt)\/([\w\.]+)/i], [f, [y, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[b, "amd64"]], [/(ia32(?=;))/i], [[b, W]], [/((?:i[346]|x)86)[;\)]/i], [[b, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[b, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[b, "armhf"]], [/windows (ce|mobile); ppc;/i], [[b, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[b, /ower/, "", W]], [/(sun4\w)[;\)]/i], [[b, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[b, W]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [p, [g, M], [m, w]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [p, [g, M], [m, _]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [p, [g, A], [m, _]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [p, [g, A], [m, w]], [/(macintosh);/i], [p, [g, A]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [p, [g, D], [m, _]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [p, [g, N], [m, w]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [p, [g, N], [m, _]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[p, /_/g, " "], [g, F], [m, _]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[p, /_/g, " "], [g, F], [m, w]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [p, [g, "OPPO"], [m, _]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [p, [g, "Vivo"], [m, _]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [p, [g, "Realme"], [m, _]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [p, [g, j], [m, _]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [p, [g, j], [m, w]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [p, [g, "LG"], [m, w]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [p, [g, "LG"], [m, _]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [p, [g, "Lenovo"], [m, w]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[p, /_/g, " "], [g, "Nokia"], [m, _]], [/(pixel c)\b/i], [p, [g, R], [m, w]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [p, [g, R], [m, _]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [p, [g, U], [m, _]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[p, "Xperia Tablet"], [g, U], [m, w]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [p, [g, "OnePlus"], [m, _]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [p, [g, S], [m, w]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[p, /(.+)/g, "Fire Phone $1"], [g, S], [m, _]], [/(playbook);[-\w\),; ]+(rim)/i], [p, g, [m, w]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [p, [g, T], [m, _]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [p, [g, k], [m, w]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [p, [g, k], [m, _]], [/(nexus 9)/i], [p, [g, "HTC"], [m, w]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [g, [p, /_/g, " "], [m, _]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [p, [g, "Acer"], [m, w]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [p, [g, "Meizu"], [m, _]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [g, p, [m, _]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [g, p, [m, w]], [/(surface duo)/i], [p, [g, $], [m, w]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [p, [g, "Fairphone"], [m, _]], [/(u304aa)/i], [p, [g, "AT&T"], [m, _]], [/\bsie-(\w*)/i], [p, [g, "Siemens"], [m, _]], [/\b(rct\w+) b/i], [p, [g, "RCA"], [m, w]], [/\b(venue[\d ]{2,7}) b/i], [p, [g, "Dell"], [m, w]], [/\b(q(?:mv|ta)\w+) b/i], [p, [g, "Verizon"], [m, w]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [p, [g, "Barnes & Noble"], [m, w]], [/\b(tm\d{3}\w+) b/i], [p, [g, "NuVision"], [m, w]], [/\b(k88) b/i], [p, [g, "ZTE"], [m, w]], [/\b(nx\d{3}j) b/i], [p, [g, "ZTE"], [m, _]], [/\b(gen\d{3}) b.+49h/i], [p, [g, "Swiss"], [m, _]], [/\b(zur\d{3}) b/i], [p, [g, "Swiss"], [m, w]], [/\b((zeki)?tb.*\b) b/i], [p, [g, "Zeki"], [m, w]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[g, "Dragon Touch"], p, [m, w]], [/\b(ns-?\w{0,9}) b/i], [p, [g, "Insignia"], [m, w]], [/\b((nxa|next)-?\w{0,9}) b/i], [p, [g, "NextBook"], [m, w]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[g, "Voice"], p, [m, _]], [/\b(lvtel\-)?(v1[12]) b/i], [[g, "LvTel"], p, [m, _]], [/\b(ph-1) /i], [p, [g, "Essential"], [m, _]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [p, [g, "Envizen"], [m, w]], [/\b(trio[-\w\. ]+) b/i], [p, [g, "MachSpeed"], [m, w]], [/\btu_(1491) b/i], [p, [g, "Rotor"], [m, w]], [/(shield[\w ]+) b/i], [p, [g, "Nvidia"], [m, w]], [/(sprint) (\w+)/i], [g, p, [m, _]], [/(kin\.[onetw]{3})/i], [[p, /\./g, " "], [g, $], [m, _]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [p, [g, z], [m, w]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [p, [g, z], [m, _]], [/smart-tv.+(samsung)/i], [g, [m, E]], [/hbbtv.+maple;(\d+)/i], [[p, /^/, "SmartTV"], [g, M], [m, E]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[g, "LG"], [m, E]], [/(apple) ?tv/i], [g, [p, A + " TV"], [m, E]], [/crkey/i], [[p, C + "cast"], [g, R], [m, E]], [/droid.+aft(\w)( bui|\))/i], [p, [g, S], [m, E]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [p, [g, D], [m, E]], [/(bravia[\w ]+)( bui|\))/i], [p, [g, U], [m, E]], [/(mitv-\w{5}) bui/i], [p, [g, F], [m, E]], [/Hbbtv.*(technisat) (.*);/i], [g, p, [m, E]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[g, J], [p, J], [m, E]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[m, E]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [g, p, [m, v]], [/droid.+; (shield) bui/i], [p, [g, "Nvidia"], [m, v]], [/(playstation [345portablevi]+)/i], [p, [g, U], [m, v]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [p, [g, $], [m, v]], [/((pebble))app/i], [g, p, [m, x]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [p, [g, A], [m, x]], [/droid.+; (glass) \d/i], [p, [g, R], [m, x]], [/droid.+; (wt63?0{2,3})\)/i], [p, [g, z], [m, x]], [/(quest( 2| pro)?)/i], [p, [g, B], [m, x]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [g, [m, O]], [/(aeobc)\b/i], [p, [g, S], [m, O]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [p, [m, _]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [p, [m, w]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[m, w]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[m, _]], [/(android[-\w\. ]{0,9});.+buil/i], [p, [g, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [y, [f, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [y, [f, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [f, y], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [y, f]], os: [[/microsoft (windows) (vista|xp)/i], [f, y], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [f, [y, X, Y]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[f, "Windows"], [y, X, Y]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /ios;fbsv\/([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[y, /_/g, "."], [f, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[f, H], [y, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [y, f], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [f, y], [/\(bb(10);/i], [y, [f, T]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [y, [f, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [y, [f, I + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [y, [f, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [y, [f, "watchOS"]], [/crkey\/([\d\.]+)/i], [y, [f, C + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[f, q], y], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [f, y], [/(sunos) ?([\w\.\d]*)/i], [[f, "Solaris"], y], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [f, y]] }, ee = function(e2, t2) {
            if (typeof e2 === c && (t2 = e2, e2 = o2), !(this instanceof ee))
              return new ee(e2, t2).getResult();
            var r2 = typeof s2 !== u && s2.navigator ? s2.navigator : o2, a2 = e2 || (r2 && r2.userAgent ? r2.userAgent : ""), n3 = r2 && r2.userAgentData ? r2.userAgentData : o2, i3 = t2 ? Z(Q, t2) : Q, v2 = r2 && r2.userAgent == a2;
            return this.getBrowser = function() {
              var e3, t3 = {};
              return t3[f] = o2, t3[y] = o2, K.call(t3, a2, i3.browser), t3[h] = typeof (e3 = t3[y]) === d ? e3.replace(/[^\d\.]/g, "").split(".")[0] : o2, v2 && r2 && r2.brave && typeof r2.brave.isBrave == l && (t3[f] = "Brave"), t3;
            }, this.getCPU = function() {
              var e3 = {};
              return e3[b] = o2, K.call(e3, a2, i3.cpu), e3;
            }, this.getDevice = function() {
              var e3 = {};
              return e3[g] = o2, e3[p] = o2, e3[m] = o2, K.call(e3, a2, i3.device), v2 && !e3[m] && n3 && n3.mobile && (e3[m] = _), v2 && "Macintosh" == e3[p] && r2 && typeof r2.standalone !== u && r2.maxTouchPoints && r2.maxTouchPoints > 2 && (e3[p] = "iPad", e3[m] = w), e3;
            }, this.getEngine = function() {
              var e3 = {};
              return e3[f] = o2, e3[y] = o2, K.call(e3, a2, i3.engine), e3;
            }, this.getOS = function() {
              var e3 = {};
              return e3[f] = o2, e3[y] = o2, K.call(e3, a2, i3.os), v2 && !e3[f] && n3 && "Unknown" != n3.platform && (e3[f] = n3.platform.replace(/chrome os/i, q).replace(/macos/i, H)), e3;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return a2;
            }, this.setUA = function(e3) {
              return a2 = typeof e3 === d && e3.length > 350 ? J(e3, 350) : e3, this;
            }, this.setUA(a2), this;
          };
          ee.VERSION = "1.0.35", ee.BROWSER = G([f, y, h]), ee.CPU = G([b]), ee.DEVICE = G([p, g, m, v, _, E, w, x, O]), ee.ENGINE = ee.OS = G([f, y]), typeof i2 !== u ? (n2.exports && (i2 = n2.exports = ee), i2.UAParser = ee) : r.amdO ? void 0 !== (a = function() {
            return ee;
          }.call(t, r, t, e)) && (e.exports = a) : typeof s2 !== u && (s2.UAParser = ee);
          var et = typeof s2 !== u && (s2.jQuery || s2.Zepto);
          if (et && !et.ua) {
            var er = new ee();
            et.ua = er.getResult(), et.ua.get = function() {
              return er.getUA();
            }, et.ua.set = function(e2) {
              er.setUA(e2);
              var t2 = er.getResult();
              for (var r2 in t2)
                et.ua[r2] = t2[r2];
            };
          }
        }("object" == typeof window ? window : this);
      } }, i = {};
      function s(e2) {
        var t2 = i[e2];
        if (void 0 !== t2)
          return t2.exports;
        var r2 = i[e2] = { exports: {} }, a2 = true;
        try {
          n[e2].call(r2.exports, r2, r2.exports, s), a2 = false;
        } finally {
          a2 && delete i[e2];
        }
        return r2.exports;
      }
      s.ab = "//";
      var o = s(226);
      e.exports = o;
    })();
  };
  __namedExportsObject["__chunk_7908"] = (e, t, r) => {
    "use strict";
    e.exports = r(8949);
  };
  __namedExportsObject["__chunk_8949"] = (e, t) => {
    "use strict";
    var r = Object.assign, a = { current: null };
    function n() {
      return /* @__PURE__ */ new Map();
    }
    if ("function" == typeof fetch) {
      var i = fetch, s = function(e2, t2) {
        var r2 = a.current;
        if (!r2 || t2 && t2.signal && t2.signal !== r2.getCacheSignal())
          return i(e2, t2);
        if ("string" != typeof e2 || t2) {
          var s2 = "string" == typeof e2 || e2 instanceof URL ? new Request(e2, t2) : e2;
          if ("GET" !== s2.method && "HEAD" !== s2.method || s2.keepalive)
            return i(e2, t2);
          var o2 = JSON.stringify([s2.method, Array.from(s2.headers.entries()), null, s2.redirect, null, s2.referrer, s2.referrerPolicy, null]);
          s2 = s2.url;
        } else
          o2 = '["GET",[],null,"follow",null,null,null,null]', s2 = e2;
        var l2 = r2.getCacheForType(n);
        if (void 0 === (r2 = l2.get(s2)))
          e2 = i(e2, t2), l2.set(s2, [o2, e2]);
        else {
          for (s2 = 0, l2 = r2.length; s2 < l2; s2 += 2) {
            var u2 = r2[s2 + 1];
            if (r2[s2] === o2)
              return (e2 = u2).then(function(e3) {
                return e3.clone();
              });
          }
          e2 = i(e2, t2), r2.push(o2, e2);
        }
        return e2.then(function(e3) {
          return e3.clone();
        });
      };
      r(s, i);
      try {
        fetch = s;
      } catch (e2) {
        try {
          globalThis.fetch = s;
        } catch (e3) {
          console.warn("React was unable to patch the fetch() function in this environment. Suspensey APIs might not work correctly as a result.");
        }
      }
    }
    var o = { current: null }, l = { ReactCurrentDispatcher: o, ReactCurrentOwner: { current: null } };
    function u(e2) {
      var t2 = "https://react.dev/errors/" + e2;
      if (1 < arguments.length) {
        t2 += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var r2 = 2; r2 < arguments.length; r2++)
          t2 += "&args[]=" + encodeURIComponent(arguments[r2]);
      }
      return "Minified React error #" + e2 + "; visit " + t2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var c = Array.isArray, d = Symbol.for("react.element"), h = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), m = Symbol.for("react.profiler"), g = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), b = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), _ = Symbol.iterator, w = Object.prototype.hasOwnProperty, E = l.ReactCurrentOwner;
    function x(e2) {
      return "object" == typeof e2 && null !== e2 && e2.$$typeof === d;
    }
    var O = /\/+/g;
    function S(e2, t2) {
      var r2, a2;
      return "object" == typeof e2 && null !== e2 && null != e2.key ? (r2 = "" + e2.key, a2 = { "=": "=0", ":": "=2" }, "$" + r2.replace(/[=:]/g, function(e3) {
        return a2[e3];
      })) : t2.toString(36);
    }
    function A() {
    }
    function k(e2, t2, r2) {
      if (null == e2)
        return e2;
      var a2 = [], n2 = 0;
      return !function e3(t3, r3, a3, n3, i2) {
        var s2, o2, l2, p2 = typeof t3;
        ("undefined" === p2 || "boolean" === p2) && (t3 = null);
        var f2 = false;
        if (null === t3)
          f2 = true;
        else
          switch (p2) {
            case "string":
            case "number":
              f2 = true;
              break;
            case "object":
              switch (t3.$$typeof) {
                case d:
                case h:
                  f2 = true;
                  break;
                case v:
                  return e3((f2 = t3._init)(t3._payload), r3, a3, n3, i2);
              }
          }
        if (f2)
          return i2 = i2(t3), f2 = "" === n3 ? "." + S(t3, 0) : n3, c(i2) ? (a3 = "", null != f2 && (a3 = f2.replace(O, "$&/") + "/"), e3(i2, r3, a3, "", function(e4) {
            return e4;
          })) : null != i2 && (x(i2) && (s2 = i2, o2 = a3 + (!i2.key || t3 && t3.key === i2.key ? "" : ("" + i2.key).replace(O, "$&/") + "/") + f2, i2 = { $$typeof: d, type: s2.type, key: o2, ref: s2.ref, props: s2.props, _owner: s2._owner }), r3.push(i2)), 1;
        f2 = 0;
        var m2 = "" === n3 ? "." : n3 + ":";
        if (c(t3))
          for (var g2 = 0; g2 < t3.length; g2++)
            p2 = m2 + S(n3 = t3[g2], g2), f2 += e3(n3, r3, a3, p2, i2);
        else if ("function" == typeof (g2 = null === (l2 = t3) || "object" != typeof l2 ? null : "function" == typeof (l2 = _ && l2[_] || l2["@@iterator"]) ? l2 : null))
          for (t3 = g2.call(t3), g2 = 0; !(n3 = t3.next()).done; )
            p2 = m2 + S(n3 = n3.value, g2++), f2 += e3(n3, r3, a3, p2, i2);
        else if ("object" === p2) {
          if ("function" == typeof t3.then)
            return e3(function(e4) {
              switch (e4.status) {
                case "fulfilled":
                  return e4.value;
                case "rejected":
                  throw e4.reason;
                default:
                  switch ("string" == typeof e4.status ? e4.then(A, A) : (e4.status = "pending", e4.then(function(t4) {
                    "pending" === e4.status && (e4.status = "fulfilled", e4.value = t4);
                  }, function(t4) {
                    "pending" === e4.status && (e4.status = "rejected", e4.reason = t4);
                  })), e4.status) {
                    case "fulfilled":
                      return e4.value;
                    case "rejected":
                      throw e4.reason;
                  }
              }
              throw e4;
            }(t3), r3, a3, n3, i2);
          throw Error(u(31, "[object Object]" === (r3 = String(t3)) ? "object with keys {" + Object.keys(t3).join(", ") + "}" : r3));
        }
        return f2;
      }(e2, a2, "", "", function(e3) {
        return t2.call(r2, e3, n2++);
      }), a2;
    }
    function T(e2) {
      if (-1 === e2._status) {
        var t2 = e2._result;
        (t2 = t2()).then(function(t3) {
          (0 === e2._status || -1 === e2._status) && (e2._status = 1, e2._result = t3);
        }, function(t3) {
          (0 === e2._status || -1 === e2._status) && (e2._status = 2, e2._result = t3);
        }), -1 === e2._status && (e2._status = 0, e2._result = t2);
      }
      if (1 === e2._status)
        return e2._result.default;
      throw e2._result;
    }
    function P() {
      return /* @__PURE__ */ new WeakMap();
    }
    function C() {
      return { s: 0, v: void 0, o: null, p: null };
    }
    var I = { transition: null };
    function R() {
    }
    var N = "function" == typeof reportError ? reportError : function(e2) {
      console.error(e2);
    };
    t.Children = { map: k, forEach: function(e2, t2, r2) {
      k(e2, function() {
        t2.apply(this, arguments);
      }, r2);
    }, count: function(e2) {
      var t2 = 0;
      return k(e2, function() {
        t2++;
      }), t2;
    }, toArray: function(e2) {
      return k(e2, function(e3) {
        return e3;
      }) || [];
    }, only: function(e2) {
      if (!x(e2))
        throw Error(u(143));
      return e2;
    } }, t.Fragment = p, t.Profiler = m, t.StrictMode = f, t.Suspense = y, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = l, t.__SECRET_SERVER_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = { ReactCurrentCache: a }, t.cache = function(e2) {
      return function() {
        var t2 = a.current;
        if (!t2)
          return e2.apply(null, arguments);
        var r2 = t2.getCacheForType(P);
        void 0 === (t2 = r2.get(e2)) && (t2 = C(), r2.set(e2, t2)), r2 = 0;
        for (var n2 = arguments.length; r2 < n2; r2++) {
          var i2 = arguments[r2];
          if ("function" == typeof i2 || "object" == typeof i2 && null !== i2) {
            var s2 = t2.o;
            null === s2 && (t2.o = s2 = /* @__PURE__ */ new WeakMap()), void 0 === (t2 = s2.get(i2)) && (t2 = C(), s2.set(i2, t2));
          } else
            null === (s2 = t2.p) && (t2.p = s2 = /* @__PURE__ */ new Map()), void 0 === (t2 = s2.get(i2)) && (t2 = C(), s2.set(i2, t2));
        }
        if (1 === t2.s)
          return t2.v;
        if (2 === t2.s)
          throw t2.v;
        try {
          var o2 = e2.apply(null, arguments);
          return (r2 = t2).s = 1, r2.v = o2;
        } catch (e3) {
          throw (o2 = t2).s = 2, o2.v = e3, e3;
        }
      };
    }, t.cloneElement = function(e2, t2, a2) {
      if (null == e2)
        throw Error(u(267, e2));
      var n2 = r({}, e2.props), i2 = e2.key, s2 = e2.ref, o2 = e2._owner;
      if (null != t2) {
        if (void 0 !== t2.ref && (s2 = t2.ref, o2 = E.current), void 0 !== t2.key && (i2 = "" + t2.key), e2.type && e2.type.defaultProps)
          var l2 = e2.type.defaultProps;
        for (c2 in t2)
          w.call(t2, c2) && "key" !== c2 && "ref" !== c2 && "__self" !== c2 && "__source" !== c2 && (n2[c2] = void 0 === t2[c2] && void 0 !== l2 ? l2[c2] : t2[c2]);
      }
      var c2 = arguments.length - 2;
      if (1 === c2)
        n2.children = a2;
      else if (1 < c2) {
        l2 = Array(c2);
        for (var h2 = 0; h2 < c2; h2++)
          l2[h2] = arguments[h2 + 2];
        n2.children = l2;
      }
      return { $$typeof: d, type: e2.type, key: i2, ref: s2, props: n2, _owner: o2 };
    }, t.createElement = function(e2, t2, r2) {
      var a2, n2 = {}, i2 = null, s2 = null;
      if (null != t2)
        for (a2 in void 0 !== t2.ref && (s2 = t2.ref), void 0 !== t2.key && (i2 = "" + t2.key), t2)
          w.call(t2, a2) && "key" !== a2 && "ref" !== a2 && "__self" !== a2 && "__source" !== a2 && (n2[a2] = t2[a2]);
      var o2 = arguments.length - 2;
      if (1 === o2)
        n2.children = r2;
      else if (1 < o2) {
        for (var l2 = Array(o2), u2 = 0; u2 < o2; u2++)
          l2[u2] = arguments[u2 + 2];
        n2.children = l2;
      }
      if (e2 && e2.defaultProps)
        for (a2 in o2 = e2.defaultProps)
          void 0 === n2[a2] && (n2[a2] = o2[a2]);
      return { $$typeof: d, type: e2, key: i2, ref: s2, props: n2, _owner: E.current };
    }, t.createRef = function() {
      return { current: null };
    }, t.forwardRef = function(e2) {
      return { $$typeof: g, render: e2 };
    }, t.isValidElement = x, t.lazy = function(e2) {
      return { $$typeof: v, _payload: { _status: -1, _result: e2 }, _init: T };
    }, t.memo = function(e2, t2) {
      return { $$typeof: b, type: e2, compare: void 0 === t2 ? null : t2 };
    }, t.startTransition = function(e2) {
      var t2 = I.transition, r2 = /* @__PURE__ */ new Set();
      I.transition = { _callbacks: r2 };
      var a2 = I.transition;
      try {
        var n2 = e2();
        "object" == typeof n2 && null !== n2 && "function" == typeof n2.then && (r2.forEach(function(e3) {
          return e3(a2, n2);
        }), n2.then(R, N));
      } catch (e3) {
        N(e3);
      } finally {
        I.transition = t2;
      }
    }, t.use = function(e2) {
      return o.current.use(e2);
    }, t.useCallback = function(e2, t2) {
      return o.current.useCallback(e2, t2);
    }, t.useDebugValue = function() {
    }, t.useId = function() {
      return o.current.useId();
    }, t.useMemo = function(e2, t2) {
      return o.current.useMemo(e2, t2);
    }, t.version = "18.3.0-canary-14898b6a9-20240318";
  };
  __namedExportsObject["__chunk_796"] = (e, t, r) => {
    "use strict";
    e.exports = r(1651);
  };
  __namedExportsObject["__chunk_1651"] = (e, t, r) => {
    "use strict";
    var a = r(7908), n = r(5105), i = null, s = 0;
    function o(e2, t2) {
      if (0 !== t2.byteLength) {
        if (2048 < t2.byteLength)
          0 < s && (e2.enqueue(new Uint8Array(i.buffer, 0, s)), i = new Uint8Array(2048), s = 0), e2.enqueue(t2);
        else {
          var r2 = i.length - s;
          r2 < t2.byteLength && (0 === r2 ? e2.enqueue(i) : (i.set(t2.subarray(0, r2), s), e2.enqueue(i), t2 = t2.subarray(r2)), i = new Uint8Array(2048), s = 0), i.set(t2, s), s += t2.byteLength;
        }
      }
      return true;
    }
    var l = new TextEncoder(), u = Symbol.for("react.client.reference"), c = Symbol.for("react.server.reference");
    function d(e2, t2, r2) {
      return Object.defineProperties(e2, { $$typeof: { value: u }, $$id: { value: t2 }, $$async: { value: r2 } });
    }
    var h = Function.prototype.bind, p = Array.prototype.slice;
    function f() {
      var e2 = h.apply(this, arguments);
      if (this.$$typeof === c) {
        var t2 = p.call(arguments, 1);
        return Object.defineProperties(e2, { $$typeof: { value: c }, $$id: { value: this.$$id }, $$bound: { value: this.$$bound ? this.$$bound.concat(t2) : t2 }, bind: { value: f } });
      }
      return e2;
    }
    var m = Promise.prototype, g = { get: function(e2, t2) {
      switch (t2) {
        case "$$typeof":
          return e2.$$typeof;
        case "$$id":
          return e2.$$id;
        case "$$async":
          return e2.$$async;
        case "name":
          return e2.name;
        case "displayName":
        case "defaultProps":
        case "toJSON":
          return;
        case Symbol.toPrimitive:
          return Object.prototype[Symbol.toPrimitive];
        case Symbol.toStringTag:
          return Object.prototype[Symbol.toStringTag];
        case "Provider":
          throw Error("Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.");
      }
      throw Error("Cannot access " + String(e2.name) + "." + String(t2) + " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.");
    }, set: function() {
      throw Error("Cannot assign to a client module from a server module.");
    } };
    function y(e2, t2) {
      switch (t2) {
        case "$$typeof":
          return e2.$$typeof;
        case "$$id":
          return e2.$$id;
        case "$$async":
          return e2.$$async;
        case "name":
          return e2.name;
        case "defaultProps":
        case "toJSON":
          return;
        case Symbol.toPrimitive:
          return Object.prototype[Symbol.toPrimitive];
        case Symbol.toStringTag:
          return Object.prototype[Symbol.toStringTag];
        case "__esModule":
          var r2 = e2.$$id;
          return e2.default = d(function() {
            throw Error("Attempted to call the default export of " + r2 + " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
          }, e2.$$id + "#", e2.$$async), true;
        case "then":
          if (e2.then)
            return e2.then;
          if (e2.$$async)
            return;
          var a2 = d({}, e2.$$id, true), n2 = new Proxy(a2, b);
          return e2.status = "fulfilled", e2.value = n2, e2.then = d(function(e3) {
            return Promise.resolve(e3(n2));
          }, e2.$$id + "#then", false);
      }
      if ("symbol" == typeof t2)
        throw Error("Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.");
      return (a2 = e2[t2]) || (Object.defineProperty(a2 = d(function() {
        throw Error("Attempted to call " + String(t2) + "() from the server but " + String(t2) + " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
      }, e2.$$id + "#" + t2, e2.$$async), "name", { value: t2 }), a2 = e2[t2] = new Proxy(a2, g)), a2;
    }
    var b = { get: function(e2, t2) {
      return y(e2, t2);
    }, getOwnPropertyDescriptor: function(e2, t2) {
      var r2 = Object.getOwnPropertyDescriptor(e2, t2);
      return r2 || (r2 = { value: y(e2, t2), writable: false, configurable: false, enumerable: false }, Object.defineProperty(e2, t2, r2)), r2;
    }, getPrototypeOf: function() {
      return m;
    }, set: function() {
      throw Error("Cannot assign to a client module from a server module.");
    } };
    n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Dispatcher;
    var v = "function" == typeof AsyncLocalStorage, _ = v ? new AsyncLocalStorage() : null;
    "object" == typeof async_hooks && async_hooks.createHook, "object" == typeof async_hooks && async_hooks.executionAsyncId;
    var w = Symbol.for("react.element"), E = Symbol.for("react.fragment"), x = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), A = Symbol.for("react.suspense_list"), k = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), P = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.postpone");
    var C = Symbol.iterator, I = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`");
    function R() {
    }
    var N = null;
    function $() {
      if (null === N)
        throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var e2 = N;
      return N = null, e2;
    }
    var j = null, L = 0, M = null;
    function D() {
      var e2 = M || [];
      return M = null, e2;
    }
    var U = { useMemo: function(e2) {
      return e2();
    }, useCallback: function(e2) {
      return e2;
    }, useDebugValue: function() {
    }, useDeferredValue: F, useTransition: F, readContext: B, useContext: B, useReducer: F, useRef: F, useState: F, useInsertionEffect: F, useLayoutEffect: F, useImperativeHandle: F, useEffect: F, useId: function() {
      if (null === j)
        throw Error("useId can only be used while React is rendering");
      var e2 = j.identifierCount++;
      return ":" + j.identifierPrefix + "S" + e2.toString(32) + ":";
    }, useSyncExternalStore: F, useCacheRefresh: function() {
      return z;
    }, useMemoCache: function(e2) {
      for (var t2 = Array(e2), r2 = 0; r2 < e2; r2++)
        t2[r2] = P;
      return t2;
    }, use: function(e2) {
      if (null !== e2 && "object" == typeof e2 || "function" == typeof e2) {
        if ("function" == typeof e2.then) {
          var t2 = L;
          return L += 1, null === M && (M = []), function(e3, t3, r2) {
            switch (void 0 === (r2 = e3[r2]) ? e3.push(t3) : r2 !== t3 && (t3.then(R, R), t3 = r2), t3.status) {
              case "fulfilled":
                return t3.value;
              case "rejected":
                throw t3.reason;
              default:
                if ("string" != typeof t3.status)
                  switch ((e3 = t3).status = "pending", e3.then(function(e4) {
                    if ("pending" === t3.status) {
                      var r3 = t3;
                      r3.status = "fulfilled", r3.value = e4;
                    }
                  }, function(e4) {
                    if ("pending" === t3.status) {
                      var r3 = t3;
                      r3.status = "rejected", r3.reason = e4;
                    }
                  }), t3.status) {
                    case "fulfilled":
                      return t3.value;
                    case "rejected":
                      throw t3.reason;
                  }
                throw N = t3, I;
            }
          }(M, e2, t2);
        }
        e2.$$typeof === x && B();
      }
      if (e2.$$typeof === u) {
        if (null != e2.value && e2.value.$$typeof === x)
          throw Error("Cannot read a Client Context from a Server Component.");
        throw Error("Cannot use() an already resolved Client Reference.");
      }
      throw Error("An unsupported type was passed to use(): " + String(e2));
    } };
    function F() {
      throw Error("This Hook is not supported in Server Components.");
    }
    function z() {
      throw Error("Refreshing the cache is not supported in Server Components.");
    }
    function B() {
      throw Error("Cannot read a Client Context from a Server Component.");
    }
    var q = Array.isArray, H = Object.getPrototypeOf;
    function Z(e2) {
      return Object.prototype.toString.call(e2).replace(/^\[object (.*)\]$/, function(e3, t2) {
        return t2;
      });
    }
    function G(e2) {
      switch (typeof e2) {
        case "string":
          return JSON.stringify(10 >= e2.length ? e2 : e2.slice(0, 10) + "...");
        case "object":
          if (q(e2))
            return "[...]";
          if (null !== e2 && e2.$$typeof === V)
            return "client";
          return "Object" === (e2 = Z(e2)) ? "{...}" : e2;
        case "function":
          return e2.$$typeof === V ? "client" : (e2 = e2.displayName || e2.name) ? "function " + e2 : "function";
        default:
          return String(e2);
      }
    }
    var V = Symbol.for("react.client.reference");
    function W(e2, t2) {
      var r2 = Z(e2);
      if ("Object" !== r2 && "Array" !== r2)
        return r2;
      r2 = -1;
      var a2 = 0;
      if (q(e2)) {
        for (var n2 = "[", i2 = 0; i2 < e2.length; i2++) {
          0 < i2 && (n2 += ", ");
          var s2 = e2[i2];
          s2 = "object" == typeof s2 && null !== s2 ? W(s2) : G(s2), "" + i2 === t2 ? (r2 = n2.length, a2 = s2.length, n2 += s2) : n2 = 10 > s2.length && 40 > n2.length + s2.length ? n2 + s2 : n2 + "...";
        }
        n2 += "]";
      } else if (e2.$$typeof === w)
        n2 = "<" + function e3(t3) {
          if ("string" == typeof t3)
            return t3;
          switch (t3) {
            case S:
              return "Suspense";
            case A:
              return "SuspenseList";
          }
          if ("object" == typeof t3)
            switch (t3.$$typeof) {
              case O:
                return e3(t3.render);
              case k:
                return e3(t3.type);
              case T:
                var r3 = t3._payload;
                t3 = t3._init;
                try {
                  return e3(t3(r3));
                } catch (e4) {
                }
            }
          return "";
        }(e2.type) + "/>";
      else {
        if (e2.$$typeof === V)
          return "client";
        for (s2 = 0, n2 = "{", i2 = Object.keys(e2); s2 < i2.length; s2++) {
          0 < s2 && (n2 += ", ");
          var o2 = i2[s2], l2 = JSON.stringify(o2);
          n2 += ('"' + o2 + '"' === l2 ? o2 : l2) + ": ", l2 = "object" == typeof (l2 = e2[o2]) && null !== l2 ? W(l2) : G(l2), o2 === t2 ? (r2 = n2.length, a2 = l2.length, n2 += l2) : n2 = 10 > l2.length && 40 > n2.length + l2.length ? n2 + l2 : n2 + "...";
        }
        n2 += "}";
      }
      return void 0 === t2 ? n2 : -1 < r2 && 0 < a2 ? "\n  " + n2 + "\n  " + (e2 = " ".repeat(r2) + "^".repeat(a2)) : "\n  " + n2;
    }
    var J = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, K = a.__SECRET_SERVER_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (!K)
      throw Error('The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.');
    var X = Object.prototype, Y = JSON.stringify, Q = (K.ReactCurrentCache, J.ReactCurrentDispatcher), ee = null;
    function et(e2) {
      if ("fulfilled" === e2.status)
        return e2.value;
      if ("rejected" === e2.status)
        throw e2.reason;
      throw e2;
    }
    function er(e2, t2, r2, a2, n2) {
      var i2 = t2.thenableState;
      if (t2.thenableState = null, L = 0, M = i2, "object" == typeof (a2 = a2(n2, void 0)) && null !== a2 && "function" == typeof a2.then) {
        if ("fulfilled" === (n2 = a2).status)
          return n2.value;
        a2 = function(e3) {
          switch (e3.status) {
            case "fulfilled":
            case "rejected":
              break;
            default:
              "string" != typeof e3.status && (e3.status = "pending", e3.then(function(t3) {
                "pending" === e3.status && (e3.status = "fulfilled", e3.value = t3);
              }, function(t3) {
                "pending" === e3.status && (e3.status = "rejected", e3.reason = t3);
              }));
          }
          return { $$typeof: T, _payload: e3, _init: et };
        }(a2);
      }
      return n2 = t2.keyPath, i2 = t2.implicitSlot, null !== r2 ? t2.keyPath = null === n2 ? r2 : n2 + "," + r2 : null === n2 && (t2.implicitSlot = true), e2 = eu(e2, t2, eh, "", a2), t2.keyPath = n2, t2.implicitSlot = i2, e2;
    }
    function ea(e2, t2) {
      var r2 = e2.pingedTasks;
      r2.push(t2), 1 === r2.length && (e2.flushScheduled = null !== e2.destination, setTimeout(function() {
        return function(e3) {
          var t3 = Q.current;
          Q.current = U;
          var r3 = ee;
          j = ee = e3;
          try {
            var a2 = e3.pingedTasks;
            e3.pingedTasks = [];
            for (var n2 = 0; n2 < a2.length; n2++)
              ep(e3, a2[n2]);
            null !== e3.destination && ef(e3, e3.destination);
          } catch (t4) {
            ec(e3, t4), function(e4, t5) {
              var r4;
              null !== e4.destination ? (e4.status = 2, "function" == typeof (r4 = e4.destination).error ? r4.error(t5) : r4.close()) : (e4.status = 1, e4.fatalError = t5);
            }(e3, t4);
          } finally {
            Q.current = t3, j = null, ee = r3;
          }
        }(e2);
      }, 0));
    }
    function en(e2, t2, r2, a2, n2) {
      e2.pendingChunks++;
      var i2 = e2.nextChunkId++;
      "object" == typeof t2 && null !== t2 && e2.writtenObjects.set(t2, i2);
      var s2 = { id: i2, status: 0, model: t2, keyPath: r2, implicitSlot: a2, ping: function() {
        return ea(e2, s2);
      }, toJSON: function(t3, r3) {
        var a3 = s2.keyPath, n3 = s2.implicitSlot;
        try {
          var i3 = eu(e2, s2, this, t3, r3);
        } catch (l2) {
          if (t3 = l2 === I ? $() : l2, r3 = "object" == typeof (r3 = s2.model) && null !== r3 && (r3.$$typeof === w || r3.$$typeof === T), "object" == typeof t3 && null !== t3 && "function" == typeof t3.then) {
            var o2 = (i3 = en(e2, s2.model, s2.keyPath, s2.implicitSlot, e2.abortableTasks)).ping;
            t3.then(o2, o2), i3.thenableState = D(), s2.keyPath = a3, s2.implicitSlot = n3, i3 = r3 ? "$L" + i3.id.toString(16) : ei(i3.id);
          } else if (s2.keyPath = a3, s2.implicitSlot = n3, r3)
            e2.pendingChunks++, a3 = e2.nextChunkId++, n3 = ec(e2, t3), ed(e2, a3, n3), i3 = "$L" + a3.toString(16);
          else
            throw t3;
        }
        return i3;
      }, thenableState: null };
      return n2.add(s2), s2;
    }
    function ei(e2) {
      return "$" + e2.toString(16);
    }
    function es(e2, t2, r2, a2) {
      var n2 = a2.$$async ? a2.$$id + "#async" : a2.$$id, i2 = e2.writtenClientReferences, s2 = i2.get(n2);
      if (void 0 !== s2)
        return t2[0] === w && "1" === r2 ? "$L" + s2.toString(16) : ei(s2);
      try {
        var o2 = e2.bundlerConfig, u2 = a2.$$id;
        s2 = "";
        var c2 = o2[u2];
        if (c2)
          s2 = c2.name;
        else {
          var d2 = u2.lastIndexOf("#");
          if (-1 !== d2 && (s2 = u2.slice(d2 + 1), c2 = o2[u2.slice(0, d2)]), !c2)
            throw Error('Could not find the module "' + u2 + '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.');
        }
        var h2 = true === a2.$$async ? [c2.id, c2.chunks, s2, 1] : [c2.id, c2.chunks, s2];
        e2.pendingChunks++;
        var p2 = e2.nextChunkId++, f2 = Y(h2), m2 = p2.toString(16) + ":I" + f2 + "\n", g2 = l.encode(m2);
        return e2.completedImportChunks.push(g2), i2.set(n2, p2), t2[0] === w && "1" === r2 ? "$L" + p2.toString(16) : ei(p2);
      } catch (a3) {
        return e2.pendingChunks++, t2 = e2.nextChunkId++, r2 = ec(e2, a3), ed(e2, t2, r2), ei(t2);
      }
    }
    function eo(e2, t2) {
      return t2 = en(e2, t2, null, false, e2.abortableTasks), ep(e2, t2), t2.id;
    }
    var el = false;
    function eu(e2, t2, r2, a2, n2) {
      if (t2.model = n2, n2 === w)
        return "$";
      if (null === n2)
        return null;
      if ("object" == typeof n2) {
        switch (n2.$$typeof) {
          case w:
            if (void 0 !== (a2 = (r2 = e2.writtenObjects).get(n2))) {
              if (el !== n2)
                return -1 === a2 ? ei(e2 = eo(e2, n2)) : ei(a2);
              el = null;
            } else
              r2.set(n2, -1);
            return function e3(t3, r3, a3, n3, i3, s3) {
              if (null != i3)
                throw Error("Refs cannot be used in Server Components, nor passed to Client Components.");
              if ("function" == typeof a3)
                return a3.$$typeof === u ? [w, a3, n3, s3] : er(t3, r3, n3, a3, s3);
              if ("string" == typeof a3)
                return [w, a3, n3, s3];
              if ("symbol" == typeof a3)
                return a3 === E && null === n3 ? (n3 = r3.implicitSlot, null === r3.keyPath && (r3.implicitSlot = true), t3 = eu(t3, r3, eh, "", s3.children), r3.implicitSlot = n3, t3) : [w, a3, n3, s3];
              if (null != a3 && "object" == typeof a3) {
                if (a3.$$typeof === u)
                  return [w, a3, n3, s3];
                switch (a3.$$typeof) {
                  case T:
                    return e3(t3, r3, a3 = (0, a3._init)(a3._payload), n3, i3, s3);
                  case O:
                    return er(t3, r3, n3, a3.render, s3);
                  case k:
                    return e3(t3, r3, a3.type, n3, i3, s3);
                }
              }
              throw Error("Unsupported Server Component type: " + G(a3));
            }(e2, t2, n2.type, n2.key, n2.ref, n2.props);
          case T:
            return t2.thenableState = null, eu(e2, t2, eh, "", n2 = (r2 = n2._init)(n2._payload));
        }
        if (n2.$$typeof === u)
          return es(e2, r2, a2, n2);
        if (a2 = (r2 = e2.writtenObjects).get(n2), "function" == typeof n2.then) {
          if (void 0 !== a2) {
            if (el !== n2)
              return "$@" + a2.toString(16);
            el = null;
          }
          return e2 = function(e3, t3, r3) {
            var a3 = en(e3, null, t3.keyPath, t3.implicitSlot, e3.abortableTasks);
            switch (r3.status) {
              case "fulfilled":
                return a3.model = r3.value, ea(e3, a3), a3.id;
              case "rejected":
                return t3 = ec(e3, r3.reason), ed(e3, a3.id, t3), a3.id;
              default:
                "string" != typeof r3.status && (r3.status = "pending", r3.then(function(e4) {
                  "pending" === r3.status && (r3.status = "fulfilled", r3.value = e4);
                }, function(e4) {
                  "pending" === r3.status && (r3.status = "rejected", r3.reason = e4);
                }));
            }
            return r3.then(function(t4) {
              a3.model = t4, ea(e3, a3);
            }, function(t4) {
              a3.status = 4, t4 = ec(e3, t4), ed(e3, a3.id, t4), e3.abortableTasks.delete(a3), null !== e3.destination && ef(e3, e3.destination);
            }), a3.id;
          }(e2, t2, n2), r2.set(n2, e2), "$@" + e2.toString(16);
        }
        if (void 0 !== a2) {
          if (el !== n2)
            return -1 === a2 ? ei(e2 = eo(e2, n2)) : ei(a2);
          el = null;
        } else
          r2.set(n2, -1);
        if (q(n2))
          return n2;
        if (n2 instanceof Map) {
          for (t2 = 0, n2 = Array.from(n2); t2 < n2.length; t2++)
            "object" == typeof (r2 = n2[t2][0]) && null !== r2 && void 0 === (a2 = e2.writtenObjects).get(r2) && a2.set(r2, -1);
          return "$Q" + eo(e2, n2).toString(16);
        }
        if (n2 instanceof Set) {
          for (t2 = 0, n2 = Array.from(n2); t2 < n2.length; t2++)
            "object" == typeof (r2 = n2[t2]) && null !== r2 && void 0 === (a2 = e2.writtenObjects).get(r2) && a2.set(r2, -1);
          return "$W" + eo(e2, n2).toString(16);
        }
        if (e2 = null === n2 || "object" != typeof n2 ? null : "function" == typeof (e2 = C && n2[C] || n2["@@iterator"]) ? e2 : null)
          return e2 = Array.from(n2);
        if ((e2 = H(n2)) !== X && (null === e2 || null !== H(e2)))
          throw Error("Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.");
        return n2;
      }
      if ("string" == typeof n2)
        return "Z" === n2[n2.length - 1] && r2[a2] instanceof Date ? "$D" + n2 : 1024 <= n2.length ? (e2.pendingChunks += 2, t2 = e2.nextChunkId++, r2 = (n2 = l.encode(n2)).byteLength, r2 = t2.toString(16) + ":T" + r2.toString(16) + ",", r2 = l.encode(r2), e2.completedRegularChunks.push(r2, n2), ei(t2)) : e2 = "$" === n2[0] ? "$" + n2 : n2;
      if ("boolean" == typeof n2)
        return n2;
      if ("number" == typeof n2)
        return Number.isFinite(n2) ? 0 === n2 && -1 / 0 == 1 / n2 ? "$-0" : n2 : 1 / 0 === n2 ? "$Infinity" : -1 / 0 === n2 ? "$-Infinity" : "$NaN";
      if (void 0 === n2)
        return "$undefined";
      if ("function" == typeof n2) {
        if (n2.$$typeof === u)
          return es(e2, r2, a2, n2);
        if (n2.$$typeof === c)
          return void 0 !== (r2 = (t2 = e2.writtenServerReferences).get(n2)) ? e2 = "$F" + r2.toString(16) : (r2 = n2.$$bound, e2 = eo(e2, r2 = { id: n2.$$id, bound: r2 ? Promise.resolve(r2) : null }), t2.set(n2, e2), e2 = "$F" + e2.toString(16)), e2;
        if (/^on[A-Z]/.test(a2))
          throw Error("Event handlers cannot be passed to Client Component props." + W(r2, a2) + "\nIf you need interactivity, consider converting part of this to a Client Component.");
        throw Error('Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' + W(r2, a2));
      }
      if ("symbol" == typeof n2) {
        var i2, s2, o2 = (t2 = e2.writtenSymbols).get(n2);
        if (void 0 !== o2)
          return ei(o2);
        if (Symbol.for(o2 = n2.description) !== n2)
          throw Error("Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" + n2.description + ") cannot be found among global symbols." + W(r2, a2));
        return e2.pendingChunks++, r2 = e2.nextChunkId++, i2 = e2, s2 = r2, i2 = Y("$S" + o2), s2 = s2.toString(16) + ":" + i2 + "\n", a2 = l.encode(s2), e2.completedImportChunks.push(a2), t2.set(n2, r2), ei(r2);
      }
      if ("bigint" == typeof n2)
        return "$n" + n2.toString(10);
      throw Error("Type " + typeof n2 + " is not supported in Client Component props." + W(r2, a2));
    }
    function ec(e2, t2) {
      var r2 = ee;
      ee = null;
      try {
        var a2 = e2.onError, n2 = v ? _.run(void 0, a2, t2) : a2(t2);
      } finally {
        ee = r2;
      }
      if (null != n2 && "string" != typeof n2)
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof n2 + '" instead');
      return n2 || "";
    }
    function ed(e2, t2, r2) {
      r2 = { digest: r2 }, t2 = t2.toString(16) + ":E" + Y(r2) + "\n", t2 = l.encode(t2), e2.completedErrorChunks.push(t2);
    }
    var eh = {};
    function ep(e2, t2) {
      if (0 === t2.status)
        try {
          el = t2.model;
          var r2 = eu(e2, t2, eh, "", t2.model);
          el = r2, t2.keyPath = null, t2.implicitSlot = false;
          var a2 = "object" == typeof r2 && null !== r2 ? Y(r2, t2.toJSON) : Y(r2), n2 = t2.id.toString(16) + ":" + a2 + "\n", i2 = l.encode(n2);
          e2.completedRegularChunks.push(i2), e2.abortableTasks.delete(t2), t2.status = 1;
        } catch (r3) {
          var s2 = r3 === I ? $() : r3;
          if ("object" == typeof s2 && null !== s2 && "function" == typeof s2.then) {
            var o2 = t2.ping;
            s2.then(o2, o2), t2.thenableState = D();
          } else {
            e2.abortableTasks.delete(t2), t2.status = 4;
            var u2 = ec(e2, s2);
            ed(e2, t2.id, u2);
          }
        } finally {
        }
    }
    function ef(e2, t2) {
      i = new Uint8Array(2048), s = 0;
      try {
        for (var r2 = e2.completedImportChunks, a2 = 0; a2 < r2.length; a2++)
          e2.pendingChunks--, o(t2, r2[a2]);
        r2.splice(0, a2);
        var n2 = e2.completedHintChunks;
        for (a2 = 0; a2 < n2.length; a2++)
          o(t2, n2[a2]);
        n2.splice(0, a2);
        var l2 = e2.completedRegularChunks;
        for (a2 = 0; a2 < l2.length; a2++)
          e2.pendingChunks--, o(t2, l2[a2]);
        l2.splice(0, a2);
        var u2 = e2.completedErrorChunks;
        for (a2 = 0; a2 < u2.length; a2++)
          e2.pendingChunks--, o(t2, u2[a2]);
        u2.splice(0, a2);
      } finally {
        e2.flushScheduled = false, i && 0 < s && (t2.enqueue(new Uint8Array(i.buffer, 0, s)), i = null, s = 0);
      }
      0 === e2.pendingChunks && t2.close();
    }
    var em = /* @__PURE__ */ new Map();
    function eg(e2) {
      var t2 = globalThis.__next_require__(e2);
      return "function" != typeof t2.then || "fulfilled" === t2.status ? null : (t2.then(function(e3) {
        t2.status = "fulfilled", t2.value = e3;
      }, function(e3) {
        t2.status = "rejected", t2.reason = e3;
      }), t2);
    }
    function ey() {
    }
    function eb(e2, t2, r2, a2) {
      this.status = e2, this.value = t2, this.reason = r2, this._response = a2;
    }
    function ev(e2, t2) {
      for (var r2 = 0; r2 < e2.length; r2++)
        (0, e2[r2])(t2);
    }
    eb.prototype = Object.create(Promise.prototype), eb.prototype.then = function(e2, t2) {
      switch ("resolved_model" === this.status && eE(this), this.status) {
        case "fulfilled":
          e2(this.value);
          break;
        case "pending":
        case "blocked":
          e2 && (null === this.value && (this.value = []), this.value.push(e2)), t2 && (null === this.reason && (this.reason = []), this.reason.push(t2));
          break;
        default:
          t2(this.reason);
      }
    };
    var e_ = null, ew = null;
    function eE(e2) {
      var t2 = e_, r2 = ew;
      e_ = e2, ew = null;
      try {
        var a2 = JSON.parse(e2.value, e2._response._fromJSON);
        null !== ew && 0 < ew.deps ? (ew.value = a2, e2.status = "blocked", e2.value = null, e2.reason = null) : (e2.status = "fulfilled", e2.value = a2);
      } catch (t3) {
        e2.status = "rejected", e2.reason = t3;
      } finally {
        e_ = t2, ew = r2;
      }
    }
    t.createClientModuleProxy = function(e2) {
      return new Proxy(e2 = d({}, e2, false), b);
    };
  };
  __namedExportsObject["__chunk_5105"] = (e, t, r) => {
    "use strict";
    e.exports = r(9642);
  };
  __namedExportsObject["__chunk_9642"] = (e, t) => {
    "use strict";
    var r = { usingClientEntryPoint: false, Events: null, Dispatcher: { current: null } };
    function a(e2, t2) {
      return "font" === e2 ? "" : "string" == typeof t2 ? "use-credentials" === t2 ? t2 : "" : void 0;
    }
    var n = r.Dispatcher;
    t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = r, t.preconnect = function(e2, t2) {
      var r2 = n.current;
      r2 && "string" == typeof e2 && (t2 = t2 ? "string" == typeof (t2 = t2.crossOrigin) ? "use-credentials" === t2 ? t2 : "" : void 0 : null, r2.preconnect(e2, t2));
    }, t.prefetchDNS = function(e2) {
      var t2 = n.current;
      t2 && "string" == typeof e2 && t2.prefetchDNS(e2);
    }, t.preinit = function(e2, t2) {
      var r2 = n.current;
      if (r2 && "string" == typeof e2 && t2 && "string" == typeof t2.as) {
        var i = t2.as, s = a(i, t2.crossOrigin), o = "string" == typeof t2.integrity ? t2.integrity : void 0, l = "string" == typeof t2.fetchPriority ? t2.fetchPriority : void 0;
        "style" === i ? r2.preinitStyle(e2, "string" == typeof t2.precedence ? t2.precedence : void 0, { crossOrigin: s, integrity: o, fetchPriority: l }) : "script" === i && r2.preinitScript(e2, { crossOrigin: s, integrity: o, fetchPriority: l, nonce: "string" == typeof t2.nonce ? t2.nonce : void 0 });
      }
    }, t.preinitModule = function(e2, t2) {
      var r2 = n.current;
      if (r2 && "string" == typeof e2) {
        if ("object" == typeof t2 && null !== t2) {
          if (null == t2.as || "script" === t2.as) {
            var i = a(t2.as, t2.crossOrigin);
            r2.preinitModuleScript(e2, { crossOrigin: i, integrity: "string" == typeof t2.integrity ? t2.integrity : void 0, nonce: "string" == typeof t2.nonce ? t2.nonce : void 0 });
          }
        } else
          null == t2 && r2.preinitModuleScript(e2);
      }
    }, t.preload = function(e2, t2) {
      var r2 = n.current;
      if (r2 && "string" == typeof e2 && "object" == typeof t2 && null !== t2 && "string" == typeof t2.as) {
        var i = t2.as, s = a(i, t2.crossOrigin);
        r2.preload(e2, i, { crossOrigin: s, integrity: "string" == typeof t2.integrity ? t2.integrity : void 0, nonce: "string" == typeof t2.nonce ? t2.nonce : void 0, type: "string" == typeof t2.type ? t2.type : void 0, fetchPriority: "string" == typeof t2.fetchPriority ? t2.fetchPriority : void 0, referrerPolicy: "string" == typeof t2.referrerPolicy ? t2.referrerPolicy : void 0, imageSrcSet: "string" == typeof t2.imageSrcSet ? t2.imageSrcSet : void 0, imageSizes: "string" == typeof t2.imageSizes ? t2.imageSizes : void 0 });
      }
    }, t.preloadModule = function(e2, t2) {
      var r2 = n.current;
      if (r2 && "string" == typeof e2) {
        if (t2) {
          var i = a(t2.as, t2.crossOrigin);
          r2.preloadModule(e2, { as: "string" == typeof t2.as && "script" !== t2.as ? t2.as : void 0, crossOrigin: i, integrity: "string" == typeof t2.integrity ? t2.integrity : void 0 });
        } else
          r2.preloadModule(e2);
      }
    };
  };
  __namedExportsObject["__chunk_5028"] = (e) => {
    !function() {
      "use strict";
      var t = { 815: function(e2) {
        e2.exports = function(e3, r2, a2, n2) {
          r2 = r2 || "&", a2 = a2 || "=";
          var i = {};
          if ("string" != typeof e3 || 0 === e3.length)
            return i;
          var s = /\+/g;
          e3 = e3.split(r2);
          var o = 1e3;
          n2 && "number" == typeof n2.maxKeys && (o = n2.maxKeys);
          var l = e3.length;
          o > 0 && l > o && (l = o);
          for (var u = 0; u < l; ++u) {
            var c, d, h, p, f = e3[u].replace(s, "%20"), m = f.indexOf(a2);
            (m >= 0 ? (c = f.substr(0, m), d = f.substr(m + 1)) : (c = f, d = ""), h = decodeURIComponent(c), p = decodeURIComponent(d), Object.prototype.hasOwnProperty.call(i, h)) ? t2(i[h]) ? i[h].push(p) : i[h] = [i[h], p] : i[h] = p;
          }
          return i;
        };
        var t2 = Array.isArray || function(e3) {
          return "[object Array]" === Object.prototype.toString.call(e3);
        };
      }, 577: function(e2) {
        var t2 = function(e3) {
          switch (typeof e3) {
            case "string":
              return e3;
            case "boolean":
              return e3 ? "true" : "false";
            case "number":
              return isFinite(e3) ? e3 : "";
            default:
              return "";
          }
        };
        e2.exports = function(e3, i, s, o) {
          return (i = i || "&", s = s || "=", null === e3 && (e3 = void 0), "object" == typeof e3) ? a2(n2(e3), function(n3) {
            var o2 = encodeURIComponent(t2(n3)) + s;
            return r2(e3[n3]) ? a2(e3[n3], function(e4) {
              return o2 + encodeURIComponent(t2(e4));
            }).join(i) : o2 + encodeURIComponent(t2(e3[n3]));
          }).join(i) : o ? encodeURIComponent(t2(o)) + s + encodeURIComponent(t2(e3)) : "";
        };
        var r2 = Array.isArray || function(e3) {
          return "[object Array]" === Object.prototype.toString.call(e3);
        };
        function a2(e3, t3) {
          if (e3.map)
            return e3.map(t3);
          for (var r3 = [], a3 = 0; a3 < e3.length; a3++)
            r3.push(t3(e3[a3], a3));
          return r3;
        }
        var n2 = Object.keys || function(e3) {
          var t3 = [];
          for (var r3 in e3)
            Object.prototype.hasOwnProperty.call(e3, r3) && t3.push(r3);
          return t3;
        };
      } }, r = {};
      function a(e2) {
        var n2 = r[e2];
        if (void 0 !== n2)
          return n2.exports;
        var i = r[e2] = { exports: {} }, s = true;
        try {
          t[e2](i, i.exports, a), s = false;
        } finally {
          s && delete r[e2];
        }
        return i.exports;
      }
      a.ab = "//";
      var n = {};
      n.decode = n.parse = a(815), n.encode = n.stringify = a(577), e.exports = n;
    }();
  };
  __namedExportsObject["__chunk_9548"] = (e, t) => {
    "use strict";
    function r(e2, t2) {
      void 0 === t2 && (t2 = {});
      for (var r2 = function(e3) {
        for (var t3 = [], r3 = 0; r3 < e3.length; ) {
          var a2 = e3[r3];
          if ("*" === a2 || "+" === a2 || "?" === a2) {
            t3.push({ type: "MODIFIER", index: r3, value: e3[r3++] });
            continue;
          }
          if ("\\" === a2) {
            t3.push({ type: "ESCAPED_CHAR", index: r3++, value: e3[r3++] });
            continue;
          }
          if ("{" === a2) {
            t3.push({ type: "OPEN", index: r3, value: e3[r3++] });
            continue;
          }
          if ("}" === a2) {
            t3.push({ type: "CLOSE", index: r3, value: e3[r3++] });
            continue;
          }
          if (":" === a2) {
            for (var n3 = "", i2 = r3 + 1; i2 < e3.length; ) {
              var s2 = e3.charCodeAt(i2);
              if (s2 >= 48 && s2 <= 57 || s2 >= 65 && s2 <= 90 || s2 >= 97 && s2 <= 122 || 95 === s2) {
                n3 += e3[i2++];
                continue;
              }
              break;
            }
            if (!n3)
              throw TypeError("Missing parameter name at " + r3);
            t3.push({ type: "NAME", index: r3, value: n3 }), r3 = i2;
            continue;
          }
          if ("(" === a2) {
            var o2 = 1, l2 = "", i2 = r3 + 1;
            if ("?" === e3[i2])
              throw TypeError('Pattern cannot start with "?" at ' + i2);
            for (; i2 < e3.length; ) {
              if ("\\" === e3[i2]) {
                l2 += e3[i2++] + e3[i2++];
                continue;
              }
              if (")" === e3[i2]) {
                if (0 == --o2) {
                  i2++;
                  break;
                }
              } else if ("(" === e3[i2] && (o2++, "?" !== e3[i2 + 1]))
                throw TypeError("Capturing groups are not allowed at " + i2);
              l2 += e3[i2++];
            }
            if (o2)
              throw TypeError("Unbalanced pattern at " + r3);
            if (!l2)
              throw TypeError("Missing pattern at " + r3);
            t3.push({ type: "PATTERN", index: r3, value: l2 }), r3 = i2;
            continue;
          }
          t3.push({ type: "CHAR", index: r3, value: e3[r3++] });
        }
        return t3.push({ type: "END", index: r3, value: "" }), t3;
      }(e2), n2 = t2.prefixes, i = void 0 === n2 ? "./" : n2, s = "[^" + a(t2.delimiter || "/#?") + "]+?", o = [], l = 0, u = 0, c = "", d = function(e3) {
        if (u < r2.length && r2[u].type === e3)
          return r2[u++].value;
      }, h = function(e3) {
        var t3 = d(e3);
        if (void 0 !== t3)
          return t3;
        var a2 = r2[u];
        throw TypeError("Unexpected " + a2.type + " at " + a2.index + ", expected " + e3);
      }, p = function() {
        for (var e3, t3 = ""; e3 = d("CHAR") || d("ESCAPED_CHAR"); )
          t3 += e3;
        return t3;
      }; u < r2.length; ) {
        var f = d("CHAR"), m = d("NAME"), g = d("PATTERN");
        if (m || g) {
          var y = f || "";
          -1 === i.indexOf(y) && (c += y, y = ""), c && (o.push(c), c = ""), o.push({ name: m || l++, prefix: y, suffix: "", pattern: g || s, modifier: d("MODIFIER") || "" });
          continue;
        }
        var b = f || d("ESCAPED_CHAR");
        if (b) {
          c += b;
          continue;
        }
        if (c && (o.push(c), c = ""), d("OPEN")) {
          var y = p(), v = d("NAME") || "", _ = d("PATTERN") || "", w = p();
          h("CLOSE"), o.push({ name: v || (_ ? l++ : ""), pattern: v && !_ ? s : _, prefix: y, suffix: w, modifier: d("MODIFIER") || "" });
          continue;
        }
        h("END");
      }
      return o;
    }
    function a(e2) {
      return e2.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function n(e2) {
      return e2 && e2.sensitive ? "" : "i";
    }
    t.MY = function(e2, t2) {
      var a2, i, s, o, l, u, c, d;
      return a2 = r(e2, t2), void 0 === (i = t2) && (i = {}), s = n(i), l = void 0 === (o = i.encode) ? function(e3) {
        return e3;
      } : o, c = void 0 === (u = i.validate) || u, d = a2.map(function(e3) {
        if ("object" == typeof e3)
          return RegExp("^(?:" + e3.pattern + ")$", s);
      }), function(e3) {
        for (var t3 = "", r2 = 0; r2 < a2.length; r2++) {
          var n2 = a2[r2];
          if ("string" == typeof n2) {
            t3 += n2;
            continue;
          }
          var i2 = e3 ? e3[n2.name] : void 0, s2 = "?" === n2.modifier || "*" === n2.modifier, o2 = "*" === n2.modifier || "+" === n2.modifier;
          if (Array.isArray(i2)) {
            if (!o2)
              throw TypeError('Expected "' + n2.name + '" to not repeat, but got an array');
            if (0 === i2.length) {
              if (s2)
                continue;
              throw TypeError('Expected "' + n2.name + '" to not be empty');
            }
            for (var u2 = 0; u2 < i2.length; u2++) {
              var h = l(i2[u2], n2);
              if (c && !d[r2].test(h))
                throw TypeError('Expected all "' + n2.name + '" to match "' + n2.pattern + '", but got "' + h + '"');
              t3 += n2.prefix + h + n2.suffix;
            }
            continue;
          }
          if ("string" == typeof i2 || "number" == typeof i2) {
            var h = l(String(i2), n2);
            if (c && !d[r2].test(h))
              throw TypeError('Expected "' + n2.name + '" to match "' + n2.pattern + '", but got "' + h + '"');
            t3 += n2.prefix + h + n2.suffix;
            continue;
          }
          if (!s2) {
            var p = o2 ? "an array" : "a string";
            throw TypeError('Expected "' + n2.name + '" to be ' + p);
          }
        }
        return t3;
      };
    }, t.WS = function(e2, t2, r2) {
      void 0 === r2 && (r2 = {});
      var a2 = r2.decode, n2 = void 0 === a2 ? function(e3) {
        return e3;
      } : a2;
      return function(r3) {
        var a3 = e2.exec(r3);
        if (!a3)
          return false;
        for (var i = a3[0], s = a3.index, o = /* @__PURE__ */ Object.create(null), l = 1; l < a3.length; l++)
          !function(e3) {
            if (void 0 !== a3[e3]) {
              var r4 = t2[e3 - 1];
              "*" === r4.modifier || "+" === r4.modifier ? o[r4.name] = a3[e3].split(r4.prefix + r4.suffix).map(function(e4) {
                return n2(e4, r4);
              }) : o[r4.name] = n2(a3[e3], r4);
            }
          }(l);
        return { path: i, index: s, params: o };
      };
    }, t.Bo = function e2(t2, i, s) {
      return t2 instanceof RegExp ? function(e3, t3) {
        if (!t3)
          return e3;
        var r2 = e3.source.match(/\((?!\?)/g);
        if (r2)
          for (var a2 = 0; a2 < r2.length; a2++)
            t3.push({ name: a2, prefix: "", suffix: "", modifier: "", pattern: "" });
        return e3;
      }(t2, i) : Array.isArray(t2) ? RegExp("(?:" + t2.map(function(t3) {
        return e2(t3, i, s).source;
      }).join("|") + ")", n(s)) : function(e3, t3, r2) {
        void 0 === r2 && (r2 = {});
        for (var i2 = r2.strict, s2 = void 0 !== i2 && i2, o = r2.start, l = r2.end, u = r2.encode, c = void 0 === u ? function(e4) {
          return e4;
        } : u, d = "[" + a(r2.endsWith || "") + "]|$", h = "[" + a(r2.delimiter || "/#?") + "]", p = void 0 === o || o ? "^" : "", f = 0; f < e3.length; f++) {
          var m = e3[f];
          if ("string" == typeof m)
            p += a(c(m));
          else {
            var g = a(c(m.prefix)), y = a(c(m.suffix));
            if (m.pattern) {
              if (t3 && t3.push(m), g || y) {
                if ("+" === m.modifier || "*" === m.modifier) {
                  var b = "*" === m.modifier ? "?" : "";
                  p += "(?:" + g + "((?:" + m.pattern + ")(?:" + y + g + "(?:" + m.pattern + "))*)" + y + ")" + b;
                } else
                  p += "(?:" + g + "(" + m.pattern + ")" + y + ")" + m.modifier;
              } else
                p += "(" + m.pattern + ")" + m.modifier;
            } else
              p += "(?:" + g + y + ")" + m.modifier;
          }
        }
        if (void 0 === l || l)
          s2 || (p += h + "?"), p += r2.endsWith ? "(?=" + d + ")" : "$";
        else {
          var v = e3[e3.length - 1], _ = "string" == typeof v ? h.indexOf(v[v.length - 1]) > -1 : void 0 === v;
          s2 || (p += "(?:" + h + "(?=" + d + "))?"), _ || (p += "(?=" + h + "|" + d + ")");
        }
        return new RegExp(p, n(r2));
      }(r(t2, s), i, s);
    };
  };
  __namedExportsObject["__chunk_6914"] = (e) => {
    !function() {
      "use strict";
      var t = { 114: function(e2) {
        function t2(e3) {
          if ("string" != typeof e3)
            throw TypeError("Path must be a string. Received " + JSON.stringify(e3));
        }
        function r2(e3, t3) {
          for (var r3, a3 = "", n2 = 0, i = -1, s = 0, o = 0; o <= e3.length; ++o) {
            if (o < e3.length)
              r3 = e3.charCodeAt(o);
            else if (47 === r3)
              break;
            else
              r3 = 47;
            if (47 === r3) {
              if (i === o - 1 || 1 === s)
                ;
              else if (i !== o - 1 && 2 === s) {
                if (a3.length < 2 || 2 !== n2 || 46 !== a3.charCodeAt(a3.length - 1) || 46 !== a3.charCodeAt(a3.length - 2)) {
                  if (a3.length > 2) {
                    var l = a3.lastIndexOf("/");
                    if (l !== a3.length - 1) {
                      -1 === l ? (a3 = "", n2 = 0) : n2 = (a3 = a3.slice(0, l)).length - 1 - a3.lastIndexOf("/"), i = o, s = 0;
                      continue;
                    }
                  } else if (2 === a3.length || 1 === a3.length) {
                    a3 = "", n2 = 0, i = o, s = 0;
                    continue;
                  }
                }
                t3 && (a3.length > 0 ? a3 += "/.." : a3 = "..", n2 = 2);
              } else
                a3.length > 0 ? a3 += "/" + e3.slice(i + 1, o) : a3 = e3.slice(i + 1, o), n2 = o - i - 1;
              i = o, s = 0;
            } else
              46 === r3 && -1 !== s ? ++s : s = -1;
          }
          return a3;
        }
        var a2 = { resolve: function() {
          for (var e3, a3, n2 = "", i = false, s = arguments.length - 1; s >= -1 && !i; s--)
            s >= 0 ? a3 = arguments[s] : (void 0 === e3 && (e3 = ""), a3 = e3), t2(a3), 0 !== a3.length && (n2 = a3 + "/" + n2, i = 47 === a3.charCodeAt(0));
          return (n2 = r2(n2, !i), i) ? n2.length > 0 ? "/" + n2 : "/" : n2.length > 0 ? n2 : ".";
        }, normalize: function(e3) {
          if (t2(e3), 0 === e3.length)
            return ".";
          var a3 = 47 === e3.charCodeAt(0), n2 = 47 === e3.charCodeAt(e3.length - 1);
          return (0 !== (e3 = r2(e3, !a3)).length || a3 || (e3 = "."), e3.length > 0 && n2 && (e3 += "/"), a3) ? "/" + e3 : e3;
        }, isAbsolute: function(e3) {
          return t2(e3), e3.length > 0 && 47 === e3.charCodeAt(0);
        }, join: function() {
          if (0 == arguments.length)
            return ".";
          for (var e3, r3 = 0; r3 < arguments.length; ++r3) {
            var n2 = arguments[r3];
            t2(n2), n2.length > 0 && (void 0 === e3 ? e3 = n2 : e3 += "/" + n2);
          }
          return void 0 === e3 ? "." : a2.normalize(e3);
        }, relative: function(e3, r3) {
          if (t2(e3), t2(r3), e3 === r3 || (e3 = a2.resolve(e3)) === (r3 = a2.resolve(r3)))
            return "";
          for (var n2 = 1; n2 < e3.length && 47 === e3.charCodeAt(n2); ++n2)
            ;
          for (var i = e3.length, s = i - n2, o = 1; o < r3.length && 47 === r3.charCodeAt(o); ++o)
            ;
          for (var l = r3.length - o, u = s < l ? s : l, c = -1, d = 0; d <= u; ++d) {
            if (d === u) {
              if (l > u) {
                if (47 === r3.charCodeAt(o + d))
                  return r3.slice(o + d + 1);
                if (0 === d)
                  return r3.slice(o + d);
              } else
                s > u && (47 === e3.charCodeAt(n2 + d) ? c = d : 0 === d && (c = 0));
              break;
            }
            var h = e3.charCodeAt(n2 + d);
            if (h !== r3.charCodeAt(o + d))
              break;
            47 === h && (c = d);
          }
          var p = "";
          for (d = n2 + c + 1; d <= i; ++d)
            (d === i || 47 === e3.charCodeAt(d)) && (0 === p.length ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(o + c) : (o += c, 47 === r3.charCodeAt(o) && ++o, r3.slice(o));
        }, _makeLong: function(e3) {
          return e3;
        }, dirname: function(e3) {
          if (t2(e3), 0 === e3.length)
            return ".";
          for (var r3 = e3.charCodeAt(0), a3 = 47 === r3, n2 = -1, i = true, s = e3.length - 1; s >= 1; --s)
            if (47 === (r3 = e3.charCodeAt(s))) {
              if (!i) {
                n2 = s;
                break;
              }
            } else
              i = false;
          return -1 === n2 ? a3 ? "/" : "." : a3 && 1 === n2 ? "//" : e3.slice(0, n2);
        }, basename: function(e3, r3) {
          if (void 0 !== r3 && "string" != typeof r3)
            throw TypeError('"ext" argument must be a string');
          t2(e3);
          var a3, n2 = 0, i = -1, s = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= e3.length) {
            if (r3.length === e3.length && r3 === e3)
              return "";
            var o = r3.length - 1, l = -1;
            for (a3 = e3.length - 1; a3 >= 0; --a3) {
              var u = e3.charCodeAt(a3);
              if (47 === u) {
                if (!s) {
                  n2 = a3 + 1;
                  break;
                }
              } else
                -1 === l && (s = false, l = a3 + 1), o >= 0 && (u === r3.charCodeAt(o) ? -1 == --o && (i = a3) : (o = -1, i = l));
            }
            return n2 === i ? i = l : -1 === i && (i = e3.length), e3.slice(n2, i);
          }
          for (a3 = e3.length - 1; a3 >= 0; --a3)
            if (47 === e3.charCodeAt(a3)) {
              if (!s) {
                n2 = a3 + 1;
                break;
              }
            } else
              -1 === i && (s = false, i = a3 + 1);
          return -1 === i ? "" : e3.slice(n2, i);
        }, extname: function(e3) {
          t2(e3);
          for (var r3 = -1, a3 = 0, n2 = -1, i = true, s = 0, o = e3.length - 1; o >= 0; --o) {
            var l = e3.charCodeAt(o);
            if (47 === l) {
              if (!i) {
                a3 = o + 1;
                break;
              }
              continue;
            }
            -1 === n2 && (i = false, n2 = o + 1), 46 === l ? -1 === r3 ? r3 = o : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
          }
          return -1 === r3 || -1 === n2 || 0 === s || 1 === s && r3 === n2 - 1 && r3 === a3 + 1 ? "" : e3.slice(r3, n2);
        }, format: function(e3) {
          var t3, r3;
          if (null === e3 || "object" != typeof e3)
            throw TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e3);
          return t3 = e3.dir || e3.root, r3 = e3.base || (e3.name || "") + (e3.ext || ""), t3 ? t3 === e3.root ? t3 + r3 : t3 + "/" + r3 : r3;
        }, parse: function(e3) {
          t2(e3);
          var r3, a3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === e3.length)
            return a3;
          var n2 = e3.charCodeAt(0), i = 47 === n2;
          i ? (a3.root = "/", r3 = 1) : r3 = 0;
          for (var s = -1, o = 0, l = -1, u = true, c = e3.length - 1, d = 0; c >= r3; --c) {
            if (47 === (n2 = e3.charCodeAt(c))) {
              if (!u) {
                o = c + 1;
                break;
              }
              continue;
            }
            -1 === l && (u = false, l = c + 1), 46 === n2 ? -1 === s ? s = c : 1 !== d && (d = 1) : -1 !== s && (d = -1);
          }
          return -1 === s || -1 === l || 0 === d || 1 === d && s === l - 1 && s === o + 1 ? -1 !== l && (0 === o && i ? a3.base = a3.name = e3.slice(1, l) : a3.base = a3.name = e3.slice(o, l)) : (0 === o && i ? (a3.name = e3.slice(1, s), a3.base = e3.slice(1, l)) : (a3.name = e3.slice(o, s), a3.base = e3.slice(o, l)), a3.ext = e3.slice(s, l)), o > 0 ? a3.dir = e3.slice(0, o - 1) : i && (a3.dir = "/"), a3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        a2.posix = a2, e2.exports = a2;
      } }, r = {};
      function a(e2) {
        var n2 = r[e2];
        if (void 0 !== n2)
          return n2.exports;
        var i = r[e2] = { exports: {} }, s = true;
        try {
          t[e2](i, i.exports, a), s = false;
        } finally {
          s && delete r[e2];
        }
        return i.exports;
      }
      a.ab = "//";
      var n = a(114);
      e.exports = n;
    }();
  };
  __namedExportsObject["__chunk_7960"] = (e, t, r) => {
    !function() {
      var t2 = { 452: function(e2) {
        "use strict";
        e2.exports = r(5028);
      } }, a = {};
      function n(e2) {
        var r2 = a[e2];
        if (void 0 !== r2)
          return r2.exports;
        var i2 = a[e2] = { exports: {} }, s = true;
        try {
          t2[e2](i2, i2.exports, n), s = false;
        } finally {
          s && delete a[e2];
        }
        return i2.exports;
      }
      n.ab = "//";
      var i = {};
      !function() {
        var e2, t3 = (e2 = n(452)) && "object" == typeof e2 && "default" in e2 ? e2.default : e2, r2 = /https?|ftp|gopher|file/;
        function a2(e3) {
          "string" == typeof e3 && (e3 = y(e3));
          var a3, n2, i2, s2, o2, l2, u2, c2, d2, h2 = (n2 = (a3 = e3).auth, i2 = a3.hostname, s2 = a3.protocol || "", o2 = a3.pathname || "", l2 = a3.hash || "", u2 = a3.query || "", c2 = false, n2 = n2 ? encodeURIComponent(n2).replace(/%3A/i, ":") + "@" : "", a3.host ? c2 = n2 + a3.host : i2 && (c2 = n2 + (~i2.indexOf(":") ? "[" + i2 + "]" : i2), a3.port && (c2 += ":" + a3.port)), u2 && "object" == typeof u2 && (u2 = t3.encode(u2)), d2 = a3.search || u2 && "?" + u2 || "", s2 && ":" !== s2.substr(-1) && (s2 += ":"), a3.slashes || (!s2 || r2.test(s2)) && false !== c2 ? (c2 = "//" + (c2 || ""), o2 && "/" !== o2[0] && (o2 = "/" + o2)) : c2 || (c2 = ""), l2 && "#" !== l2[0] && (l2 = "#" + l2), d2 && "?" !== d2[0] && (d2 = "?" + d2), { protocol: s2, host: c2, pathname: o2 = o2.replace(/[?#]/g, encodeURIComponent), search: d2 = d2.replace("#", "%23"), hash: l2 });
          return "" + h2.protocol + h2.host + h2.pathname + h2.search + h2.hash;
        }
        var s = "http://", o = s + "w.w", l = /^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i, u = /https?|ftp|gopher|file/;
        function c(e3, t4) {
          var r3 = "string" == typeof e3 ? y(e3) : e3;
          e3 = "object" == typeof e3 ? a2(e3) : e3;
          var n2 = y(t4), i2 = "";
          r3.protocol && !r3.slashes && (i2 = r3.protocol, e3 = e3.replace(r3.protocol, ""), i2 += "/" === t4[0] || "/" === e3[0] ? "/" : ""), i2 && n2.protocol && (i2 = "", n2.slashes || (i2 = n2.protocol, t4 = t4.replace(n2.protocol, "")));
          var c2 = e3.match(l);
          c2 && !n2.protocol && (e3 = e3.substr((i2 = c2[1] + (c2[2] || "")).length), /^\/\/[^/]/.test(t4) && (i2 = i2.slice(0, -1)));
          var d2 = new URL(e3, o + "/"), h2 = new URL(t4, d2).toString().replace(o, ""), p2 = n2.protocol || r3.protocol;
          return p2 += r3.slashes || n2.slashes ? "//" : "", !i2 && p2 ? h2 = h2.replace(s, p2) : i2 && (h2 = h2.replace(s, "")), u.test(h2) || ~t4.indexOf(".") || "/" === e3.slice(-1) || "/" === t4.slice(-1) || "/" !== h2.slice(-1) || (h2 = h2.slice(0, -1)), i2 && (h2 = i2 + ("/" === h2[0] ? h2.substr(1) : h2)), h2;
        }
        function d() {
        }
        d.prototype.parse = y, d.prototype.format = a2, d.prototype.resolve = c, d.prototype.resolveObject = c;
        var h = /^https?|ftp|gopher|file/, p = /^(.*?)([#?].*)/, f = /^([a-z0-9.+-]*:)(\/{0,3})(.*)/i, m = /^([a-z0-9.+-]*:)?\/\/\/*/i, g = /^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;
        function y(e3, r3, n2) {
          if (void 0 === r3 && (r3 = false), void 0 === n2 && (n2 = false), e3 && "object" == typeof e3 && e3 instanceof d)
            return e3;
          var i2 = (e3 = e3.trim()).match(p);
          e3 = i2 ? i2[1].replace(/\\/g, "/") + i2[2] : e3.replace(/\\/g, "/"), g.test(e3) && "/" !== e3.slice(-1) && (e3 += "/");
          var s2 = !/(^javascript)/.test(e3) && e3.match(f), l2 = m.test(e3), u2 = "";
          s2 && (h.test(s2[1]) || (u2 = s2[1].toLowerCase(), e3 = "" + s2[2] + s2[3]), s2[2] || (l2 = false, h.test(s2[1]) ? (u2 = s2[1], e3 = "" + s2[3]) : e3 = "//" + s2[3]), 3 !== s2[2].length && 1 !== s2[2].length || (u2 = s2[1], e3 = "/" + s2[3]));
          var c2, y2 = (i2 ? i2[1] : e3).match(/^https?:\/\/[^/]+(:[0-9]+)(?=\/|$)/), b = y2 && y2[1], v = new d(), _ = "", w = "";
          try {
            c2 = new URL(e3);
          } catch (t4) {
            _ = t4, u2 || n2 || !/^\/\//.test(e3) || /^\/\/.+[@.]/.test(e3) || (w = "/", e3 = e3.substr(1));
            try {
              c2 = new URL(e3, o);
            } catch (e4) {
              return v.protocol = u2, v.href = u2, v;
            }
          }
          v.slashes = l2 && !w, v.host = "w.w" === c2.host ? "" : c2.host, v.hostname = "w.w" === c2.hostname ? "" : c2.hostname.replace(/(\[|\])/g, ""), v.protocol = _ ? u2 || null : c2.protocol, v.search = c2.search.replace(/\\/g, "%5C"), v.hash = c2.hash.replace(/\\/g, "%5C");
          var E = e3.split("#");
          !v.search && ~E[0].indexOf("?") && (v.search = "?"), v.hash || "" !== E[1] || (v.hash = "#"), v.query = r3 ? t3.decode(c2.search.substr(1)) : v.search.substr(1), v.pathname = w + (s2 ? c2.pathname.replace(/['^|`]/g, function(e4) {
            return "%" + e4.charCodeAt().toString(16).toUpperCase();
          }).replace(/((?:%[0-9A-F]{2})+)/g, function(e4, t4) {
            try {
              return decodeURIComponent(t4).split("").map(function(e5) {
                var t5 = e5.charCodeAt();
                return t5 > 256 || /^[a-z0-9]$/i.test(e5) ? e5 : "%" + t5.toString(16).toUpperCase();
              }).join("");
            } catch (e5) {
              return t4;
            }
          }) : c2.pathname), "about:" === v.protocol && "blank" === v.pathname && (v.protocol = "", v.pathname = ""), _ && "/" !== e3[0] && (v.pathname = v.pathname.substr(1)), u2 && !h.test(u2) && "/" !== e3.slice(-1) && "/" === v.pathname && (v.pathname = ""), v.path = v.pathname + v.search, v.auth = [c2.username, c2.password].map(decodeURIComponent).filter(Boolean).join(":"), v.port = c2.port, b && !v.host.endsWith(b) && (v.host += b, v.port = b.slice(1)), v.href = w ? "" + v.pathname + v.search + v.hash : a2(v);
          var x = /^(file)/.test(v.href) ? ["host", "hostname"] : [];
          return Object.keys(v).forEach(function(e4) {
            ~x.indexOf(e4) || (v[e4] = v[e4] || null);
          }), v;
        }
        i.parse = y, i.format = a2, i.resolve = c, i.resolveObject = function(e3, t4) {
          return y(c(e3, t4));
        }, i.Url = d;
      }(), e.exports = i;
    }();
  };
  __namedExportsObject["__chunk_5996"] = (e) => {
    (() => {
      "use strict";
      var t = { 806: (e2, t2, r2) => {
        let a2 = r2(190), n2 = Symbol("max"), i = Symbol("length"), s = Symbol("lengthCalculator"), o = Symbol("allowStale"), l = Symbol("maxAge"), u = Symbol("dispose"), c = Symbol("noDisposeOnSet"), d = Symbol("lruList"), h = Symbol("cache"), p = Symbol("updateAgeOnGet"), f = () => 1;
        class m {
          constructor(e3) {
            if ("number" == typeof e3 && (e3 = { max: e3 }), e3 || (e3 = {}), e3.max && ("number" != typeof e3.max || e3.max < 0))
              throw TypeError("max must be a non-negative number");
            this[n2] = e3.max || 1 / 0;
            let t3 = e3.length || f;
            if (this[s] = "function" != typeof t3 ? f : t3, this[o] = e3.stale || false, e3.maxAge && "number" != typeof e3.maxAge)
              throw TypeError("maxAge must be a number");
            this[l] = e3.maxAge || 0, this[u] = e3.dispose, this[c] = e3.noDisposeOnSet || false, this[p] = e3.updateAgeOnGet || false, this.reset();
          }
          set max(e3) {
            if ("number" != typeof e3 || e3 < 0)
              throw TypeError("max must be a non-negative number");
            this[n2] = e3 || 1 / 0, b(this);
          }
          get max() {
            return this[n2];
          }
          set allowStale(e3) {
            this[o] = !!e3;
          }
          get allowStale() {
            return this[o];
          }
          set maxAge(e3) {
            if ("number" != typeof e3)
              throw TypeError("maxAge must be a non-negative number");
            this[l] = e3, b(this);
          }
          get maxAge() {
            return this[l];
          }
          set lengthCalculator(e3) {
            "function" != typeof e3 && (e3 = f), e3 !== this[s] && (this[s] = e3, this[i] = 0, this[d].forEach((e4) => {
              e4.length = this[s](e4.value, e4.key), this[i] += e4.length;
            })), b(this);
          }
          get lengthCalculator() {
            return this[s];
          }
          get length() {
            return this[i];
          }
          get itemCount() {
            return this[d].length;
          }
          rforEach(e3, t3) {
            t3 = t3 || this;
            for (let r3 = this[d].tail; null !== r3; ) {
              let a3 = r3.prev;
              w(this, e3, r3, t3), r3 = a3;
            }
          }
          forEach(e3, t3) {
            t3 = t3 || this;
            for (let r3 = this[d].head; null !== r3; ) {
              let a3 = r3.next;
              w(this, e3, r3, t3), r3 = a3;
            }
          }
          keys() {
            return this[d].toArray().map((e3) => e3.key);
          }
          values() {
            return this[d].toArray().map((e3) => e3.value);
          }
          reset() {
            this[u] && this[d] && this[d].length && this[d].forEach((e3) => this[u](e3.key, e3.value)), this[h] = /* @__PURE__ */ new Map(), this[d] = new a2(), this[i] = 0;
          }
          dump() {
            return this[d].map((e3) => !y(this, e3) && { k: e3.key, v: e3.value, e: e3.now + (e3.maxAge || 0) }).toArray().filter((e3) => e3);
          }
          dumpLru() {
            return this[d];
          }
          set(e3, t3, r3) {
            if ((r3 = r3 || this[l]) && "number" != typeof r3)
              throw TypeError("maxAge must be a number");
            let a3 = r3 ? Date.now() : 0, o2 = this[s](t3, e3);
            if (this[h].has(e3)) {
              if (o2 > this[n2])
                return v(this, this[h].get(e3)), false;
              let s2 = this[h].get(e3).value;
              return this[u] && !this[c] && this[u](e3, s2.value), s2.now = a3, s2.maxAge = r3, s2.value = t3, this[i] += o2 - s2.length, s2.length = o2, this.get(e3), b(this), true;
            }
            let p2 = new _(e3, t3, o2, a3, r3);
            return p2.length > this[n2] ? (this[u] && this[u](e3, t3), false) : (this[i] += p2.length, this[d].unshift(p2), this[h].set(e3, this[d].head), b(this), true);
          }
          has(e3) {
            return !!this[h].has(e3) && !y(this, this[h].get(e3).value);
          }
          get(e3) {
            return g(this, e3, true);
          }
          peek(e3) {
            return g(this, e3, false);
          }
          pop() {
            let e3 = this[d].tail;
            return e3 ? (v(this, e3), e3.value) : null;
          }
          del(e3) {
            v(this, this[h].get(e3));
          }
          load(e3) {
            this.reset();
            let t3 = Date.now();
            for (let r3 = e3.length - 1; r3 >= 0; r3--) {
              let a3 = e3[r3], n3 = a3.e || 0;
              if (0 === n3)
                this.set(a3.k, a3.v);
              else {
                let e4 = n3 - t3;
                e4 > 0 && this.set(a3.k, a3.v, e4);
              }
            }
          }
          prune() {
            this[h].forEach((e3, t3) => g(this, t3, false));
          }
        }
        let g = (e3, t3, r3) => {
          let a3 = e3[h].get(t3);
          if (a3) {
            let t4 = a3.value;
            if (y(e3, t4)) {
              if (v(e3, a3), !e3[o])
                return;
            } else
              r3 && (e3[p] && (a3.value.now = Date.now()), e3[d].unshiftNode(a3));
            return t4.value;
          }
        }, y = (e3, t3) => {
          if (!t3 || !t3.maxAge && !e3[l])
            return false;
          let r3 = Date.now() - t3.now;
          return t3.maxAge ? r3 > t3.maxAge : e3[l] && r3 > e3[l];
        }, b = (e3) => {
          if (e3[i] > e3[n2])
            for (let t3 = e3[d].tail; e3[i] > e3[n2] && null !== t3; ) {
              let r3 = t3.prev;
              v(e3, t3), t3 = r3;
            }
        }, v = (e3, t3) => {
          if (t3) {
            let r3 = t3.value;
            e3[u] && e3[u](r3.key, r3.value), e3[i] -= r3.length, e3[h].delete(r3.key), e3[d].removeNode(t3);
          }
        };
        class _ {
          constructor(e3, t3, r3, a3, n3) {
            this.key = e3, this.value = t3, this.length = r3, this.now = a3, this.maxAge = n3 || 0;
          }
        }
        let w = (e3, t3, r3, a3) => {
          let n3 = r3.value;
          y(e3, n3) && (v(e3, r3), e3[o] || (n3 = void 0)), n3 && t3.call(a3, n3.value, n3.key, e3);
        };
        e2.exports = m;
      }, 76: (e2) => {
        e2.exports = function(e3) {
          e3.prototype[Symbol.iterator] = function* () {
            for (let e4 = this.head; e4; e4 = e4.next)
              yield e4.value;
          };
        };
      }, 190: (e2, t2, r2) => {
        function a2(e3) {
          var t3 = this;
          if (t3 instanceof a2 || (t3 = new a2()), t3.tail = null, t3.head = null, t3.length = 0, e3 && "function" == typeof e3.forEach)
            e3.forEach(function(e4) {
              t3.push(e4);
            });
          else if (arguments.length > 0)
            for (var r3 = 0, n3 = arguments.length; r3 < n3; r3++)
              t3.push(arguments[r3]);
          return t3;
        }
        function n2(e3, t3, r3, a3) {
          if (!(this instanceof n2))
            return new n2(e3, t3, r3, a3);
          this.list = a3, this.value = e3, t3 ? (t3.next = this, this.prev = t3) : this.prev = null, r3 ? (r3.prev = this, this.next = r3) : this.next = null;
        }
        e2.exports = a2, a2.Node = n2, a2.create = a2, a2.prototype.removeNode = function(e3) {
          if (e3.list !== this)
            throw Error("removing node which does not belong to this list");
          var t3 = e3.next, r3 = e3.prev;
          return t3 && (t3.prev = r3), r3 && (r3.next = t3), e3 === this.head && (this.head = t3), e3 === this.tail && (this.tail = r3), e3.list.length--, e3.next = null, e3.prev = null, e3.list = null, t3;
        }, a2.prototype.unshiftNode = function(e3) {
          if (e3 !== this.head) {
            e3.list && e3.list.removeNode(e3);
            var t3 = this.head;
            e3.list = this, e3.next = t3, t3 && (t3.prev = e3), this.head = e3, this.tail || (this.tail = e3), this.length++;
          }
        }, a2.prototype.pushNode = function(e3) {
          if (e3 !== this.tail) {
            e3.list && e3.list.removeNode(e3);
            var t3 = this.tail;
            e3.list = this, e3.prev = t3, t3 && (t3.next = e3), this.tail = e3, this.head || (this.head = e3), this.length++;
          }
        }, a2.prototype.push = function() {
          for (var e3, t3 = 0, r3 = arguments.length; t3 < r3; t3++)
            e3 = arguments[t3], this.tail = new n2(e3, this.tail, null, this), this.head || (this.head = this.tail), this.length++;
          return this.length;
        }, a2.prototype.unshift = function() {
          for (var e3, t3 = 0, r3 = arguments.length; t3 < r3; t3++)
            e3 = arguments[t3], this.head = new n2(e3, null, this.head, this), this.tail || (this.tail = this.head), this.length++;
          return this.length;
        }, a2.prototype.pop = function() {
          if (this.tail) {
            var e3 = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e3;
          }
        }, a2.prototype.shift = function() {
          if (this.head) {
            var e3 = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e3;
          }
        }, a2.prototype.forEach = function(e3, t3) {
          t3 = t3 || this;
          for (var r3 = this.head, a3 = 0; null !== r3; a3++)
            e3.call(t3, r3.value, a3, this), r3 = r3.next;
        }, a2.prototype.forEachReverse = function(e3, t3) {
          t3 = t3 || this;
          for (var r3 = this.tail, a3 = this.length - 1; null !== r3; a3--)
            e3.call(t3, r3.value, a3, this), r3 = r3.prev;
        }, a2.prototype.get = function(e3) {
          for (var t3 = 0, r3 = this.head; null !== r3 && t3 < e3; t3++)
            r3 = r3.next;
          if (t3 === e3 && null !== r3)
            return r3.value;
        }, a2.prototype.getReverse = function(e3) {
          for (var t3 = 0, r3 = this.tail; null !== r3 && t3 < e3; t3++)
            r3 = r3.prev;
          if (t3 === e3 && null !== r3)
            return r3.value;
        }, a2.prototype.map = function(e3, t3) {
          t3 = t3 || this;
          for (var r3 = new a2(), n3 = this.head; null !== n3; )
            r3.push(e3.call(t3, n3.value, this)), n3 = n3.next;
          return r3;
        }, a2.prototype.mapReverse = function(e3, t3) {
          t3 = t3 || this;
          for (var r3 = new a2(), n3 = this.tail; null !== n3; )
            r3.push(e3.call(t3, n3.value, this)), n3 = n3.prev;
          return r3;
        }, a2.prototype.reduce = function(e3, t3) {
          var r3, a3 = this.head;
          if (arguments.length > 1)
            r3 = t3;
          else if (this.head)
            a3 = this.head.next, r3 = this.head.value;
          else
            throw TypeError("Reduce of empty list with no initial value");
          for (var n3 = 0; null !== a3; n3++)
            r3 = e3(r3, a3.value, n3), a3 = a3.next;
          return r3;
        }, a2.prototype.reduceReverse = function(e3, t3) {
          var r3, a3 = this.tail;
          if (arguments.length > 1)
            r3 = t3;
          else if (this.tail)
            a3 = this.tail.prev, r3 = this.tail.value;
          else
            throw TypeError("Reduce of empty list with no initial value");
          for (var n3 = this.length - 1; null !== a3; n3--)
            r3 = e3(r3, a3.value, n3), a3 = a3.prev;
          return r3;
        }, a2.prototype.toArray = function() {
          for (var e3 = Array(this.length), t3 = 0, r3 = this.head; null !== r3; t3++)
            e3[t3] = r3.value, r3 = r3.next;
          return e3;
        }, a2.prototype.toArrayReverse = function() {
          for (var e3 = Array(this.length), t3 = 0, r3 = this.tail; null !== r3; t3++)
            e3[t3] = r3.value, r3 = r3.prev;
          return e3;
        }, a2.prototype.slice = function(e3, t3) {
          (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
          var r3 = new a2();
          if (t3 < e3 || t3 < 0)
            return r3;
          e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
          for (var n3 = 0, i = this.head; null !== i && n3 < e3; n3++)
            i = i.next;
          for (; null !== i && n3 < t3; n3++, i = i.next)
            r3.push(i.value);
          return r3;
        }, a2.prototype.sliceReverse = function(e3, t3) {
          (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
          var r3 = new a2();
          if (t3 < e3 || t3 < 0)
            return r3;
          e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
          for (var n3 = this.length, i = this.tail; null !== i && n3 > t3; n3--)
            i = i.prev;
          for (; null !== i && n3 > e3; n3--, i = i.prev)
            r3.push(i.value);
          return r3;
        }, a2.prototype.splice = function(e3, t3) {
          e3 > this.length && (e3 = this.length - 1), e3 < 0 && (e3 = this.length + e3);
          for (var r3 = 0, a3 = this.head; null !== a3 && r3 < e3; r3++)
            a3 = a3.next;
          for (var i = [], r3 = 0; a3 && r3 < t3; r3++)
            i.push(a3.value), a3 = this.removeNode(a3);
          null === a3 && (a3 = this.tail), a3 !== this.head && a3 !== this.tail && (a3 = a3.prev);
          for (var r3 = 2; r3 < arguments.length; r3++)
            a3 = function(e4, t4, r4) {
              var a4 = t4 === e4.head ? new n2(r4, null, t4, e4) : new n2(r4, t4, t4.next, e4);
              return null === a4.next && (e4.tail = a4), null === a4.prev && (e4.head = a4), e4.length++, a4;
            }(this, a3, arguments[r3]);
          return i;
        }, a2.prototype.reverse = function() {
          for (var e3 = this.head, t3 = this.tail, r3 = e3; null !== r3; r3 = r3.prev) {
            var a3 = r3.prev;
            r3.prev = r3.next, r3.next = a3;
          }
          return this.head = t3, this.tail = e3, this;
        };
        try {
          r2(76)(a2);
        } catch (e3) {
        }
      } }, r = {};
      function a(e2) {
        var n2 = r[e2];
        if (void 0 !== n2)
          return n2.exports;
        var i = r[e2] = { exports: {} }, s = true;
        try {
          t[e2](i, i.exports, a), s = false;
        } finally {
          s && delete r[e2];
        }
        return i.exports;
      }
      a.ab = "//";
      var n = a(806);
      e.exports = n;
    })();
  };
  __namedExportsObject["__chunk_4337"] = (e) => {
    (() => {
      "use strict";
      "undefined" != typeof __nccwpck_require__ && (__nccwpck_require__.ab = "//");
      var t = {};
      (() => {
        t.parse = function(t2, r2) {
          if ("string" != typeof t2)
            throw TypeError("argument str must be a string");
          for (var n2 = {}, i = t2.split(a), s = (r2 || {}).decode || e2, o = 0; o < i.length; o++) {
            var l = i[o], u = l.indexOf("=");
            if (!(u < 0)) {
              var c = l.substr(0, u).trim(), d = l.substr(++u, l.length).trim();
              '"' == d[0] && (d = d.slice(1, -1)), void 0 == n2[c] && (n2[c] = function(e3, t3) {
                try {
                  return t3(e3);
                } catch (t4) {
                  return e3;
                }
              }(d, s));
            }
          }
          return n2;
        }, t.serialize = function(e3, t2, a2) {
          var i = a2 || {}, s = i.encode || r;
          if ("function" != typeof s)
            throw TypeError("option encode is invalid");
          if (!n.test(e3))
            throw TypeError("argument name is invalid");
          var o = s(t2);
          if (o && !n.test(o))
            throw TypeError("argument val is invalid");
          var l = e3 + "=" + o;
          if (null != i.maxAge) {
            var u = i.maxAge - 0;
            if (isNaN(u) || !isFinite(u))
              throw TypeError("option maxAge is invalid");
            l += "; Max-Age=" + Math.floor(u);
          }
          if (i.domain) {
            if (!n.test(i.domain))
              throw TypeError("option domain is invalid");
            l += "; Domain=" + i.domain;
          }
          if (i.path) {
            if (!n.test(i.path))
              throw TypeError("option path is invalid");
            l += "; Path=" + i.path;
          }
          if (i.expires) {
            if ("function" != typeof i.expires.toUTCString)
              throw TypeError("option expires is invalid");
            l += "; Expires=" + i.expires.toUTCString();
          }
          if (i.httpOnly && (l += "; HttpOnly"), i.secure && (l += "; Secure"), i.sameSite)
            switch ("string" == typeof i.sameSite ? i.sameSite.toLowerCase() : i.sameSite) {
              case true:
              case "strict":
                l += "; SameSite=Strict";
                break;
              case "lax":
                l += "; SameSite=Lax";
                break;
              case "none":
                l += "; SameSite=None";
                break;
              default:
                throw TypeError("option sameSite is invalid");
            }
          return l;
        };
        var e2 = decodeURIComponent, r = encodeURIComponent, a = /; */, n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      })(), e.exports = t;
    })();
  };
  __namedExportsObject["__chunk_676"] = (e) => {
    "use strict";
    var t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, a = Object.getOwnPropertyNames, n = Object.prototype.hasOwnProperty, i = {};
    function s(e2) {
      var t2;
      let r2 = ["path" in e2 && e2.path && `Path=${e2.path}`, "expires" in e2 && (e2.expires || 0 === e2.expires) && `Expires=${("number" == typeof e2.expires ? new Date(e2.expires) : e2.expires).toUTCString()}`, "maxAge" in e2 && "number" == typeof e2.maxAge && `Max-Age=${e2.maxAge}`, "domain" in e2 && e2.domain && `Domain=${e2.domain}`, "secure" in e2 && e2.secure && "Secure", "httpOnly" in e2 && e2.httpOnly && "HttpOnly", "sameSite" in e2 && e2.sameSite && `SameSite=${e2.sameSite}`, "partitioned" in e2 && e2.partitioned && "Partitioned", "priority" in e2 && e2.priority && `Priority=${e2.priority}`].filter(Boolean), a2 = `${e2.name}=${encodeURIComponent(null != (t2 = e2.value) ? t2 : "")}`;
      return 0 === r2.length ? a2 : `${a2}; ${r2.join("; ")}`;
    }
    function o(e2) {
      let t2 = /* @__PURE__ */ new Map();
      for (let r2 of e2.split(/; */)) {
        if (!r2)
          continue;
        let e3 = r2.indexOf("=");
        if (-1 === e3) {
          t2.set(r2, "true");
          continue;
        }
        let [a2, n2] = [r2.slice(0, e3), r2.slice(e3 + 1)];
        try {
          t2.set(a2, decodeURIComponent(null != n2 ? n2 : "true"));
        } catch {
        }
      }
      return t2;
    }
    function l(e2) {
      var t2, r2;
      if (!e2)
        return;
      let [[a2, n2], ...i2] = o(e2), { domain: s2, expires: l2, httponly: d2, maxage: h2, path: p, samesite: f, secure: m, partitioned: g, priority: y } = Object.fromEntries(i2.map(([e3, t3]) => [e3.toLowerCase(), t3]));
      return function(e3) {
        let t3 = {};
        for (let r3 in e3)
          e3[r3] && (t3[r3] = e3[r3]);
        return t3;
      }({ name: a2, value: decodeURIComponent(n2), domain: s2, ...l2 && { expires: new Date(l2) }, ...d2 && { httpOnly: true }, ..."string" == typeof h2 && { maxAge: Number(h2) }, path: p, ...f && { sameSite: u.includes(t2 = (t2 = f).toLowerCase()) ? t2 : void 0 }, ...m && { secure: true }, ...y && { priority: c.includes(r2 = (r2 = y).toLowerCase()) ? r2 : void 0 }, ...g && { partitioned: true } });
    }
    ((e2, r2) => {
      for (var a2 in r2)
        t(e2, a2, { get: r2[a2], enumerable: true });
    })(i, { RequestCookies: () => d, ResponseCookies: () => h, parseCookie: () => o, parseSetCookie: () => l, stringifyCookie: () => s }), e.exports = ((e2, i2, s2, o2) => {
      if (i2 && "object" == typeof i2 || "function" == typeof i2)
        for (let l2 of a(i2))
          n.call(e2, l2) || l2 === s2 || t(e2, l2, { get: () => i2[l2], enumerable: !(o2 = r(i2, l2)) || o2.enumerable });
      return e2;
    })(t({}, "__esModule", { value: true }), i);
    var u = ["strict", "lax", "none"], c = ["low", "medium", "high"], d = class {
      constructor(e2) {
        this._parsed = /* @__PURE__ */ new Map(), this._headers = e2;
        let t2 = e2.get("cookie");
        if (t2)
          for (let [e3, r2] of o(t2))
            this._parsed.set(e3, { name: e3, value: r2 });
      }
      [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
      }
      get size() {
        return this._parsed.size;
      }
      get(...e2) {
        let t2 = "string" == typeof e2[0] ? e2[0] : e2[0].name;
        return this._parsed.get(t2);
      }
      getAll(...e2) {
        var t2;
        let r2 = Array.from(this._parsed);
        if (!e2.length)
          return r2.map(([e3, t3]) => t3);
        let a2 = "string" == typeof e2[0] ? e2[0] : null == (t2 = e2[0]) ? void 0 : t2.name;
        return r2.filter(([e3]) => e3 === a2).map(([e3, t3]) => t3);
      }
      has(e2) {
        return this._parsed.has(e2);
      }
      set(...e2) {
        let [t2, r2] = 1 === e2.length ? [e2[0].name, e2[0].value] : e2, a2 = this._parsed;
        return a2.set(t2, { name: t2, value: r2 }), this._headers.set("cookie", Array.from(a2).map(([e3, t3]) => s(t3)).join("; ")), this;
      }
      delete(e2) {
        let t2 = this._parsed, r2 = Array.isArray(e2) ? e2.map((e3) => t2.delete(e3)) : t2.delete(e2);
        return this._headers.set("cookie", Array.from(t2).map(([e3, t3]) => s(t3)).join("; ")), r2;
      }
      clear() {
        return this.delete(Array.from(this._parsed.keys())), this;
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
      }
      toString() {
        return [...this._parsed.values()].map((e2) => `${e2.name}=${encodeURIComponent(e2.value)}`).join("; ");
      }
    }, h = class {
      constructor(e2) {
        var t2, r2, a2;
        this._parsed = /* @__PURE__ */ new Map(), this._headers = e2;
        let n2 = null != (a2 = null != (r2 = null == (t2 = e2.getSetCookie) ? void 0 : t2.call(e2)) ? r2 : e2.get("set-cookie")) ? a2 : [];
        for (let e3 of Array.isArray(n2) ? n2 : function(e4) {
          if (!e4)
            return [];
          var t3, r3, a3, n3, i2, s2 = [], o2 = 0;
          function l2() {
            for (; o2 < e4.length && /\s/.test(e4.charAt(o2)); )
              o2 += 1;
            return o2 < e4.length;
          }
          for (; o2 < e4.length; ) {
            for (t3 = o2, i2 = false; l2(); )
              if ("," === (r3 = e4.charAt(o2))) {
                for (a3 = o2, o2 += 1, l2(), n3 = o2; o2 < e4.length && "=" !== (r3 = e4.charAt(o2)) && ";" !== r3 && "," !== r3; )
                  o2 += 1;
                o2 < e4.length && "=" === e4.charAt(o2) ? (i2 = true, o2 = n3, s2.push(e4.substring(t3, a3)), t3 = o2) : o2 = a3 + 1;
              } else
                o2 += 1;
            (!i2 || o2 >= e4.length) && s2.push(e4.substring(t3, e4.length));
          }
          return s2;
        }(n2)) {
          let t3 = l(e3);
          t3 && this._parsed.set(t3.name, t3);
        }
      }
      get(...e2) {
        let t2 = "string" == typeof e2[0] ? e2[0] : e2[0].name;
        return this._parsed.get(t2);
      }
      getAll(...e2) {
        var t2;
        let r2 = Array.from(this._parsed.values());
        if (!e2.length)
          return r2;
        let a2 = "string" == typeof e2[0] ? e2[0] : null == (t2 = e2[0]) ? void 0 : t2.name;
        return r2.filter((e3) => e3.name === a2);
      }
      has(e2) {
        return this._parsed.has(e2);
      }
      set(...e2) {
        let [t2, r2, a2] = 1 === e2.length ? [e2[0].name, e2[0].value, e2[0]] : e2, n2 = this._parsed;
        return n2.set(t2, function(e3 = { name: "", value: "" }) {
          return "number" == typeof e3.expires && (e3.expires = new Date(e3.expires)), e3.maxAge && (e3.expires = new Date(Date.now() + 1e3 * e3.maxAge)), (null === e3.path || void 0 === e3.path) && (e3.path = "/"), e3;
        }({ name: t2, value: r2, ...a2 })), function(e3, t3) {
          for (let [, r3] of (t3.delete("set-cookie"), e3)) {
            let e4 = s(r3);
            t3.append("set-cookie", e4);
          }
        }(n2, this._headers), this;
      }
      delete(...e2) {
        let [t2, r2, a2] = "string" == typeof e2[0] ? [e2[0]] : [e2[0].name, e2[0].path, e2[0].domain];
        return this.set({ name: t2, path: r2, domain: a2, value: "", expires: new Date(0) });
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
      }
      toString() {
        return [...this._parsed.values()].map(s).join("; ");
      }
    };
  };
  __namedExportsObject["__chunk_3030"] = (e) => {
    "use strict";
    var t = Object.prototype.hasOwnProperty, r = "~";
    function a() {
    }
    function n(e2, t2, r2) {
      this.fn = e2, this.context = t2, this.once = r2 || false;
    }
    function i(e2, t2, a2, i2, s2) {
      if ("function" != typeof a2)
        throw TypeError("The listener must be a function");
      var o2 = new n(a2, i2 || e2, s2), l = r ? r + t2 : t2;
      return e2._events[l] ? e2._events[l].fn ? e2._events[l] = [e2._events[l], o2] : e2._events[l].push(o2) : (e2._events[l] = o2, e2._eventsCount++), e2;
    }
    function s(e2, t2) {
      0 == --e2._eventsCount ? e2._events = new a() : delete e2._events[t2];
    }
    function o() {
      this._events = new a(), this._eventsCount = 0;
    }
    Object.create && (a.prototype = /* @__PURE__ */ Object.create(null), new a().__proto__ || (r = false)), o.prototype.eventNames = function() {
      var e2, a2, n2 = [];
      if (0 === this._eventsCount)
        return n2;
      for (a2 in e2 = this._events)
        t.call(e2, a2) && n2.push(r ? a2.slice(1) : a2);
      return Object.getOwnPropertySymbols ? n2.concat(Object.getOwnPropertySymbols(e2)) : n2;
    }, o.prototype.listeners = function(e2) {
      var t2 = r ? r + e2 : e2, a2 = this._events[t2];
      if (!a2)
        return [];
      if (a2.fn)
        return [a2.fn];
      for (var n2 = 0, i2 = a2.length, s2 = Array(i2); n2 < i2; n2++)
        s2[n2] = a2[n2].fn;
      return s2;
    }, o.prototype.listenerCount = function(e2) {
      var t2 = r ? r + e2 : e2, a2 = this._events[t2];
      return a2 ? a2.fn ? 1 : a2.length : 0;
    }, o.prototype.emit = function(e2, t2, a2, n2, i2, s2) {
      var o2 = r ? r + e2 : e2;
      if (!this._events[o2])
        return false;
      var l, u, c = this._events[o2], d = arguments.length;
      if (c.fn) {
        switch (c.once && this.removeListener(e2, c.fn, void 0, true), d) {
          case 1:
            return c.fn.call(c.context), true;
          case 2:
            return c.fn.call(c.context, t2), true;
          case 3:
            return c.fn.call(c.context, t2, a2), true;
          case 4:
            return c.fn.call(c.context, t2, a2, n2), true;
          case 5:
            return c.fn.call(c.context, t2, a2, n2, i2), true;
          case 6:
            return c.fn.call(c.context, t2, a2, n2, i2, s2), true;
        }
        for (u = 1, l = Array(d - 1); u < d; u++)
          l[u - 1] = arguments[u];
        c.fn.apply(c.context, l);
      } else {
        var h, p = c.length;
        for (u = 0; u < p; u++)
          switch (c[u].once && this.removeListener(e2, c[u].fn, void 0, true), d) {
            case 1:
              c[u].fn.call(c[u].context);
              break;
            case 2:
              c[u].fn.call(c[u].context, t2);
              break;
            case 3:
              c[u].fn.call(c[u].context, t2, a2);
              break;
            case 4:
              c[u].fn.call(c[u].context, t2, a2, n2);
              break;
            default:
              if (!l)
                for (h = 1, l = Array(d - 1); h < d; h++)
                  l[h - 1] = arguments[h];
              c[u].fn.apply(c[u].context, l);
          }
      }
      return true;
    }, o.prototype.on = function(e2, t2, r2) {
      return i(this, e2, t2, r2, false);
    }, o.prototype.once = function(e2, t2, r2) {
      return i(this, e2, t2, r2, true);
    }, o.prototype.removeListener = function(e2, t2, a2, n2) {
      var i2 = r ? r + e2 : e2;
      if (!this._events[i2])
        return this;
      if (!t2)
        return s(this, i2), this;
      var o2 = this._events[i2];
      if (o2.fn)
        o2.fn !== t2 || n2 && !o2.once || a2 && o2.context !== a2 || s(this, i2);
      else {
        for (var l = 0, u = [], c = o2.length; l < c; l++)
          (o2[l].fn !== t2 || n2 && !o2[l].once || a2 && o2[l].context !== a2) && u.push(o2[l]);
        u.length ? this._events[i2] = 1 === u.length ? u[0] : u : s(this, i2);
      }
      return this;
    }, o.prototype.removeAllListeners = function(e2) {
      var t2;
      return e2 ? (t2 = r ? r + e2 : e2, this._events[t2] && s(this, t2)) : (this._events = new a(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = r, o.EventEmitter = o, e.exports = o;
  };
  __namedExportsObject["__chunk_5792"] = (e) => {
    "use strict";
    e.exports = function(e2, t) {
      if ("string" != typeof e2)
        throw TypeError("Expected a string");
      return t = void 0 === t ? "_" : t, e2.replace(/([a-z\d])([A-Z])/g, "$1" + t + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + t + "$2").toLowerCase();
    };
  };
  __namedExportsObject["__chunk_2513"] = (e) => {
    "use strict";
    let t = /[\p{Lu}]/u, r = /[\p{Ll}]/u, a = /^[\p{Lu}](?![\p{Lu}])/gu, n = /([\p{Alpha}\p{N}_]|$)/u, i = /[_.\- ]+/, s = RegExp("^" + i.source), o = RegExp(i.source + n.source, "gu"), l = RegExp("\\d+" + n.source, "gu"), u = (e2, a2, n2) => {
      let i2 = false, s2 = false, o2 = false;
      for (let l2 = 0; l2 < e2.length; l2++) {
        let u2 = e2[l2];
        i2 && t.test(u2) ? (e2 = e2.slice(0, l2) + "-" + e2.slice(l2), i2 = false, o2 = s2, s2 = true, l2++) : s2 && o2 && r.test(u2) ? (e2 = e2.slice(0, l2 - 1) + "-" + e2.slice(l2 - 1), o2 = s2, s2 = false, i2 = true) : (i2 = a2(u2) === u2 && n2(u2) !== u2, o2 = s2, s2 = n2(u2) === u2 && a2(u2) !== u2);
      }
      return e2;
    }, c = (e2, t2) => (a.lastIndex = 0, e2.replace(a, (e3) => t2(e3))), d = (e2, t2) => (o.lastIndex = 0, l.lastIndex = 0, e2.replace(o, (e3, r2) => t2(r2)).replace(l, (e3) => t2(e3))), h = (e2, t2) => {
      if (!("string" == typeof e2 || Array.isArray(e2)))
        throw TypeError("Expected the input to be `string | string[]`");
      if (t2 = { pascalCase: false, preserveConsecutiveUppercase: false, ...t2 }, 0 === (e2 = Array.isArray(e2) ? e2.map((e3) => e3.trim()).filter((e3) => e3.length).join("-") : e2.trim()).length)
        return "";
      let r2 = false === t2.locale ? (e3) => e3.toLowerCase() : (e3) => e3.toLocaleLowerCase(t2.locale), a2 = false === t2.locale ? (e3) => e3.toUpperCase() : (e3) => e3.toLocaleUpperCase(t2.locale);
      return 1 === e2.length ? t2.pascalCase ? a2(e2) : r2(e2) : (e2 !== r2(e2) && (e2 = u(e2, r2, a2)), e2 = e2.replace(s, ""), e2 = t2.preserveConsecutiveUppercase ? c(e2, r2) : r2(e2), t2.pascalCase && (e2 = a2(e2.charAt(0)) + e2.slice(1)), d(e2, a2));
    };
    e.exports = h, e.exports.default = h;
  };
  __namedExportsObject["__chunk_8566"] = (e, t) => {
    "use strict";
    t.byteLength = function(e2) {
      var t2 = l(e2), r2 = t2[0], a2 = t2[1];
      return (r2 + a2) * 3 / 4 - a2;
    }, t.toByteArray = function(e2) {
      var t2, r2, i2 = l(e2), s2 = i2[0], o2 = i2[1], u = new n((s2 + o2) * 3 / 4 - o2), c = 0, d = o2 > 0 ? s2 - 4 : s2;
      for (r2 = 0; r2 < d; r2 += 4)
        t2 = a[e2.charCodeAt(r2)] << 18 | a[e2.charCodeAt(r2 + 1)] << 12 | a[e2.charCodeAt(r2 + 2)] << 6 | a[e2.charCodeAt(r2 + 3)], u[c++] = t2 >> 16 & 255, u[c++] = t2 >> 8 & 255, u[c++] = 255 & t2;
      return 2 === o2 && (t2 = a[e2.charCodeAt(r2)] << 2 | a[e2.charCodeAt(r2 + 1)] >> 4, u[c++] = 255 & t2), 1 === o2 && (t2 = a[e2.charCodeAt(r2)] << 10 | a[e2.charCodeAt(r2 + 1)] << 4 | a[e2.charCodeAt(r2 + 2)] >> 2, u[c++] = t2 >> 8 & 255, u[c++] = 255 & t2), u;
    }, t.fromByteArray = function(e2) {
      for (var t2, a2 = e2.length, n2 = a2 % 3, i2 = [], s2 = 0, o2 = a2 - n2; s2 < o2; s2 += 16383)
        i2.push(function(e3, t3, a3) {
          for (var n3, i3 = [], s3 = t3; s3 < a3; s3 += 3)
            i3.push(r[(n3 = (e3[s3] << 16 & 16711680) + (e3[s3 + 1] << 8 & 65280) + (255 & e3[s3 + 2])) >> 18 & 63] + r[n3 >> 12 & 63] + r[n3 >> 6 & 63] + r[63 & n3]);
          return i3.join("");
        }(e2, s2, s2 + 16383 > o2 ? o2 : s2 + 16383));
      return 1 === n2 ? i2.push(r[(t2 = e2[a2 - 1]) >> 2] + r[t2 << 4 & 63] + "==") : 2 === n2 && i2.push(r[(t2 = (e2[a2 - 2] << 8) + e2[a2 - 1]) >> 10] + r[t2 >> 4 & 63] + r[t2 << 2 & 63] + "="), i2.join("");
    };
    for (var r = [], a = [], n = "undefined" != typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, o = i.length; s < o; ++s)
      r[s] = i[s], a[i.charCodeAt(s)] = s;
    function l(e2) {
      var t2 = e2.length;
      if (t2 % 4 > 0)
        throw Error("Invalid string. Length must be a multiple of 4");
      var r2 = e2.indexOf("=");
      -1 === r2 && (r2 = t2);
      var a2 = r2 === t2 ? 0 : 4 - r2 % 4;
      return [r2, a2];
    }
    a["-".charCodeAt(0)] = 62, a["_".charCodeAt(0)] = 63;
  };
  __namedExportsObject["__chunk_6676"] = (e, t, r) => {
    "use strict";
    e = r.nmd(e);
    let a = (e2 = 0) => (t2) => `\x1B[${38 + e2};5;${t2}m`, n = (e2 = 0) => (t2, r2, a2) => `\x1B[${38 + e2};2;${t2};${r2};${a2}m`;
    Object.defineProperty(e, "exports", { enumerable: true, get: function() {
      let e2 = /* @__PURE__ */ new Map(), t2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
      for (let [r2, a2] of (t2.color.gray = t2.color.blackBright, t2.bgColor.bgGray = t2.bgColor.bgBlackBright, t2.color.grey = t2.color.blackBright, t2.bgColor.bgGrey = t2.bgColor.bgBlackBright, Object.entries(t2))) {
        for (let [r3, n2] of Object.entries(a2))
          t2[r3] = { open: `\x1B[${n2[0]}m`, close: `\x1B[${n2[1]}m` }, a2[r3] = t2[r3], e2.set(n2[0], n2[1]);
        Object.defineProperty(t2, r2, { value: a2, enumerable: false });
      }
      return Object.defineProperty(t2, "codes", { value: e2, enumerable: false }), t2.color.close = "\x1B[39m", t2.bgColor.close = "\x1B[49m", t2.color.ansi256 = a(), t2.color.ansi16m = n(), t2.bgColor.ansi256 = a(10), t2.bgColor.ansi16m = n(10), Object.defineProperties(t2, { rgbToAnsi256: { value: (e3, t3, r2) => e3 === t3 && t3 === r2 ? e3 < 8 ? 16 : e3 > 248 ? 231 : Math.round((e3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e3 / 255 * 5) + 6 * Math.round(t3 / 255 * 5) + Math.round(r2 / 255 * 5), enumerable: false }, hexToRgb: { value: (e3) => {
        let t3 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(e3.toString(16));
        if (!t3)
          return [0, 0, 0];
        let { colorString: r2 } = t3.groups;
        3 === r2.length && (r2 = r2.split("").map((e4) => e4 + e4).join(""));
        let a2 = Number.parseInt(r2, 16);
        return [a2 >> 16 & 255, a2 >> 8 & 255, 255 & a2];
      }, enumerable: false }, hexToAnsi256: { value: (e3) => t2.rgbToAnsi256(...t2.hexToRgb(e3)), enumerable: false } }), t2;
    } });
  };
  __namedExportsObject["__chunk_7723"] = (e, t, r) => {
    "use strict";
    r.r(t), r.d(t, { DiagConsoleLogger: () => $, DiagLogLevel: () => a, INVALID_SPANID: () => ed, INVALID_SPAN_CONTEXT: () => ep, INVALID_TRACEID: () => eh, ProxyTracer: () => eI, ProxyTracerProvider: () => eN, ROOT_CONTEXT: () => R, SamplingDecision: () => s, SpanKind: () => o, SpanStatusCode: () => l, TraceFlags: () => i, ValueType: () => n, baggageEntryMetadataFromString: () => C, context: () => eF, createContextKey: () => I, createNoopMeter: () => ee, createTraceState: () => eU, default: () => e2, defaultTextMapGetter: () => et, defaultTextMapSetter: () => er, diag: () => ez, isSpanContextValid: () => eA, isValidSpanId: () => eS, isValidTraceId: () => eO, metrics: () => eH, propagation: () => eQ, trace: () => e1 });
    var a, n, i, s, o, l, u = "object" == typeof globalThis ? globalThis : "object" == typeof self ? self : "object" == typeof window ? window : "object" == typeof r.g ? r.g : {}, c = "1.9.0", d = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/, h = function(e3) {
      var t2 = /* @__PURE__ */ new Set([e3]), r2 = /* @__PURE__ */ new Set(), a2 = e3.match(d);
      if (!a2)
        return function() {
          return false;
        };
      var n2 = { major: +a2[1], minor: +a2[2], patch: +a2[3], prerelease: a2[4] };
      if (null != n2.prerelease)
        return function(t3) {
          return t3 === e3;
        };
      function i2(e4) {
        return r2.add(e4), false;
      }
      return function(e4) {
        if (t2.has(e4))
          return true;
        if (r2.has(e4))
          return false;
        var a3 = e4.match(d);
        if (!a3)
          return i2(e4);
        var s2 = { major: +a3[1], minor: +a3[2], patch: +a3[3], prerelease: a3[4] };
        return null != s2.prerelease || n2.major !== s2.major ? i2(e4) : 0 === n2.major ? n2.minor === s2.minor && n2.patch <= s2.patch ? (t2.add(e4), true) : i2(e4) : n2.minor <= s2.minor ? (t2.add(e4), true) : i2(e4);
      };
    }(c), p = Symbol.for("opentelemetry.js.api." + c.split(".")[0]);
    function f(e3, t2, r2, a2) {
      void 0 === a2 && (a2 = false);
      var n2, i2 = u[p] = null !== (n2 = u[p]) && void 0 !== n2 ? n2 : { version: c };
      if (!a2 && i2[e3]) {
        var s2 = Error("@opentelemetry/api: Attempted duplicate registration of API: " + e3);
        return r2.error(s2.stack || s2.message), false;
      }
      if (i2.version !== c) {
        var s2 = Error("@opentelemetry/api: Registration of version v" + i2.version + " for " + e3 + " does not match previously registered API v" + c);
        return r2.error(s2.stack || s2.message), false;
      }
      return i2[e3] = t2, r2.debug("@opentelemetry/api: Registered a global for " + e3 + " v" + c + "."), true;
    }
    function m(e3) {
      var t2, r2, a2 = null === (t2 = u[p]) || void 0 === t2 ? void 0 : t2.version;
      if (a2 && h(a2))
        return null === (r2 = u[p]) || void 0 === r2 ? void 0 : r2[e3];
    }
    function g(e3, t2) {
      t2.debug("@opentelemetry/api: Unregistering a global for " + e3 + " v" + c + ".");
      var r2 = u[p];
      r2 && delete r2[e3];
    }
    var y = function(e3, t2) {
      var r2 = "function" == typeof Symbol && e3[Symbol.iterator];
      if (!r2)
        return e3;
      var a2, n2, i2 = r2.call(e3), s2 = [];
      try {
        for (; (void 0 === t2 || t2-- > 0) && !(a2 = i2.next()).done; )
          s2.push(a2.value);
      } catch (e4) {
        n2 = { error: e4 };
      } finally {
        try {
          a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      return s2;
    }, b = function(e3, t2, r2) {
      if (r2 || 2 == arguments.length)
        for (var a2, n2 = 0, i2 = t2.length; n2 < i2; n2++)
          !a2 && n2 in t2 || (a2 || (a2 = Array.prototype.slice.call(t2, 0, n2)), a2[n2] = t2[n2]);
      return e3.concat(a2 || Array.prototype.slice.call(t2));
    }, v = function() {
      function e3(e4) {
        this._namespace = e4.namespace || "DiagComponentLogger";
      }
      return e3.prototype.debug = function() {
        for (var e4 = [], t2 = 0; t2 < arguments.length; t2++)
          e4[t2] = arguments[t2];
        return _("debug", this._namespace, e4);
      }, e3.prototype.error = function() {
        for (var e4 = [], t2 = 0; t2 < arguments.length; t2++)
          e4[t2] = arguments[t2];
        return _("error", this._namespace, e4);
      }, e3.prototype.info = function() {
        for (var e4 = [], t2 = 0; t2 < arguments.length; t2++)
          e4[t2] = arguments[t2];
        return _("info", this._namespace, e4);
      }, e3.prototype.warn = function() {
        for (var e4 = [], t2 = 0; t2 < arguments.length; t2++)
          e4[t2] = arguments[t2];
        return _("warn", this._namespace, e4);
      }, e3.prototype.verbose = function() {
        for (var e4 = [], t2 = 0; t2 < arguments.length; t2++)
          e4[t2] = arguments[t2];
        return _("verbose", this._namespace, e4);
      }, e3;
    }();
    function _(e3, t2, r2) {
      var a2 = m("diag");
      if (a2)
        return r2.unshift(t2), a2[e3].apply(a2, b([], y(r2), false));
    }
    !function(e3) {
      e3[e3.NONE = 0] = "NONE", e3[e3.ERROR = 30] = "ERROR", e3[e3.WARN = 50] = "WARN", e3[e3.INFO = 60] = "INFO", e3[e3.DEBUG = 70] = "DEBUG", e3[e3.VERBOSE = 80] = "VERBOSE", e3[e3.ALL = 9999] = "ALL";
    }(a || (a = {}));
    var w = function(e3, t2) {
      var r2 = "function" == typeof Symbol && e3[Symbol.iterator];
      if (!r2)
        return e3;
      var a2, n2, i2 = r2.call(e3), s2 = [];
      try {
        for (; (void 0 === t2 || t2-- > 0) && !(a2 = i2.next()).done; )
          s2.push(a2.value);
      } catch (e4) {
        n2 = { error: e4 };
      } finally {
        try {
          a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      return s2;
    }, E = function(e3, t2, r2) {
      if (r2 || 2 == arguments.length)
        for (var a2, n2 = 0, i2 = t2.length; n2 < i2; n2++)
          !a2 && n2 in t2 || (a2 || (a2 = Array.prototype.slice.call(t2, 0, n2)), a2[n2] = t2[n2]);
      return e3.concat(a2 || Array.prototype.slice.call(t2));
    }, x = function() {
      function e3() {
        function e4(e5) {
          return function() {
            for (var t3 = [], r2 = 0; r2 < arguments.length; r2++)
              t3[r2] = arguments[r2];
            var a2 = m("diag");
            if (a2)
              return a2[e5].apply(a2, E([], w(t3), false));
          };
        }
        var t2 = this;
        t2.setLogger = function(e5, r2) {
          if (void 0 === r2 && (r2 = { logLevel: a.INFO }), e5 === t2) {
            var n2, i2, s2, o2 = Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            return t2.error(null !== (n2 = o2.stack) && void 0 !== n2 ? n2 : o2.message), false;
          }
          "number" == typeof r2 && (r2 = { logLevel: r2 });
          var l2 = m("diag"), u2 = function(e6, t3) {
            function r3(r4, a2) {
              var n3 = t3[r4];
              return "function" == typeof n3 && e6 >= a2 ? n3.bind(t3) : function() {
              };
            }
            return e6 < a.NONE ? e6 = a.NONE : e6 > a.ALL && (e6 = a.ALL), t3 = t3 || {}, { error: r3("error", a.ERROR), warn: r3("warn", a.WARN), info: r3("info", a.INFO), debug: r3("debug", a.DEBUG), verbose: r3("verbose", a.VERBOSE) };
          }(null !== (i2 = r2.logLevel) && void 0 !== i2 ? i2 : a.INFO, e5);
          if (l2 && !r2.suppressOverrideMessage) {
            var c2 = null !== (s2 = Error().stack) && void 0 !== s2 ? s2 : "<failed to generate stacktrace>";
            l2.warn("Current logger will be overwritten from " + c2), u2.warn("Current logger will overwrite one already registered from " + c2);
          }
          return f("diag", u2, t2, true);
        }, t2.disable = function() {
          g("diag", t2);
        }, t2.createComponentLogger = function(e5) {
          return new v(e5);
        }, t2.verbose = e4("verbose"), t2.debug = e4("debug"), t2.info = e4("info"), t2.warn = e4("warn"), t2.error = e4("error");
      }
      return e3.instance = function() {
        return this._instance || (this._instance = new e3()), this._instance;
      }, e3;
    }(), O = function(e3, t2) {
      var r2 = "function" == typeof Symbol && e3[Symbol.iterator];
      if (!r2)
        return e3;
      var a2, n2, i2 = r2.call(e3), s2 = [];
      try {
        for (; (void 0 === t2 || t2-- > 0) && !(a2 = i2.next()).done; )
          s2.push(a2.value);
      } catch (e4) {
        n2 = { error: e4 };
      } finally {
        try {
          a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      return s2;
    }, S = function(e3) {
      var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e3[t2], a2 = 0;
      if (r2)
        return r2.call(e3);
      if (e3 && "number" == typeof e3.length)
        return { next: function() {
          return e3 && a2 >= e3.length && (e3 = void 0), { value: e3 && e3[a2++], done: !e3 };
        } };
      throw TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, A = function() {
      function e3(e4) {
        this._entries = e4 ? new Map(e4) : /* @__PURE__ */ new Map();
      }
      return e3.prototype.getEntry = function(e4) {
        var t2 = this._entries.get(e4);
        if (t2)
          return Object.assign({}, t2);
      }, e3.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(e4) {
          var t2 = O(e4, 2);
          return [t2[0], t2[1]];
        });
      }, e3.prototype.setEntry = function(t2, r2) {
        var a2 = new e3(this._entries);
        return a2._entries.set(t2, r2), a2;
      }, e3.prototype.removeEntry = function(t2) {
        var r2 = new e3(this._entries);
        return r2._entries.delete(t2), r2;
      }, e3.prototype.removeEntries = function() {
        for (var t2, r2, a2 = [], n2 = 0; n2 < arguments.length; n2++)
          a2[n2] = arguments[n2];
        var i2 = new e3(this._entries);
        try {
          for (var s2 = S(a2), o2 = s2.next(); !o2.done; o2 = s2.next()) {
            var l2 = o2.value;
            i2._entries.delete(l2);
          }
        } catch (e4) {
          t2 = { error: e4 };
        } finally {
          try {
            o2 && !o2.done && (r2 = s2.return) && r2.call(s2);
          } finally {
            if (t2)
              throw t2.error;
          }
        }
        return i2;
      }, e3.prototype.clear = function() {
        return new e3();
      }, e3;
    }(), k = Symbol("BaggageEntryMetadata"), T = x.instance();
    function P(e3) {
      return void 0 === e3 && (e3 = {}), new A(new Map(Object.entries(e3)));
    }
    function C(e3) {
      return "string" != typeof e3 && (T.error("Cannot create baggage metadata from unknown type: " + typeof e3), e3 = ""), { __TYPE__: k, toString: function() {
        return e3;
      } };
    }
    function I(e3) {
      return Symbol.for(e3);
    }
    var R = new function e3(t2) {
      var r2 = this;
      r2._currentContext = t2 ? new Map(t2) : /* @__PURE__ */ new Map(), r2.getValue = function(e4) {
        return r2._currentContext.get(e4);
      }, r2.setValue = function(t3, a2) {
        var n2 = new e3(r2._currentContext);
        return n2._currentContext.set(t3, a2), n2;
      }, r2.deleteValue = function(t3) {
        var a2 = new e3(r2._currentContext);
        return a2._currentContext.delete(t3), a2;
      };
    }(), N = [{ n: "error", c: "error" }, { n: "warn", c: "warn" }, { n: "info", c: "info" }, { n: "debug", c: "debug" }, { n: "verbose", c: "trace" }], $ = function() {
      for (var e3 = 0; e3 < N.length; e3++)
        this[N[e3].n] = function(e4) {
          return function() {
            for (var t2 = [], r2 = 0; r2 < arguments.length; r2++)
              t2[r2] = arguments[r2];
            if (console) {
              var a2 = console[e4];
              if ("function" != typeof a2 && (a2 = console.log), "function" == typeof a2)
                return a2.apply(console, t2);
            }
          };
        }(N[e3].c);
    }, j = function() {
      var e3 = function(t2, r2) {
        return (e3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t3) {
          e4.__proto__ = t3;
        } || function(e4, t3) {
          for (var r3 in t3)
            Object.prototype.hasOwnProperty.call(t3, r3) && (e4[r3] = t3[r3]);
        })(t2, r2);
      };
      return function(t2, r2) {
        if ("function" != typeof r2 && null !== r2)
          throw TypeError("Class extends value " + String(r2) + " is not a constructor or null");
        function a2() {
          this.constructor = t2;
        }
        e3(t2, r2), t2.prototype = null === r2 ? Object.create(r2) : (a2.prototype = r2.prototype, new a2());
      };
    }(), L = function() {
      function e3() {
      }
      return e3.prototype.createGauge = function(e4, t2) {
        return W;
      }, e3.prototype.createHistogram = function(e4, t2) {
        return J;
      }, e3.prototype.createCounter = function(e4, t2) {
        return V;
      }, e3.prototype.createUpDownCounter = function(e4, t2) {
        return K;
      }, e3.prototype.createObservableGauge = function(e4, t2) {
        return Y;
      }, e3.prototype.createObservableCounter = function(e4, t2) {
        return X;
      }, e3.prototype.createObservableUpDownCounter = function(e4, t2) {
        return Q;
      }, e3.prototype.addBatchObservableCallback = function(e4, t2) {
      }, e3.prototype.removeBatchObservableCallback = function(e4) {
      }, e3;
    }(), M = function() {
    }, D = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2.prototype.add = function(e4, t3) {
      }, t2;
    }(M), U = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2.prototype.add = function(e4, t3) {
      }, t2;
    }(M), F = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2.prototype.record = function(e4, t3) {
      }, t2;
    }(M), z = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2.prototype.record = function(e4, t3) {
      }, t2;
    }(M), B = function() {
      function e3() {
      }
      return e3.prototype.addCallback = function(e4) {
      }, e3.prototype.removeCallback = function(e4) {
      }, e3;
    }(), q = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2;
    }(B), H = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2;
    }(B), Z = function(e3) {
      function t2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      return j(t2, e3), t2;
    }(B), G = new L(), V = new D(), W = new F(), J = new z(), K = new U(), X = new q(), Y = new H(), Q = new Z();
    function ee() {
      return G;
    }
    !function(e3) {
      e3[e3.INT = 0] = "INT", e3[e3.DOUBLE = 1] = "DOUBLE";
    }(n || (n = {}));
    var et = { get: function(e3, t2) {
      if (null != e3)
        return e3[t2];
    }, keys: function(e3) {
      return null == e3 ? [] : Object.keys(e3);
    } }, er = { set: function(e3, t2, r2) {
      null != e3 && (e3[t2] = r2);
    } }, ea = function(e3, t2) {
      var r2 = "function" == typeof Symbol && e3[Symbol.iterator];
      if (!r2)
        return e3;
      var a2, n2, i2 = r2.call(e3), s2 = [];
      try {
        for (; (void 0 === t2 || t2-- > 0) && !(a2 = i2.next()).done; )
          s2.push(a2.value);
      } catch (e4) {
        n2 = { error: e4 };
      } finally {
        try {
          a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      return s2;
    }, en = function(e3, t2, r2) {
      if (r2 || 2 == arguments.length)
        for (var a2, n2 = 0, i2 = t2.length; n2 < i2; n2++)
          !a2 && n2 in t2 || (a2 || (a2 = Array.prototype.slice.call(t2, 0, n2)), a2[n2] = t2[n2]);
      return e3.concat(a2 || Array.prototype.slice.call(t2));
    }, ei = function() {
      function e3() {
      }
      return e3.prototype.active = function() {
        return R;
      }, e3.prototype.with = function(e4, t2, r2) {
        for (var a2 = [], n2 = 3; n2 < arguments.length; n2++)
          a2[n2 - 3] = arguments[n2];
        return t2.call.apply(t2, en([r2], ea(a2), false));
      }, e3.prototype.bind = function(e4, t2) {
        return t2;
      }, e3.prototype.enable = function() {
        return this;
      }, e3.prototype.disable = function() {
        return this;
      }, e3;
    }(), es = function(e3, t2) {
      var r2 = "function" == typeof Symbol && e3[Symbol.iterator];
      if (!r2)
        return e3;
      var a2, n2, i2 = r2.call(e3), s2 = [];
      try {
        for (; (void 0 === t2 || t2-- > 0) && !(a2 = i2.next()).done; )
          s2.push(a2.value);
      } catch (e4) {
        n2 = { error: e4 };
      } finally {
        try {
          a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      return s2;
    }, eo = function(e3, t2, r2) {
      if (r2 || 2 == arguments.length)
        for (var a2, n2 = 0, i2 = t2.length; n2 < i2; n2++)
          !a2 && n2 in t2 || (a2 || (a2 = Array.prototype.slice.call(t2, 0, n2)), a2[n2] = t2[n2]);
      return e3.concat(a2 || Array.prototype.slice.call(t2));
    }, el = "context", eu = new ei(), ec = function() {
      function e3() {
      }
      return e3.getInstance = function() {
        return this._instance || (this._instance = new e3()), this._instance;
      }, e3.prototype.setGlobalContextManager = function(e4) {
        return f(el, e4, x.instance());
      }, e3.prototype.active = function() {
        return this._getContextManager().active();
      }, e3.prototype.with = function(e4, t2, r2) {
        for (var a2, n2 = [], i2 = 3; i2 < arguments.length; i2++)
          n2[i2 - 3] = arguments[i2];
        return (a2 = this._getContextManager()).with.apply(a2, eo([e4, t2, r2], es(n2), false));
      }, e3.prototype.bind = function(e4, t2) {
        return this._getContextManager().bind(e4, t2);
      }, e3.prototype._getContextManager = function() {
        return m(el) || eu;
      }, e3.prototype.disable = function() {
        this._getContextManager().disable(), g(el, x.instance());
      }, e3;
    }();
    !function(e3) {
      e3[e3.NONE = 0] = "NONE", e3[e3.SAMPLED = 1] = "SAMPLED";
    }(i || (i = {}));
    var ed = "0000000000000000", eh = "00000000000000000000000000000000", ep = { traceId: eh, spanId: ed, traceFlags: i.NONE }, ef = function() {
      function e3(e4) {
        void 0 === e4 && (e4 = ep), this._spanContext = e4;
      }
      return e3.prototype.spanContext = function() {
        return this._spanContext;
      }, e3.prototype.setAttribute = function(e4, t2) {
        return this;
      }, e3.prototype.setAttributes = function(e4) {
        return this;
      }, e3.prototype.addEvent = function(e4, t2) {
        return this;
      }, e3.prototype.addLink = function(e4) {
        return this;
      }, e3.prototype.addLinks = function(e4) {
        return this;
      }, e3.prototype.setStatus = function(e4) {
        return this;
      }, e3.prototype.updateName = function(e4) {
        return this;
      }, e3.prototype.end = function(e4) {
      }, e3.prototype.isRecording = function() {
        return false;
      }, e3.prototype.recordException = function(e4, t2) {
      }, e3;
    }(), em = I("OpenTelemetry Context Key SPAN");
    function eg(e3) {
      return e3.getValue(em) || void 0;
    }
    function ey() {
      return eg(ec.getInstance().active());
    }
    function eb(e3, t2) {
      return e3.setValue(em, t2);
    }
    function ev(e3) {
      return e3.deleteValue(em);
    }
    function e_(e3, t2) {
      return eb(e3, new ef(t2));
    }
    function ew(e3) {
      var t2;
      return null === (t2 = eg(e3)) || void 0 === t2 ? void 0 : t2.spanContext();
    }
    var eE = /^([0-9a-f]{32})$/i, ex = /^[0-9a-f]{16}$/i;
    function eO(e3) {
      return eE.test(e3) && e3 !== eh;
    }
    function eS(e3) {
      return ex.test(e3) && e3 !== ed;
    }
    function eA(e3) {
      return eO(e3.traceId) && eS(e3.spanId);
    }
    function ek(e3) {
      return new ef(e3);
    }
    var eT = ec.getInstance(), eP = function() {
      function e3() {
      }
      return e3.prototype.startSpan = function(e4, t2, r2) {
        if (void 0 === r2 && (r2 = eT.active()), null == t2 ? void 0 : t2.root)
          return new ef();
        var a2 = r2 && ew(r2);
        return "object" == typeof a2 && "string" == typeof a2.spanId && "string" == typeof a2.traceId && "number" == typeof a2.traceFlags && eA(a2) ? new ef(a2) : new ef();
      }, e3.prototype.startActiveSpan = function(e4, t2, r2, a2) {
        if (!(arguments.length < 2)) {
          2 == arguments.length ? s2 = t2 : 3 == arguments.length ? (n2 = t2, s2 = r2) : (n2 = t2, i2 = r2, s2 = a2);
          var n2, i2, s2, o2 = null != i2 ? i2 : eT.active(), l2 = this.startSpan(e4, n2, o2), u2 = eb(o2, l2);
          return eT.with(u2, s2, void 0, l2);
        }
      }, e3;
    }(), eC = new eP(), eI = function() {
      function e3(e4, t2, r2, a2) {
        this._provider = e4, this.name = t2, this.version = r2, this.options = a2;
      }
      return e3.prototype.startSpan = function(e4, t2, r2) {
        return this._getTracer().startSpan(e4, t2, r2);
      }, e3.prototype.startActiveSpan = function(e4, t2, r2, a2) {
        var n2 = this._getTracer();
        return Reflect.apply(n2.startActiveSpan, n2, arguments);
      }, e3.prototype._getTracer = function() {
        if (this._delegate)
          return this._delegate;
        var e4 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        return e4 ? (this._delegate = e4, this._delegate) : eC;
      }, e3;
    }(), eR = new (function() {
      function e3() {
      }
      return e3.prototype.getTracer = function(e4, t2, r2) {
        return new eP();
      }, e3;
    }())(), eN = function() {
      function e3() {
      }
      return e3.prototype.getTracer = function(e4, t2, r2) {
        var a2;
        return null !== (a2 = this.getDelegateTracer(e4, t2, r2)) && void 0 !== a2 ? a2 : new eI(this, e4, t2, r2);
      }, e3.prototype.getDelegate = function() {
        var e4;
        return null !== (e4 = this._delegate) && void 0 !== e4 ? e4 : eR;
      }, e3.prototype.setDelegate = function(e4) {
        this._delegate = e4;
      }, e3.prototype.getDelegateTracer = function(e4, t2, r2) {
        var a2;
        return null === (a2 = this._delegate) || void 0 === a2 ? void 0 : a2.getTracer(e4, t2, r2);
      }, e3;
    }();
    !function(e3) {
      e3[e3.NOT_RECORD = 0] = "NOT_RECORD", e3[e3.RECORD = 1] = "RECORD", e3[e3.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
    }(s || (s = {})), function(e3) {
      e3[e3.INTERNAL = 0] = "INTERNAL", e3[e3.SERVER = 1] = "SERVER", e3[e3.CLIENT = 2] = "CLIENT", e3[e3.PRODUCER = 3] = "PRODUCER", e3[e3.CONSUMER = 4] = "CONSUMER";
    }(o || (o = {})), function(e3) {
      e3[e3.UNSET = 0] = "UNSET", e3[e3.OK = 1] = "OK", e3[e3.ERROR = 2] = "ERROR";
    }(l || (l = {}));
    var e$ = "[_0-9a-z-*/]", ej = RegExp("^(?:[a-z]" + e$ + "{0,255}|" + ("[a-z0-9]" + e$) + "{0,240}@[a-z]" + e$ + "{0,13})$"), eL = /^[ -~]{0,255}[!-~]$/, eM = /,|=/, eD = function() {
      function e3(e4) {
        this._internalState = /* @__PURE__ */ new Map(), e4 && this._parse(e4);
      }
      return e3.prototype.set = function(e4, t2) {
        var r2 = this._clone();
        return r2._internalState.has(e4) && r2._internalState.delete(e4), r2._internalState.set(e4, t2), r2;
      }, e3.prototype.unset = function(e4) {
        var t2 = this._clone();
        return t2._internalState.delete(e4), t2;
      }, e3.prototype.get = function(e4) {
        return this._internalState.get(e4);
      }, e3.prototype.serialize = function() {
        var e4 = this;
        return this._keys().reduce(function(t2, r2) {
          return t2.push(r2 + "=" + e4.get(r2)), t2;
        }, []).join(",");
      }, e3.prototype._parse = function(e4) {
        !(e4.length > 512) && (this._internalState = e4.split(",").reverse().reduce(function(e5, t2) {
          var r2 = t2.trim(), a2 = r2.indexOf("=");
          if (-1 !== a2) {
            var n2 = r2.slice(0, a2), i2 = r2.slice(a2 + 1, t2.length);
            ej.test(n2) && eL.test(i2) && !eM.test(i2) && e5.set(n2, i2);
          }
          return e5;
        }, /* @__PURE__ */ new Map()), this._internalState.size > 32 && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, 32))));
      }, e3.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      }, e3.prototype._clone = function() {
        var t2 = new e3();
        return t2._internalState = new Map(this._internalState), t2;
      }, e3;
    }();
    function eU(e3) {
      return new eD(e3);
    }
    var eF = ec.getInstance(), ez = x.instance(), eB = new (function() {
      function e3() {
      }
      return e3.prototype.getMeter = function(e4, t2, r2) {
        return G;
      }, e3;
    }())(), eq = "metrics", eH = function() {
      function e3() {
      }
      return e3.getInstance = function() {
        return this._instance || (this._instance = new e3()), this._instance;
      }, e3.prototype.setGlobalMeterProvider = function(e4) {
        return f(eq, e4, x.instance());
      }, e3.prototype.getMeterProvider = function() {
        return m(eq) || eB;
      }, e3.prototype.getMeter = function(e4, t2, r2) {
        return this.getMeterProvider().getMeter(e4, t2, r2);
      }, e3.prototype.disable = function() {
        g(eq, x.instance());
      }, e3;
    }().getInstance(), eZ = function() {
      function e3() {
      }
      return e3.prototype.inject = function(e4, t2) {
      }, e3.prototype.extract = function(e4, t2) {
        return e4;
      }, e3.prototype.fields = function() {
        return [];
      }, e3;
    }(), eG = I("OpenTelemetry Baggage Key");
    function eV(e3) {
      return e3.getValue(eG) || void 0;
    }
    function eW() {
      return eV(ec.getInstance().active());
    }
    function eJ(e3, t2) {
      return e3.setValue(eG, t2);
    }
    function eK(e3) {
      return e3.deleteValue(eG);
    }
    var eX = "propagation", eY = new eZ(), eQ = function() {
      function e3() {
        this.createBaggage = P, this.getBaggage = eV, this.getActiveBaggage = eW, this.setBaggage = eJ, this.deleteBaggage = eK;
      }
      return e3.getInstance = function() {
        return this._instance || (this._instance = new e3()), this._instance;
      }, e3.prototype.setGlobalPropagator = function(e4) {
        return f(eX, e4, x.instance());
      }, e3.prototype.inject = function(e4, t2, r2) {
        return void 0 === r2 && (r2 = er), this._getGlobalPropagator().inject(e4, t2, r2);
      }, e3.prototype.extract = function(e4, t2, r2) {
        return void 0 === r2 && (r2 = et), this._getGlobalPropagator().extract(e4, t2, r2);
      }, e3.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      }, e3.prototype.disable = function() {
        g(eX, x.instance());
      }, e3.prototype._getGlobalPropagator = function() {
        return m(eX) || eY;
      }, e3;
    }().getInstance(), e0 = "trace", e1 = function() {
      function e3() {
        this._proxyTracerProvider = new eN(), this.wrapSpanContext = ek, this.isSpanContextValid = eA, this.deleteSpan = ev, this.getSpan = eg, this.getActiveSpan = ey, this.getSpanContext = ew, this.setSpan = eb, this.setSpanContext = e_;
      }
      return e3.getInstance = function() {
        return this._instance || (this._instance = new e3()), this._instance;
      }, e3.prototype.setGlobalTracerProvider = function(e4) {
        var t2 = f(e0, this._proxyTracerProvider, x.instance());
        return t2 && this._proxyTracerProvider.setDelegate(e4), t2;
      }, e3.prototype.getTracerProvider = function() {
        return m(e0) || this._proxyTracerProvider;
      }, e3.prototype.getTracer = function(e4, t2) {
        return this.getTracerProvider().getTracer(e4, t2);
      }, e3.prototype.disable = function() {
        g(e0, x.instance()), this._proxyTracerProvider = new eN();
      }, e3;
    }().getInstance();
    let e2 = { context: eF, diag: ez, metrics: eH, propagation: eQ, trace: e1 };
  };
  return __namedExportsObject;
};
export {
  __getNamedExports
};
